/** Declaration file generated by dts-gen */

export class Dir {
    constructor(...args: any[]);

    close(...args: any[]): void;

    closeSync(...args: any[]): void;

    entries(...args: any[]): void;

    read(...args: any[]): void;

    readSync(...args: any[]): void;

}

export class Dirent {
    constructor(...args: any[]);

    isBlockDevice(...args: any[]): void;

    isCharacterDevice(...args: any[]): void;

    isDirectory(...args: any[]): void;

    isFIFO(...args: any[]): void;

    isFile(...args: any[]): void;

    isSocket(...args: any[]): void;

    isSymbolicLink(...args: any[]): void;

}

export class FileReadStream {
    constructor(path: any, options: any);

    close(cb: any): void;

    open(args: any): any;

    static addAbortSignal(signal: any, stream: any): any;

    static captureRejectionSymbol: any;

    static captureRejections: boolean;

    static compose(streams: any): any;

    static defaultMaxListeners: number;

    static destroy(stream: any, err: any): any;

    static errorMonitor: any;

    static finished(stream: any, options: any, callback: any, ...args: any[]): any;

    static from(iterable: any, opts: any): any;

    static getEventListeners(emitterOrTarget: any, type: any): any;

    static init(opts: any): void;

    static isDisturbed(stream: any): any;

    static isErrored(stream: any): any;

    static isReadable(stream: any): any;

    static kMaxEventTargetListeners: any;

    static kMaxEventTargetListenersWarned: any;

    static listenerCount(emitter: any, type: any): any;

    static on(emitter: any, event: any, options: any): any;

    static once(emitter: any, name: any, options: any): any;

    static pipeline(streams: any): any;

    static setMaxListeners(n: any, eventTargets: any): void;

    static usingDomains: boolean;

    static wrap(src: any, options: any): any;

}

export class FileWriteStream {
    constructor(path: any, options: any);

    close(cb: any): void;

    destroySoon(chunk: any, encoding: any, cb: any): any;

    open(args: any): any;

    static addAbortSignal(signal: any, stream: any): any;

    static captureRejectionSymbol: any;

    static captureRejections: boolean;

    static compose(streams: any): any;

    static defaultMaxListeners: number;

    static destroy(stream: any, err: any): any;

    static errorMonitor: any;

    static finished(stream: any, options: any, callback: any, ...args: any[]): any;

    static getEventListeners(emitterOrTarget: any, type: any): any;

    static init(opts: any): void;

    static isDisturbed(stream: any): any;

    static isErrored(stream: any): any;

    static isReadable(stream: any): any;

    static kMaxEventTargetListeners: any;

    static kMaxEventTargetListenersWarned: any;

    static listenerCount(emitter: any, type: any): any;

    static on(emitter: any, event: any, options: any): any;

    static once(emitter: any, name: any, options: any): any;

    static pipeline(streams: any): any;

    static setMaxListeners(n: any, eventTargets: any): void;

    static usingDomains: boolean;

}

export class ReadStream {
    constructor(path: any, options: any);

    close(cb: any): void;

    open(args: any): any;

    static addAbortSignal(signal: any, stream: any): any;

    static captureRejectionSymbol: any;

    static captureRejections: boolean;

    static compose(streams: any): any;

    static defaultMaxListeners: number;

    static destroy(stream: any, err: any): any;

    static errorMonitor: any;

    static finished(stream: any, options: any, callback: any, ...args: any[]): any;

    static from(iterable: any, opts: any): any;

    static getEventListeners(emitterOrTarget: any, type: any): any;

    static init(opts: any): void;

    static isDisturbed(stream: any): any;

    static isErrored(stream: any): any;

    static isReadable(stream: any): any;

    static kMaxEventTargetListeners: any;

    static kMaxEventTargetListenersWarned: any;

    static listenerCount(emitter: any, type: any): any;

    static on(emitter: any, event: any, options: any): any;

    static once(emitter: any, name: any, options: any): any;

    static pipeline(streams: any): any;

    static setMaxListeners(n: any, eventTargets: any): void;

    static usingDomains: boolean;

    static wrap(src: any, options: any): any;

}

export class Stats {
    constructor(dev: any, mode: any, nlink: any, uid: any, gid: any, rdev: any, blksize: any, ino: any, size: any, blocks: any, atimeMs: any, mtimeMs: any, ctimeMs: any, birthtimeMs: any);

    isFile(): any;

}

export class WriteStream {
    constructor(path: any, options: any);

    close(cb: any): void;

    destroySoon(chunk: any, encoding: any, cb: any): any;

    open(args: any): any;

    static addAbortSignal(signal: any, stream: any): any;

    static captureRejectionSymbol: any;

    static captureRejections: boolean;

    static compose(streams: any): any;

    static defaultMaxListeners: number;

    static destroy(stream: any, err: any): any;

    static errorMonitor: any;

    static finished(stream: any, options: any, callback: any, ...args: any[]): any;

    static getEventListeners(emitterOrTarget: any, type: any): any;

    static init(opts: any): void;

    static isDisturbed(stream: any): any;

    static isErrored(stream: any): any;

    static isReadable(stream: any): any;

    static kMaxEventTargetListeners: any;

    static kMaxEventTargetListenersWarned: any;

    static listenerCount(emitter: any, type: any): any;

    static on(emitter: any, event: any, options: any): any;

    static once(emitter: any, name: any, options: any): any;

    static pipeline(streams: any): any;

    static setMaxListeners(n: any, eventTargets: any): void;

    static usingDomains: boolean;

}

export const F_OK: number;

export const R_OK: number;

export const W_OK: number;

export const X_OK: number;

export const constants: {
    COPYFILE_EXCL: number;
    COPYFILE_FICLONE: number;
    COPYFILE_FICLONE_FORCE: number;
    F_OK: number;
    O_APPEND: number;
    O_CREAT: number;
    O_EXCL: number;
    O_RDONLY: number;
    O_RDWR: number;
    O_TRUNC: number;
    O_WRONLY: number;
    R_OK: number;
    S_IFCHR: number;
    S_IFDIR: number;
    S_IFLNK: number;
    S_IFMT: number;
    S_IFREG: number;
    UV_DIRENT_BLOCK: number;
    UV_DIRENT_CHAR: number;
    UV_DIRENT_DIR: number;
    UV_DIRENT_FIFO: number;
    UV_DIRENT_FILE: number;
    UV_DIRENT_LINK: number;
    UV_DIRENT_SOCKET: number;
    UV_DIRENT_UNKNOWN: number;
    UV_FS_COPYFILE_EXCL: number;
    UV_FS_COPYFILE_FICLONE: number;
    UV_FS_COPYFILE_FICLONE_FORCE: number;
    UV_FS_O_FILEMAP: number;
    UV_FS_SYMLINK_DIR: number;
    UV_FS_SYMLINK_JUNCTION: number;
    W_OK: number;
    X_OK: number;
};

export const lchmod: any;

export const lchmodSync: any;

export function access(path: any, mode: any, callback: any): void;

export function accessSync(path: any, mode: any): void;

export function appendFile(path: any, data: any, options: any, callback: any): void;

export function appendFileSync(path: any, data: any, options: any): void;

export function chmod(path: any, mode: any, callback: any): void;

export function chmodSync(path: any, mode: any): void;

export function chown(path: any, uid: any, gid: any, callback: any): void;

export function chownSync(path: any, uid: any, gid: any): void;

export function close(fd: any, cb: any, ...args: any[]): any;

export function closeSync(fd: any, ...args: any[]): void;

export function copyFile(src: any, dest: any, mode: any, callback: any): void;

export function copyFileSync(src: any, dest: any, mode: any): void;

export function cp(src: any, dest: any, options: any, callback: any): void;

export function cpSync(src: any, dest: any, options: any): void;

export function createReadStream(path: any, options: any): any;

export function createWriteStream(path: any, options: any): any;

export function exists(path: any, callback: any): any;

export function existsSync(path: any): any;

export function fchmod(fd: any, mode: any, callback: any): void;

export function fchmodSync(fd: any, mode: any): void;

export function fchown(fd: any, uid: any, gid: any, callback: any): void;

export function fchownSync(fd: any, uid: any, gid: any): void;

export function fdatasync(fd: any, callback: any): void;

export function fdatasyncSync(fd: any): void;

export function fstat(fd: any, options: any, callback: any): void;

export function fstatSync(fd: any, options: any): any;

export function fsync(fd: any, callback: any): void;

export function fsyncSync(fd: any): void;

export function ftruncate(fd: any, len: any, callback: any): void;

export function ftruncateSync(fd: any, len: any): void;

export function futimes(fd: any, atime: any, mtime: any, callback: any): void;

export function futimesSync(fd: any, atime: any, mtime: any): void;

export function lchown(path: any, uid: any, gid: any, callback: any): void;

export function lchownSync(path: any, uid: any, gid: any): void;

export function link(existingPath: any, newPath: any, callback: any): void;

export function linkSync(existingPath: any, newPath: any): any;

export function lstat(path: any, options: any, callback: any): void;

export function lstatSync(path: any, options: any): any;

export function lutimes(path: any, atime: any, mtime: any, callback: any): void;

export function lutimesSync(path: any, atime: any, mtime: any): void;

export function mkdir(path: any, options: any, callback: any): void;

export function mkdirSync(path: any, options: any): any;

export function mkdtemp(prefix: any, options: any, callback: any): void;

export function mkdtempSync(prefix: any, options: any): any;

export function open(path: any, flags: any, mode: any, callback: any, ...args: any[]): void;

export function openSync(path: any, flags: any, mode: any): any;

export function opendir(path: any, options: any, callback: any): void;

export function opendirSync(path: any, options: any): any;

export function read(fd: any, buffer: any, offset: any, length: any, position: any, callback: any, ...args: any[]): any;

export function readFile(path: any, options: any, callback: any): void;

export function readFileSync(path: any, options: any): any;

export function readSync(fd: any, buffer: any, offset: any, length: any, position: any, ...args: any[]): any;

export function readdir(path: any, options: any, callback: any): void;

export function readdirSync(path: any, options: any): any;

export function readlink(path: any, options: any, callback: any): void;

export function readlinkSync(path: any, options: any): any;

export function readv(fd: any, buffers: any, position: any, callback: any): any;

export function readvSync(fd: any, buffers: any, position: any): any;

export function realpath(p: any, options: any, callback: any): any;

export function realpathSync(p: any, options: any): any;

export function rename(oldPath: any, newPath: any, callback: any): void;

export function renameSync(oldPath: any, newPath: any): void;

export function rm(path: any, options: any, callback: any): any;

export function rmSync(path: any, options: any): any;

export function rmdir(path: any, options: any, callback: any): any;

export function rmdirSync(path: any, options: any): any;

export function stat(path: any, options: any, callback: any): void;

export function statSync(path: any, options: any): any;

export function symlink(target: any, path: any, type_: any, callback_: any, ...args: any[]): void;

export function symlinkSync(target: any, path: any, type: any): void;

export function truncate(path: any, len: any, callback: any): any;

export function truncateSync(path: any, len: any): any;

export function unlink(path: any, callback: any): void;

export function unlinkSync(path: any): void;

export function unwatchFile(filename: any, listener: any): void;

export function utimes(path: any, atime: any, mtime: any, callback: any): void;

export function utimesSync(path: any, atime: any, mtime: any): void;

export function watch(filename: any, options: any, listener: any): any;

export function watchFile(filename: any, options: any, listener: any): any;

export function write(fd: any, buffer: any, offset: any, length: any, position: any, callback: any): any;

export function writeFile(path: any, data: any, options: any, callback: any): void;

export function writeFileSync(path: any, data: any, options: any): void;

export function writeSync(fd: any, buffer: any, offset: any, length: any, position: any): any;

export function writev(fd: any, buffers: any, position: any, callback: any): any;

export function writevSync(fd: any, buffers: any, position: any): any;

export namespace FileReadStream {
    class Duplex {
        constructor(options: any);

        cork(): void;

        end(chunk: any, encoding: any, cb: any): any;

        setDefaultEncoding(encoding: any): any;

        uncork(): void;

        write(chunk: any, encoding: any, cb: any): any;

        static Duplex: any;

        static addAbortSignal(signal: any, stream: any): any;

        static captureRejectionSymbol: any;

        static captureRejections: boolean;

        static compose(streams: any): any;

        static defaultMaxListeners: number;

        static destroy(stream: any, err: any): any;

        static errorMonitor: any;

        static finished(stream: any, options: any, callback: any, ...args: any[]): any;

        static from(body: any): any;

        static getEventListeners(emitterOrTarget: any, type: any): any;

        static init(opts: any): void;

        static isDisturbed(stream: any): any;

        static isErrored(stream: any): any;

        static isReadable(stream: any): any;

        static kMaxEventTargetListeners: any;

        static kMaxEventTargetListenersWarned: any;

        static listenerCount(emitter: any, type: any): any;

        static on(emitter: any, event: any, options: any): any;

        static once(emitter: any, name: any, options: any): any;

        static pipeline(streams: any): any;

        static setMaxListeners(n: any, eventTargets: any): void;

        static usingDomains: boolean;

        static wrap(src: any, options: any): any;

    }

    class EventEmitter {
        constructor(opts: any);

        addListener(type: any, listener: any): any;

        emit(type: any, args: any): any;

        eventNames(): any;

        getMaxListeners(): any;

        listenerCount(type: any): any;

        listeners(type: any): any;

        off(type: any, listener: any): any;

        on(type: any, listener: any): any;

        once(type: any, listener: any): any;

        prependListener(type: any, listener: any): any;

        prependOnceListener(type: any, listener: any): any;

        rawListeners(type: any): any;

        removeAllListeners(type: any, ...args: any[]): any;

        removeListener(type: any, listener: any): any;

        setMaxListeners(n: any): any;

        static EventEmitter: any;

        static captureRejectionSymbol: any;

        static captureRejections: boolean;

        static defaultMaxListeners: number;

        static errorMonitor: any;

        static getEventListeners(emitterOrTarget: any, type: any): any;

        static init(opts: any): void;

        static kMaxEventTargetListeners: any;

        static kMaxEventTargetListenersWarned: any;

        static listenerCount(emitter: any, type: any): any;

        static on(emitter: any, event: any, options: any): any;

        static once(emitter: any, name: any, options: any): any;

        static setMaxListeners(n: any, eventTargets: any): void;

        static usingDomains: boolean;

    }

    class EventEmitterAsyncResource {
        constructor(...args: any[]);

        emit(...args: any[]): void;

        emitDestroy(...args: any[]): void;

        static EventEmitterAsyncResource: any;

        static captureRejectionSymbol: any;

        static captureRejections: boolean;

        static defaultMaxListeners: number;

        static errorMonitor: any;

        static getEventListeners(emitterOrTarget: any, type: any): any;

        static init(opts: any): void;

        static kMaxEventTargetListeners: any;

        static kMaxEventTargetListenersWarned: any;

        static listenerCount(emitter: any, type: any): any;

        static on(emitter: any, event: any, options: any): any;

        static once(emitter: any, name: any, options: any): any;

        static setMaxListeners(n: any, eventTargets: any): void;

        static usingDomains: boolean;

    }

    class PassThrough {
        constructor(options: any);

        static PassThrough: any;

        static addAbortSignal(signal: any, stream: any): any;

        static captureRejectionSymbol: any;

        static captureRejections: boolean;

        static compose(streams: any): any;

        static defaultMaxListeners: number;

        static destroy(stream: any, err: any): any;

        static errorMonitor: any;

        static finished(stream: any, options: any, callback: any, ...args: any[]): any;

        static from(body: any): any;

        static getEventListeners(emitterOrTarget: any, type: any): any;

        static init(opts: any): void;

        static isDisturbed(stream: any): any;

        static isErrored(stream: any): any;

        static isReadable(stream: any): any;

        static kMaxEventTargetListeners: any;

        static kMaxEventTargetListenersWarned: any;

        static listenerCount(emitter: any, type: any): any;

        static on(emitter: any, event: any, options: any): any;

        static once(emitter: any, name: any, options: any): any;

        static pipeline(streams: any): any;

        static setMaxListeners(n: any, eventTargets: any): void;

        static usingDomains: boolean;

        static wrap(src: any, options: any): any;

    }

    class Readable {
        constructor(options: any);

        addListener(ev: any, fn: any): any;

        destroy(err: any, cb: any): any;

        filter(args: any): any;

        isPaused(): any;

        iterator(options: any): any;

        map(args: any): any;

        off(ev: any, fn: any): any;

        on(ev: any, fn: any): any;

        pause(): any;

        pipe(dest: any, pipeOpts: any): any;

        push(chunk: any, encoding: any): any;

        read(n: any): any;

        removeAllListeners(ev: any, ...args: any[]): any;

        removeListener(ev: any, fn: any): any;

        resume(): any;

        setEncoding(enc: any): any;

        unpipe(dest: any): any;

        unshift(chunk: any, encoding: any): any;

        wrap(stream: any): any;

        static Readable: any;

        static addAbortSignal(signal: any, stream: any): any;

        static captureRejectionSymbol: any;

        static captureRejections: boolean;

        static compose(streams: any): any;

        static defaultMaxListeners: number;

        static destroy(stream: any, err: any): any;

        static errorMonitor: any;

        static finished(stream: any, options: any, callback: any, ...args: any[]): any;

        static from(iterable: any, opts: any): any;

        static getEventListeners(emitterOrTarget: any, type: any): any;

        static init(opts: any): void;

        static isDisturbed(stream: any): any;

        static isErrored(stream: any): any;

        static isReadable(stream: any): any;

        static kMaxEventTargetListeners: any;

        static kMaxEventTargetListenersWarned: any;

        static listenerCount(emitter: any, type: any): any;

        static on(emitter: any, event: any, options: any): any;

        static once(emitter: any, name: any, options: any): any;

        static pipeline(streams: any): any;

        static setMaxListeners(n: any, eventTargets: any): void;

        static usingDomains: boolean;

        static wrap(src: any, options: any): any;

    }

    class ReadableState {
        constructor(options: any, stream: any, isDuplex: any);

    }

    class Stream {
        constructor(opts: any);

        pipe(dest: any, options: any): any;

        static Stream: any;

        static addAbortSignal(signal: any, stream: any): any;

        static captureRejectionSymbol: any;

        static captureRejections: boolean;

        static compose(streams: any): any;

        static defaultMaxListeners: number;

        static destroy(stream: any, err: any): any;

        static errorMonitor: any;

        static finished(stream: any, options: any, callback: any, ...args: any[]): any;

        static getEventListeners(emitterOrTarget: any, type: any): any;

        static init(opts: any): void;

        static isDisturbed(stream: any): any;

        static isErrored(stream: any): any;

        static isReadable(stream: any): any;

        static kMaxEventTargetListeners: any;

        static kMaxEventTargetListenersWarned: any;

        static listenerCount(emitter: any, type: any): any;

        static on(emitter: any, event: any, options: any): any;

        static once(emitter: any, name: any, options: any): any;

        static pipeline(streams: any): any;

        static setMaxListeners(n: any, eventTargets: any): void;

        static usingDomains: boolean;

    }

    class Transform {
        constructor(options: any);

        static Transform: any;

        static addAbortSignal(signal: any, stream: any): any;

        static captureRejectionSymbol: any;

        static captureRejections: boolean;

        static compose(streams: any): any;

        static defaultMaxListeners: number;

        static destroy(stream: any, err: any): any;

        static errorMonitor: any;

        static finished(stream: any, options: any, callback: any, ...args: any[]): any;

        static from(body: any): any;

        static getEventListeners(emitterOrTarget: any, type: any): any;

        static init(opts: any): void;

        static isDisturbed(stream: any): any;

        static isErrored(stream: any): any;

        static isReadable(stream: any): any;

        static kMaxEventTargetListeners: any;

        static kMaxEventTargetListenersWarned: any;

        static listenerCount(emitter: any, type: any): any;

        static on(emitter: any, event: any, options: any): any;

        static once(emitter: any, name: any, options: any): any;

        static pipeline(streams: any): any;

        static setMaxListeners(n: any, eventTargets: any): void;

        static usingDomains: boolean;

        static wrap(src: any, options: any): any;

    }

    class Writable {
        constructor(options: any);

        cork(): void;

        destroy(err: any, cb: any): any;

        end(chunk: any, encoding: any, cb: any): any;

        pipe(): void;

        setDefaultEncoding(encoding: any): any;

        uncork(): void;

        write(chunk: any, encoding: any, cb: any): any;

        static Writable: any;

        static addAbortSignal(signal: any, stream: any): any;

        static captureRejectionSymbol: any;

        static captureRejections: boolean;

        static compose(streams: any): any;

        static defaultMaxListeners: number;

        static destroy(stream: any, err: any): any;

        static errorMonitor: any;

        static finished(stream: any, options: any, callback: any, ...args: any[]): any;

        static getEventListeners(emitterOrTarget: any, type: any): any;

        static init(opts: any): void;

        static isDisturbed(stream: any): any;

        static isErrored(stream: any): any;

        static isReadable(stream: any): any;

        static kMaxEventTargetListeners: any;

        static kMaxEventTargetListenersWarned: any;

        static listenerCount(emitter: any, type: any): any;

        static on(emitter: any, event: any, options: any): any;

        static once(emitter: any, name: any, options: any): any;

        static pipeline(streams: any): any;

        static setMaxListeners(n: any, eventTargets: any): void;

        static usingDomains: boolean;

    }

    namespace Duplex {
        class EventEmitter {
            constructor(opts: any);

            addListener(type: any, listener: any): any;

            emit(type: any, args: any): any;

            eventNames(): any;

            getMaxListeners(): any;

            listenerCount(type: any): any;

            listeners(type: any): any;

            off(type: any, listener: any): any;

            on(type: any, listener: any): any;

            once(type: any, listener: any): any;

            prependListener(type: any, listener: any): any;

            prependOnceListener(type: any, listener: any): any;

            rawListeners(type: any): any;

            removeAllListeners(type: any, ...args: any[]): any;

            removeListener(type: any, listener: any): any;

            setMaxListeners(n: any): any;

            static EventEmitter: any;

            static captureRejectionSymbol: any;

            static captureRejections: boolean;

            static defaultMaxListeners: number;

            static errorMonitor: any;

            static getEventListeners(emitterOrTarget: any, type: any): any;

            static init(opts: any): void;

            static kMaxEventTargetListeners: any;

            static kMaxEventTargetListenersWarned: any;

            static listenerCount(emitter: any, type: any): any;

            static on(emitter: any, event: any, options: any): any;

            static once(emitter: any, name: any, options: any): any;

            static setMaxListeners(n: any, eventTargets: any): void;

            static usingDomains: boolean;

        }

        class EventEmitterAsyncResource {
            constructor(...args: any[]);

            emit(...args: any[]): void;

            emitDestroy(...args: any[]): void;

            static EventEmitterAsyncResource: any;

            static captureRejectionSymbol: any;

            static captureRejections: boolean;

            static defaultMaxListeners: number;

            static errorMonitor: any;

            static getEventListeners(emitterOrTarget: any, type: any): any;

            static init(opts: any): void;

            static kMaxEventTargetListeners: any;

            static kMaxEventTargetListenersWarned: any;

            static listenerCount(emitter: any, type: any): any;

            static on(emitter: any, event: any, options: any): any;

            static once(emitter: any, name: any, options: any): any;

            static setMaxListeners(n: any, eventTargets: any): void;

            static usingDomains: boolean;

        }

        class PassThrough {
            constructor(options: any);

            static Duplex: any;

            static PassThrough: any;

            static addAbortSignal(signal: any, stream: any): any;

            static captureRejectionSymbol: any;

            static captureRejections: boolean;

            static compose(streams: any): any;

            static defaultMaxListeners: number;

            static destroy(stream: any, err: any): any;

            static errorMonitor: any;

            static finished(stream: any, options: any, callback: any, ...args: any[]): any;

            static from(body: any): any;

            static getEventListeners(emitterOrTarget: any, type: any): any;

            static init(opts: any): void;

            static isDisturbed(stream: any): any;

            static isErrored(stream: any): any;

            static isReadable(stream: any): any;

            static kMaxEventTargetListeners: any;

            static kMaxEventTargetListenersWarned: any;

            static listenerCount(emitter: any, type: any): any;

            static on(emitter: any, event: any, options: any): any;

            static once(emitter: any, name: any, options: any): any;

            static pipeline(streams: any): any;

            static setMaxListeners(n: any, eventTargets: any): void;

            static usingDomains: boolean;

            static wrap(src: any, options: any): any;

        }

        class Readable {
            constructor(options: any);

            addListener(ev: any, fn: any): any;

            destroy(err: any, cb: any): any;

            filter(args: any): any;

            isPaused(): any;

            iterator(options: any): any;

            map(args: any): any;

            off(ev: any, fn: any): any;

            on(ev: any, fn: any): any;

            pause(): any;

            pipe(dest: any, pipeOpts: any): any;

            push(chunk: any, encoding: any): any;

            read(n: any): any;

            removeAllListeners(ev: any, ...args: any[]): any;

            removeListener(ev: any, fn: any): any;

            resume(): any;

            setEncoding(enc: any): any;

            unpipe(dest: any): any;

            unshift(chunk: any, encoding: any): any;

            wrap(stream: any): any;

            static Duplex: any;

            static Readable: any;

            static addAbortSignal(signal: any, stream: any): any;

            static captureRejectionSymbol: any;

            static captureRejections: boolean;

            static compose(streams: any): any;

            static defaultMaxListeners: number;

            static destroy(stream: any, err: any): any;

            static errorMonitor: any;

            static finished(stream: any, options: any, callback: any, ...args: any[]): any;

            static from(iterable: any, opts: any): any;

            static getEventListeners(emitterOrTarget: any, type: any): any;

            static init(opts: any): void;

            static isDisturbed(stream: any): any;

            static isErrored(stream: any): any;

            static isReadable(stream: any): any;

            static kMaxEventTargetListeners: any;

            static kMaxEventTargetListenersWarned: any;

            static listenerCount(emitter: any, type: any): any;

            static on(emitter: any, event: any, options: any): any;

            static once(emitter: any, name: any, options: any): any;

            static pipeline(streams: any): any;

            static setMaxListeners(n: any, eventTargets: any): void;

            static usingDomains: boolean;

            static wrap(src: any, options: any): any;

        }

        class ReadableState {
            constructor(options: any, stream: any, isDuplex: any);

        }

        class Stream {
            constructor(opts: any);

            pipe(dest: any, options: any): any;

            static Duplex: any;

            static Stream: any;

            static addAbortSignal(signal: any, stream: any): any;

            static captureRejectionSymbol: any;

            static captureRejections: boolean;

            static compose(streams: any): any;

            static defaultMaxListeners: number;

            static destroy(stream: any, err: any): any;

            static errorMonitor: any;

            static finished(stream: any, options: any, callback: any, ...args: any[]): any;

            static getEventListeners(emitterOrTarget: any, type: any): any;

            static init(opts: any): void;

            static isDisturbed(stream: any): any;

            static isErrored(stream: any): any;

            static isReadable(stream: any): any;

            static kMaxEventTargetListeners: any;

            static kMaxEventTargetListenersWarned: any;

            static listenerCount(emitter: any, type: any): any;

            static on(emitter: any, event: any, options: any): any;

            static once(emitter: any, name: any, options: any): any;

            static pipeline(streams: any): any;

            static setMaxListeners(n: any, eventTargets: any): void;

            static usingDomains: boolean;

        }

        class Transform {
            constructor(options: any);

            static Duplex: any;

            static Transform: any;

            static addAbortSignal(signal: any, stream: any): any;

            static captureRejectionSymbol: any;

            static captureRejections: boolean;

            static compose(streams: any): any;

            static defaultMaxListeners: number;

            static destroy(stream: any, err: any): any;

            static errorMonitor: any;

            static finished(stream: any, options: any, callback: any, ...args: any[]): any;

            static from(body: any): any;

            static getEventListeners(emitterOrTarget: any, type: any): any;

            static init(opts: any): void;

            static isDisturbed(stream: any): any;

            static isErrored(stream: any): any;

            static isReadable(stream: any): any;

            static kMaxEventTargetListeners: any;

            static kMaxEventTargetListenersWarned: any;

            static listenerCount(emitter: any, type: any): any;

            static on(emitter: any, event: any, options: any): any;

            static once(emitter: any, name: any, options: any): any;

            static pipeline(streams: any): any;

            static setMaxListeners(n: any, eventTargets: any): void;

            static usingDomains: boolean;

            static wrap(src: any, options: any): any;

        }

        class Writable {
            constructor(options: any);

            cork(): void;

            destroy(err: any, cb: any): any;

            end(chunk: any, encoding: any, cb: any): any;

            pipe(): void;

            setDefaultEncoding(encoding: any): any;

            uncork(): void;

            write(chunk: any, encoding: any, cb: any): any;

            static Duplex: any;

            static Writable: any;

            static addAbortSignal(signal: any, stream: any): any;

            static captureRejectionSymbol: any;

            static captureRejections: boolean;

            static compose(streams: any): any;

            static defaultMaxListeners: number;

            static destroy(stream: any, err: any): any;

            static errorMonitor: any;

            static finished(stream: any, options: any, callback: any, ...args: any[]): any;

            static getEventListeners(emitterOrTarget: any, type: any): any;

            static init(opts: any): void;

            static isDisturbed(stream: any): any;

            static isErrored(stream: any): any;

            static isReadable(stream: any): any;

            static kMaxEventTargetListeners: any;

            static kMaxEventTargetListenersWarned: any;

            static listenerCount(emitter: any, type: any): any;

            static on(emitter: any, event: any, options: any): any;

            static once(emitter: any, name: any, options: any): any;

            static pipeline(streams: any): any;

            static setMaxListeners(n: any, eventTargets: any): void;

            static usingDomains: boolean;

        }

        namespace EventEmitter {
            class EventEmitterAsyncResource {
                constructor(...args: any[]);

                emit(...args: any[]): void;

                emitDestroy(...args: any[]): void;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static defaultMaxListeners: any;

                static errorMonitor: any;

                static getEventListeners: any;

                static init: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static setMaxListeners: any;

                static usingDomains: any;

            }

        }

        namespace EventEmitterAsyncResource {
            class EventEmitter {
                constructor(opts: any);

                addListener(type: any, listener: any): any;

                emit(type: any, args: any): any;

                eventNames(): any;

                getMaxListeners(): any;

                listenerCount(type: any): any;

                listeners(type: any): any;

                off(type: any, listener: any): any;

                on(type: any, listener: any): any;

                once(type: any, listener: any): any;

                prependListener(type: any, listener: any): any;

                prependOnceListener(type: any, listener: any): any;

                rawListeners(type: any): any;

                removeAllListeners(type: any, ...args: any[]): any;

                removeListener(type: any, listener: any): any;

                setMaxListeners(n: any): any;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static defaultMaxListeners: any;

                static errorMonitor: any;

                static getEventListeners: any;

                static init: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static setMaxListeners: any;

                static usingDomains: any;

            }

        }

        namespace PassThrough {
            class EventEmitter {
                constructor(opts: any);

                addListener(type: any, listener: any): any;

                emit(type: any, args: any): any;

                eventNames(): any;

                getMaxListeners(): any;

                listenerCount(type: any): any;

                listeners(type: any): any;

                off(type: any, listener: any): any;

                on(type: any, listener: any): any;

                once(type: any, listener: any): any;

                prependListener(type: any, listener: any): any;

                prependOnceListener(type: any, listener: any): any;

                rawListeners(type: any): any;

                removeAllListeners(type: any, ...args: any[]): any;

                removeListener(type: any, listener: any): any;

                setMaxListeners(n: any): any;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static defaultMaxListeners: any;

                static errorMonitor: any;

                static getEventListeners: any;

                static init: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static setMaxListeners: any;

                static usingDomains: any;

            }

            class EventEmitterAsyncResource {
                constructor(...args: any[]);

                emit(...args: any[]): void;

                emitDestroy(...args: any[]): void;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static defaultMaxListeners: any;

                static errorMonitor: any;

                static getEventListeners: any;

                static init: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static setMaxListeners: any;

                static usingDomains: any;

            }

            class Readable {
                constructor(options: any);

                addListener(ev: any, fn: any): any;

                destroy(err: any, cb: any): any;

                filter(args: any): any;

                isPaused(): any;

                iterator(options: any): any;

                map(args: any): any;

                off(ev: any, fn: any): any;

                on(ev: any, fn: any): any;

                pause(): any;

                pipe(dest: any, pipeOpts: any): any;

                push(chunk: any, encoding: any): any;

                read(n: any): any;

                removeAllListeners(ev: any, ...args: any[]): any;

                removeListener(ev: any, fn: any): any;

                resume(): any;

                setEncoding(enc: any): any;

                unpipe(dest: any): any;

                unshift(chunk: any, encoding: any): any;

                wrap(stream: any): any;

                static Duplex: any;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static PassThrough: any;

                static Readable: any;

                static ReadableState: any;

                static Stream: any;

                static Transform: any;

                static Writable: any;

                static addAbortSignal: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static compose: any;

                static defaultMaxListeners: any;

                static destroy: any;

                static errorMonitor: any;

                static finished: any;

                static from: any;

                static getEventListeners: any;

                static init: any;

                static isDisturbed: any;

                static isErrored: any;

                static isReadable: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static pipeline: any;

                static promises: any;

                static setMaxListeners: any;

                static usingDomains: any;

                static wrap: any;

            }

            class ReadableState {
                constructor(options: any, stream: any, isDuplex: any);

            }

            class Stream {
                constructor(opts: any);

                pipe(dest: any, options: any): any;

                static Duplex: any;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static PassThrough: any;

                static Readable: any;

                static Stream: any;

                static Transform: any;

                static Writable: any;

                static addAbortSignal: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static compose: any;

                static defaultMaxListeners: any;

                static destroy: any;

                static errorMonitor: any;

                static finished: any;

                static getEventListeners: any;

                static init: any;

                static isDisturbed: any;

                static isErrored: any;

                static isReadable: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static pipeline: any;

                static promises: any;

                static setMaxListeners: any;

                static usingDomains: any;

            }

            class Transform {
                constructor(options: any);

                static Duplex: any;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static PassThrough: any;

                static Readable: any;

                static ReadableState: any;

                static Stream: any;

                static Transform: any;

                static Writable: any;

                static addAbortSignal: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static compose: any;

                static defaultMaxListeners: any;

                static destroy: any;

                static errorMonitor: any;

                static finished: any;

                static from: any;

                static getEventListeners: any;

                static init: any;

                static isDisturbed: any;

                static isErrored: any;

                static isReadable: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static pipeline: any;

                static promises: any;

                static setMaxListeners: any;

                static usingDomains: any;

                static wrap: any;

            }

            class Writable {
                constructor(options: any);

                cork(): void;

                destroy(err: any, cb: any): any;

                end(chunk: any, encoding: any, cb: any): any;

                pipe(): void;

                setDefaultEncoding(encoding: any): any;

                uncork(): void;

                write(chunk: any, encoding: any, cb: any): any;

                static Duplex: any;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static PassThrough: any;

                static Readable: any;

                static Stream: any;

                static Transform: any;

                static Writable: any;

                static WritableState: any;

                static addAbortSignal: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static compose: any;

                static defaultMaxListeners: any;

                static destroy: any;

                static errorMonitor: any;

                static finished: any;

                static getEventListeners: any;

                static init: any;

                static isDisturbed: any;

                static isErrored: any;

                static isReadable: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static pipeline: any;

                static promises: any;

                static setMaxListeners: any;

                static usingDomains: any;

            }

            namespace promises {
                // Too-deep object hierarchy from fs.FileReadStream.Duplex.PassThrough.promises
                const finished: any;

                // Too-deep object hierarchy from fs.FileReadStream.Duplex.PassThrough.promises
                const pipeline: any;

            }

        }

        namespace Readable {
            class EventEmitter {
                constructor(opts: any);

                addListener(type: any, listener: any): any;

                emit(type: any, args: any): any;

                eventNames(): any;

                getMaxListeners(): any;

                listenerCount(type: any): any;

                listeners(type: any): any;

                off(type: any, listener: any): any;

                on(type: any, listener: any): any;

                once(type: any, listener: any): any;

                prependListener(type: any, listener: any): any;

                prependOnceListener(type: any, listener: any): any;

                rawListeners(type: any): any;

                removeAllListeners(type: any, ...args: any[]): any;

                removeListener(type: any, listener: any): any;

                setMaxListeners(n: any): any;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static defaultMaxListeners: any;

                static errorMonitor: any;

                static getEventListeners: any;

                static init: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static setMaxListeners: any;

                static usingDomains: any;

            }

            class EventEmitterAsyncResource {
                constructor(...args: any[]);

                emit(...args: any[]): void;

                emitDestroy(...args: any[]): void;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static defaultMaxListeners: any;

                static errorMonitor: any;

                static getEventListeners: any;

                static init: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static setMaxListeners: any;

                static usingDomains: any;

            }

            class PassThrough {
                constructor(options: any);

                static Duplex: any;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static PassThrough: any;

                static Readable: any;

                static ReadableState: any;

                static Stream: any;

                static Transform: any;

                static Writable: any;

                static addAbortSignal: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static compose: any;

                static defaultMaxListeners: any;

                static destroy: any;

                static errorMonitor: any;

                static finished: any;

                static from: any;

                static getEventListeners: any;

                static init: any;

                static isDisturbed: any;

                static isErrored: any;

                static isReadable: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static pipeline: any;

                static promises: any;

                static setMaxListeners: any;

                static usingDomains: any;

                static wrap: any;

            }

            class ReadableState {
                constructor(options: any, stream: any, isDuplex: any);

            }

            class Stream {
                constructor(opts: any);

                pipe(dest: any, options: any): any;

                static Duplex: any;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static PassThrough: any;

                static Readable: any;

                static Stream: any;

                static Transform: any;

                static Writable: any;

                static addAbortSignal: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static compose: any;

                static defaultMaxListeners: any;

                static destroy: any;

                static errorMonitor: any;

                static finished: any;

                static getEventListeners: any;

                static init: any;

                static isDisturbed: any;

                static isErrored: any;

                static isReadable: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static pipeline: any;

                static promises: any;

                static setMaxListeners: any;

                static usingDomains: any;

            }

            class Transform {
                constructor(options: any);

                static Duplex: any;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static PassThrough: any;

                static Readable: any;

                static ReadableState: any;

                static Stream: any;

                static Transform: any;

                static Writable: any;

                static addAbortSignal: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static compose: any;

                static defaultMaxListeners: any;

                static destroy: any;

                static errorMonitor: any;

                static finished: any;

                static from: any;

                static getEventListeners: any;

                static init: any;

                static isDisturbed: any;

                static isErrored: any;

                static isReadable: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static pipeline: any;

                static promises: any;

                static setMaxListeners: any;

                static usingDomains: any;

                static wrap: any;

            }

            class Writable {
                constructor(options: any);

                cork(): void;

                destroy(err: any, cb: any): any;

                end(chunk: any, encoding: any, cb: any): any;

                pipe(): void;

                setDefaultEncoding(encoding: any): any;

                uncork(): void;

                write(chunk: any, encoding: any, cb: any): any;

                static Duplex: any;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static PassThrough: any;

                static Readable: any;

                static Stream: any;

                static Transform: any;

                static Writable: any;

                static WritableState: any;

                static addAbortSignal: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static compose: any;

                static defaultMaxListeners: any;

                static destroy: any;

                static errorMonitor: any;

                static finished: any;

                static getEventListeners: any;

                static init: any;

                static isDisturbed: any;

                static isErrored: any;

                static isReadable: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static pipeline: any;

                static promises: any;

                static setMaxListeners: any;

                static usingDomains: any;

            }

            namespace promises {
                // Too-deep object hierarchy from fs.FileReadStream.Duplex.Readable.promises
                const finished: any;

                // Too-deep object hierarchy from fs.FileReadStream.Duplex.Readable.promises
                const pipeline: any;

            }

        }

        namespace Stream {
            class EventEmitter {
                constructor(opts: any);

                addListener(type: any, listener: any): any;

                emit(type: any, args: any): any;

                eventNames(): any;

                getMaxListeners(): any;

                listenerCount(type: any): any;

                listeners(type: any): any;

                off(type: any, listener: any): any;

                on(type: any, listener: any): any;

                once(type: any, listener: any): any;

                prependListener(type: any, listener: any): any;

                prependOnceListener(type: any, listener: any): any;

                rawListeners(type: any): any;

                removeAllListeners(type: any, ...args: any[]): any;

                removeListener(type: any, listener: any): any;

                setMaxListeners(n: any): any;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static defaultMaxListeners: any;

                static errorMonitor: any;

                static getEventListeners: any;

                static init: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static setMaxListeners: any;

                static usingDomains: any;

            }

            class EventEmitterAsyncResource {
                constructor(...args: any[]);

                emit(...args: any[]): void;

                emitDestroy(...args: any[]): void;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static defaultMaxListeners: any;

                static errorMonitor: any;

                static getEventListeners: any;

                static init: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static setMaxListeners: any;

                static usingDomains: any;

            }

            class PassThrough {
                constructor(options: any);

                static Duplex: any;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static PassThrough: any;

                static Readable: any;

                static ReadableState: any;

                static Stream: any;

                static Transform: any;

                static Writable: any;

                static addAbortSignal: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static compose: any;

                static defaultMaxListeners: any;

                static destroy: any;

                static errorMonitor: any;

                static finished: any;

                static from: any;

                static getEventListeners: any;

                static init: any;

                static isDisturbed: any;

                static isErrored: any;

                static isReadable: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static pipeline: any;

                static promises: any;

                static setMaxListeners: any;

                static usingDomains: any;

                static wrap: any;

            }

            class Readable {
                constructor(options: any);

                addListener(ev: any, fn: any): any;

                destroy(err: any, cb: any): any;

                filter(args: any): any;

                isPaused(): any;

                iterator(options: any): any;

                map(args: any): any;

                off(ev: any, fn: any): any;

                on(ev: any, fn: any): any;

                pause(): any;

                pipe(dest: any, pipeOpts: any): any;

                push(chunk: any, encoding: any): any;

                read(n: any): any;

                removeAllListeners(ev: any, ...args: any[]): any;

                removeListener(ev: any, fn: any): any;

                resume(): any;

                setEncoding(enc: any): any;

                unpipe(dest: any): any;

                unshift(chunk: any, encoding: any): any;

                wrap(stream: any): any;

                static Duplex: any;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static PassThrough: any;

                static Readable: any;

                static ReadableState: any;

                static Stream: any;

                static Transform: any;

                static Writable: any;

                static addAbortSignal: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static compose: any;

                static defaultMaxListeners: any;

                static destroy: any;

                static errorMonitor: any;

                static finished: any;

                static from: any;

                static getEventListeners: any;

                static init: any;

                static isDisturbed: any;

                static isErrored: any;

                static isReadable: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static pipeline: any;

                static promises: any;

                static setMaxListeners: any;

                static usingDomains: any;

                static wrap: any;

            }

            class Transform {
                constructor(options: any);

                static Duplex: any;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static PassThrough: any;

                static Readable: any;

                static ReadableState: any;

                static Stream: any;

                static Transform: any;

                static Writable: any;

                static addAbortSignal: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static compose: any;

                static defaultMaxListeners: any;

                static destroy: any;

                static errorMonitor: any;

                static finished: any;

                static from: any;

                static getEventListeners: any;

                static init: any;

                static isDisturbed: any;

                static isErrored: any;

                static isReadable: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static pipeline: any;

                static promises: any;

                static setMaxListeners: any;

                static usingDomains: any;

                static wrap: any;

            }

            class Writable {
                constructor(options: any);

                cork(): void;

                destroy(err: any, cb: any): any;

                end(chunk: any, encoding: any, cb: any): any;

                pipe(): void;

                setDefaultEncoding(encoding: any): any;

                uncork(): void;

                write(chunk: any, encoding: any, cb: any): any;

                static Duplex: any;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static PassThrough: any;

                static Readable: any;

                static Stream: any;

                static Transform: any;

                static Writable: any;

                static WritableState: any;

                static addAbortSignal: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static compose: any;

                static defaultMaxListeners: any;

                static destroy: any;

                static errorMonitor: any;

                static finished: any;

                static getEventListeners: any;

                static init: any;

                static isDisturbed: any;

                static isErrored: any;

                static isReadable: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static pipeline: any;

                static promises: any;

                static setMaxListeners: any;

                static usingDomains: any;

            }

            namespace promises {
                // Too-deep object hierarchy from fs.FileReadStream.Duplex.Stream.promises
                const finished: any;

                // Too-deep object hierarchy from fs.FileReadStream.Duplex.Stream.promises
                const pipeline: any;

            }

        }

        namespace Transform {
            class EventEmitter {
                constructor(opts: any);

                addListener(type: any, listener: any): any;

                emit(type: any, args: any): any;

                eventNames(): any;

                getMaxListeners(): any;

                listenerCount(type: any): any;

                listeners(type: any): any;

                off(type: any, listener: any): any;

                on(type: any, listener: any): any;

                once(type: any, listener: any): any;

                prependListener(type: any, listener: any): any;

                prependOnceListener(type: any, listener: any): any;

                rawListeners(type: any): any;

                removeAllListeners(type: any, ...args: any[]): any;

                removeListener(type: any, listener: any): any;

                setMaxListeners(n: any): any;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static defaultMaxListeners: any;

                static errorMonitor: any;

                static getEventListeners: any;

                static init: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static setMaxListeners: any;

                static usingDomains: any;

            }

            class EventEmitterAsyncResource {
                constructor(...args: any[]);

                emit(...args: any[]): void;

                emitDestroy(...args: any[]): void;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static defaultMaxListeners: any;

                static errorMonitor: any;

                static getEventListeners: any;

                static init: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static setMaxListeners: any;

                static usingDomains: any;

            }

            class PassThrough {
                constructor(options: any);

                static Duplex: any;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static PassThrough: any;

                static Readable: any;

                static ReadableState: any;

                static Stream: any;

                static Transform: any;

                static Writable: any;

                static addAbortSignal: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static compose: any;

                static defaultMaxListeners: any;

                static destroy: any;

                static errorMonitor: any;

                static finished: any;

                static from: any;

                static getEventListeners: any;

                static init: any;

                static isDisturbed: any;

                static isErrored: any;

                static isReadable: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static pipeline: any;

                static promises: any;

                static setMaxListeners: any;

                static usingDomains: any;

                static wrap: any;

            }

            class Readable {
                constructor(options: any);

                addListener(ev: any, fn: any): any;

                destroy(err: any, cb: any): any;

                filter(args: any): any;

                isPaused(): any;

                iterator(options: any): any;

                map(args: any): any;

                off(ev: any, fn: any): any;

                on(ev: any, fn: any): any;

                pause(): any;

                pipe(dest: any, pipeOpts: any): any;

                push(chunk: any, encoding: any): any;

                read(n: any): any;

                removeAllListeners(ev: any, ...args: any[]): any;

                removeListener(ev: any, fn: any): any;

                resume(): any;

                setEncoding(enc: any): any;

                unpipe(dest: any): any;

                unshift(chunk: any, encoding: any): any;

                wrap(stream: any): any;

                static Duplex: any;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static PassThrough: any;

                static Readable: any;

                static ReadableState: any;

                static Stream: any;

                static Transform: any;

                static Writable: any;

                static addAbortSignal: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static compose: any;

                static defaultMaxListeners: any;

                static destroy: any;

                static errorMonitor: any;

                static finished: any;

                static from: any;

                static getEventListeners: any;

                static init: any;

                static isDisturbed: any;

                static isErrored: any;

                static isReadable: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static pipeline: any;

                static promises: any;

                static setMaxListeners: any;

                static usingDomains: any;

                static wrap: any;

            }

            class ReadableState {
                constructor(options: any, stream: any, isDuplex: any);

            }

            class Stream {
                constructor(opts: any);

                pipe(dest: any, options: any): any;

                static Duplex: any;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static PassThrough: any;

                static Readable: any;

                static Stream: any;

                static Transform: any;

                static Writable: any;

                static addAbortSignal: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static compose: any;

                static defaultMaxListeners: any;

                static destroy: any;

                static errorMonitor: any;

                static finished: any;

                static getEventListeners: any;

                static init: any;

                static isDisturbed: any;

                static isErrored: any;

                static isReadable: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static pipeline: any;

                static promises: any;

                static setMaxListeners: any;

                static usingDomains: any;

            }

            class Writable {
                constructor(options: any);

                cork(): void;

                destroy(err: any, cb: any): any;

                end(chunk: any, encoding: any, cb: any): any;

                pipe(): void;

                setDefaultEncoding(encoding: any): any;

                uncork(): void;

                write(chunk: any, encoding: any, cb: any): any;

                static Duplex: any;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static PassThrough: any;

                static Readable: any;

                static Stream: any;

                static Transform: any;

                static Writable: any;

                static WritableState: any;

                static addAbortSignal: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static compose: any;

                static defaultMaxListeners: any;

                static destroy: any;

                static errorMonitor: any;

                static finished: any;

                static getEventListeners: any;

                static init: any;

                static isDisturbed: any;

                static isErrored: any;

                static isReadable: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static pipeline: any;

                static promises: any;

                static setMaxListeners: any;

                static usingDomains: any;

            }

            namespace promises {
                // Too-deep object hierarchy from fs.FileReadStream.Duplex.Transform.promises
                const finished: any;

                // Too-deep object hierarchy from fs.FileReadStream.Duplex.Transform.promises
                const pipeline: any;

            }

        }

        namespace Writable {
            class EventEmitter {
                constructor(opts: any);

                addListener(type: any, listener: any): any;

                emit(type: any, args: any): any;

                eventNames(): any;

                getMaxListeners(): any;

                listenerCount(type: any): any;

                listeners(type: any): any;

                off(type: any, listener: any): any;

                on(type: any, listener: any): any;

                once(type: any, listener: any): any;

                prependListener(type: any, listener: any): any;

                prependOnceListener(type: any, listener: any): any;

                rawListeners(type: any): any;

                removeAllListeners(type: any, ...args: any[]): any;

                removeListener(type: any, listener: any): any;

                setMaxListeners(n: any): any;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static defaultMaxListeners: any;

                static errorMonitor: any;

                static getEventListeners: any;

                static init: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static setMaxListeners: any;

                static usingDomains: any;

            }

            class EventEmitterAsyncResource {
                constructor(...args: any[]);

                emit(...args: any[]): void;

                emitDestroy(...args: any[]): void;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static defaultMaxListeners: any;

                static errorMonitor: any;

                static getEventListeners: any;

                static init: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static setMaxListeners: any;

                static usingDomains: any;

            }

            class PassThrough {
                constructor(options: any);

                static Duplex: any;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static PassThrough: any;

                static Readable: any;

                static ReadableState: any;

                static Stream: any;

                static Transform: any;

                static Writable: any;

                static addAbortSignal: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static compose: any;

                static defaultMaxListeners: any;

                static destroy: any;

                static errorMonitor: any;

                static finished: any;

                static from: any;

                static getEventListeners: any;

                static init: any;

                static isDisturbed: any;

                static isErrored: any;

                static isReadable: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static pipeline: any;

                static promises: any;

                static setMaxListeners: any;

                static usingDomains: any;

                static wrap: any;

            }

            class Readable {
                constructor(options: any);

                addListener(ev: any, fn: any): any;

                destroy(err: any, cb: any): any;

                filter(args: any): any;

                isPaused(): any;

                iterator(options: any): any;

                map(args: any): any;

                off(ev: any, fn: any): any;

                on(ev: any, fn: any): any;

                pause(): any;

                pipe(dest: any, pipeOpts: any): any;

                push(chunk: any, encoding: any): any;

                read(n: any): any;

                removeAllListeners(ev: any, ...args: any[]): any;

                removeListener(ev: any, fn: any): any;

                resume(): any;

                setEncoding(enc: any): any;

                unpipe(dest: any): any;

                unshift(chunk: any, encoding: any): any;

                wrap(stream: any): any;

                static Duplex: any;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static PassThrough: any;

                static Readable: any;

                static ReadableState: any;

                static Stream: any;

                static Transform: any;

                static Writable: any;

                static addAbortSignal: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static compose: any;

                static defaultMaxListeners: any;

                static destroy: any;

                static errorMonitor: any;

                static finished: any;

                static from: any;

                static getEventListeners: any;

                static init: any;

                static isDisturbed: any;

                static isErrored: any;

                static isReadable: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static pipeline: any;

                static promises: any;

                static setMaxListeners: any;

                static usingDomains: any;

                static wrap: any;

            }

            class Stream {
                constructor(opts: any);

                pipe(dest: any, options: any): any;

                static Duplex: any;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static PassThrough: any;

                static Readable: any;

                static Stream: any;

                static Transform: any;

                static Writable: any;

                static addAbortSignal: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static compose: any;

                static defaultMaxListeners: any;

                static destroy: any;

                static errorMonitor: any;

                static finished: any;

                static getEventListeners: any;

                static init: any;

                static isDisturbed: any;

                static isErrored: any;

                static isReadable: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static pipeline: any;

                static promises: any;

                static setMaxListeners: any;

                static usingDomains: any;

            }

            class Transform {
                constructor(options: any);

                static Duplex: any;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static PassThrough: any;

                static Readable: any;

                static ReadableState: any;

                static Stream: any;

                static Transform: any;

                static Writable: any;

                static addAbortSignal: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static compose: any;

                static defaultMaxListeners: any;

                static destroy: any;

                static errorMonitor: any;

                static finished: any;

                static from: any;

                static getEventListeners: any;

                static init: any;

                static isDisturbed: any;

                static isErrored: any;

                static isReadable: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static pipeline: any;

                static promises: any;

                static setMaxListeners: any;

                static usingDomains: any;

                static wrap: any;

            }

            class WritableState {
                constructor(options: any, stream: any, isDuplex: any);

                getBuffer(): any;

            }

            namespace promises {
                // Too-deep object hierarchy from fs.FileReadStream.Duplex.Writable.promises
                const finished: any;

                // Too-deep object hierarchy from fs.FileReadStream.Duplex.Writable.promises
                const pipeline: any;

            }

        }

        namespace promises {
            function finished(stream: any, opts: any): any;

            function pipeline(streams: any): any;

        }

    }

    namespace EventEmitter {
        class EventEmitterAsyncResource {
            constructor(...args: any[]);

            emit(...args: any[]): void;

            emitDestroy(...args: any[]): void;

            static EventEmitter: any;

            static EventEmitterAsyncResource: any;

            static captureRejectionSymbol: any;

            static captureRejections: boolean;

            static defaultMaxListeners: number;

            static errorMonitor: any;

            static getEventListeners(emitterOrTarget: any, type: any): any;

            static init(opts: any): void;

            static kMaxEventTargetListeners: any;

            static kMaxEventTargetListenersWarned: any;

            static listenerCount(emitter: any, type: any): any;

            static on(emitter: any, event: any, options: any): any;

            static once(emitter: any, name: any, options: any): any;

            static setMaxListeners(n: any, eventTargets: any): void;

            static usingDomains: boolean;

        }

    }

    namespace EventEmitterAsyncResource {
        class EventEmitter {
            constructor(opts: any);

            addListener(type: any, listener: any): any;

            emit(type: any, args: any): any;

            eventNames(): any;

            getMaxListeners(): any;

            listenerCount(type: any): any;

            listeners(type: any): any;

            off(type: any, listener: any): any;

            on(type: any, listener: any): any;

            once(type: any, listener: any): any;

            prependListener(type: any, listener: any): any;

            prependOnceListener(type: any, listener: any): any;

            rawListeners(type: any): any;

            removeAllListeners(type: any, ...args: any[]): any;

            removeListener(type: any, listener: any): any;

            setMaxListeners(n: any): any;

            static EventEmitter: any;

            static EventEmitterAsyncResource: any;

            static captureRejectionSymbol: any;

            static captureRejections: boolean;

            static defaultMaxListeners: number;

            static errorMonitor: any;

            static getEventListeners(emitterOrTarget: any, type: any): any;

            static init(opts: any): void;

            static kMaxEventTargetListeners: any;

            static kMaxEventTargetListenersWarned: any;

            static listenerCount(emitter: any, type: any): any;

            static on(emitter: any, event: any, options: any): any;

            static once(emitter: any, name: any, options: any): any;

            static setMaxListeners(n: any, eventTargets: any): void;

            static usingDomains: boolean;

        }

    }

    namespace PassThrough {
        class Duplex {
            constructor(options: any);

            cork(): void;

            end(chunk: any, encoding: any, cb: any): any;

            setDefaultEncoding(encoding: any): any;

            uncork(): void;

            write(chunk: any, encoding: any, cb: any): any;

            static Duplex: any;

            static PassThrough: any;

            static addAbortSignal(signal: any, stream: any): any;

            static captureRejectionSymbol: any;

            static captureRejections: boolean;

            static compose(streams: any): any;

            static defaultMaxListeners: number;

            static destroy(stream: any, err: any): any;

            static errorMonitor: any;

            static finished(stream: any, options: any, callback: any, ...args: any[]): any;

            static from(body: any): any;

            static getEventListeners(emitterOrTarget: any, type: any): any;

            static init(opts: any): void;

            static isDisturbed(stream: any): any;

            static isErrored(stream: any): any;

            static isReadable(stream: any): any;

            static kMaxEventTargetListeners: any;

            static kMaxEventTargetListenersWarned: any;

            static listenerCount(emitter: any, type: any): any;

            static on(emitter: any, event: any, options: any): any;

            static once(emitter: any, name: any, options: any): any;

            static pipeline(streams: any): any;

            static setMaxListeners(n: any, eventTargets: any): void;

            static usingDomains: boolean;

            static wrap(src: any, options: any): any;

        }

        class EventEmitter {
            constructor(opts: any);

            addListener(type: any, listener: any): any;

            emit(type: any, args: any): any;

            eventNames(): any;

            getMaxListeners(): any;

            listenerCount(type: any): any;

            listeners(type: any): any;

            off(type: any, listener: any): any;

            on(type: any, listener: any): any;

            once(type: any, listener: any): any;

            prependListener(type: any, listener: any): any;

            prependOnceListener(type: any, listener: any): any;

            rawListeners(type: any): any;

            removeAllListeners(type: any, ...args: any[]): any;

            removeListener(type: any, listener: any): any;

            setMaxListeners(n: any): any;

            static EventEmitter: any;

            static captureRejectionSymbol: any;

            static captureRejections: boolean;

            static defaultMaxListeners: number;

            static errorMonitor: any;

            static getEventListeners(emitterOrTarget: any, type: any): any;

            static init(opts: any): void;

            static kMaxEventTargetListeners: any;

            static kMaxEventTargetListenersWarned: any;

            static listenerCount(emitter: any, type: any): any;

            static on(emitter: any, event: any, options: any): any;

            static once(emitter: any, name: any, options: any): any;

            static setMaxListeners(n: any, eventTargets: any): void;

            static usingDomains: boolean;

        }

        class EventEmitterAsyncResource {
            constructor(...args: any[]);

            emit(...args: any[]): void;

            emitDestroy(...args: any[]): void;

            static EventEmitterAsyncResource: any;

            static captureRejectionSymbol: any;

            static captureRejections: boolean;

            static defaultMaxListeners: number;

            static errorMonitor: any;

            static getEventListeners(emitterOrTarget: any, type: any): any;

            static init(opts: any): void;

            static kMaxEventTargetListeners: any;

            static kMaxEventTargetListenersWarned: any;

            static listenerCount(emitter: any, type: any): any;

            static on(emitter: any, event: any, options: any): any;

            static once(emitter: any, name: any, options: any): any;

            static setMaxListeners(n: any, eventTargets: any): void;

            static usingDomains: boolean;

        }

        class Readable {
            constructor(options: any);

            addListener(ev: any, fn: any): any;

            destroy(err: any, cb: any): any;

            filter(args: any): any;

            isPaused(): any;

            iterator(options: any): any;

            map(args: any): any;

            off(ev: any, fn: any): any;

            on(ev: any, fn: any): any;

            pause(): any;

            pipe(dest: any, pipeOpts: any): any;

            push(chunk: any, encoding: any): any;

            read(n: any): any;

            removeAllListeners(ev: any, ...args: any[]): any;

            removeListener(ev: any, fn: any): any;

            resume(): any;

            setEncoding(enc: any): any;

            unpipe(dest: any): any;

            unshift(chunk: any, encoding: any): any;

            wrap(stream: any): any;

            static PassThrough: any;

            static Readable: any;

            static addAbortSignal(signal: any, stream: any): any;

            static captureRejectionSymbol: any;

            static captureRejections: boolean;

            static compose(streams: any): any;

            static defaultMaxListeners: number;

            static destroy(stream: any, err: any): any;

            static errorMonitor: any;

            static finished(stream: any, options: any, callback: any, ...args: any[]): any;

            static from(iterable: any, opts: any): any;

            static getEventListeners(emitterOrTarget: any, type: any): any;

            static init(opts: any): void;

            static isDisturbed(stream: any): any;

            static isErrored(stream: any): any;

            static isReadable(stream: any): any;

            static kMaxEventTargetListeners: any;

            static kMaxEventTargetListenersWarned: any;

            static listenerCount(emitter: any, type: any): any;

            static on(emitter: any, event: any, options: any): any;

            static once(emitter: any, name: any, options: any): any;

            static pipeline(streams: any): any;

            static setMaxListeners(n: any, eventTargets: any): void;

            static usingDomains: boolean;

            static wrap(src: any, options: any): any;

        }

        class ReadableState {
            constructor(options: any, stream: any, isDuplex: any);

        }

        class Stream {
            constructor(opts: any);

            pipe(dest: any, options: any): any;

            static PassThrough: any;

            static Stream: any;

            static addAbortSignal(signal: any, stream: any): any;

            static captureRejectionSymbol: any;

            static captureRejections: boolean;

            static compose(streams: any): any;

            static defaultMaxListeners: number;

            static destroy(stream: any, err: any): any;

            static errorMonitor: any;

            static finished(stream: any, options: any, callback: any, ...args: any[]): any;

            static getEventListeners(emitterOrTarget: any, type: any): any;

            static init(opts: any): void;

            static isDisturbed(stream: any): any;

            static isErrored(stream: any): any;

            static isReadable(stream: any): any;

            static kMaxEventTargetListeners: any;

            static kMaxEventTargetListenersWarned: any;

            static listenerCount(emitter: any, type: any): any;

            static on(emitter: any, event: any, options: any): any;

            static once(emitter: any, name: any, options: any): any;

            static pipeline(streams: any): any;

            static setMaxListeners(n: any, eventTargets: any): void;

            static usingDomains: boolean;

        }

        class Transform {
            constructor(options: any);

            static PassThrough: any;

            static Transform: any;

            static addAbortSignal(signal: any, stream: any): any;

            static captureRejectionSymbol: any;

            static captureRejections: boolean;

            static compose(streams: any): any;

            static defaultMaxListeners: number;

            static destroy(stream: any, err: any): any;

            static errorMonitor: any;

            static finished(stream: any, options: any, callback: any, ...args: any[]): any;

            static from(body: any): any;

            static getEventListeners(emitterOrTarget: any, type: any): any;

            static init(opts: any): void;

            static isDisturbed(stream: any): any;

            static isErrored(stream: any): any;

            static isReadable(stream: any): any;

            static kMaxEventTargetListeners: any;

            static kMaxEventTargetListenersWarned: any;

            static listenerCount(emitter: any, type: any): any;

            static on(emitter: any, event: any, options: any): any;

            static once(emitter: any, name: any, options: any): any;

            static pipeline(streams: any): any;

            static setMaxListeners(n: any, eventTargets: any): void;

            static usingDomains: boolean;

            static wrap(src: any, options: any): any;

        }

        class Writable {
            constructor(options: any);

            cork(): void;

            destroy(err: any, cb: any): any;

            end(chunk: any, encoding: any, cb: any): any;

            pipe(): void;

            setDefaultEncoding(encoding: any): any;

            uncork(): void;

            write(chunk: any, encoding: any, cb: any): any;

            static PassThrough: any;

            static Writable: any;

            static addAbortSignal(signal: any, stream: any): any;

            static captureRejectionSymbol: any;

            static captureRejections: boolean;

            static compose(streams: any): any;

            static defaultMaxListeners: number;

            static destroy(stream: any, err: any): any;

            static errorMonitor: any;

            static finished(stream: any, options: any, callback: any, ...args: any[]): any;

            static getEventListeners(emitterOrTarget: any, type: any): any;

            static init(opts: any): void;

            static isDisturbed(stream: any): any;

            static isErrored(stream: any): any;

            static isReadable(stream: any): any;

            static kMaxEventTargetListeners: any;

            static kMaxEventTargetListenersWarned: any;

            static listenerCount(emitter: any, type: any): any;

            static on(emitter: any, event: any, options: any): any;

            static once(emitter: any, name: any, options: any): any;

            static pipeline(streams: any): any;

            static setMaxListeners(n: any, eventTargets: any): void;

            static usingDomains: boolean;

        }

        namespace Duplex {
            class EventEmitter {
                constructor(opts: any);

                addListener(type: any, listener: any): any;

                emit(type: any, args: any): any;

                eventNames(): any;

                getMaxListeners(): any;

                listenerCount(type: any): any;

                listeners(type: any): any;

                off(type: any, listener: any): any;

                on(type: any, listener: any): any;

                once(type: any, listener: any): any;

                prependListener(type: any, listener: any): any;

                prependOnceListener(type: any, listener: any): any;

                rawListeners(type: any): any;

                removeAllListeners(type: any, ...args: any[]): any;

                removeListener(type: any, listener: any): any;

                setMaxListeners(n: any): any;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static defaultMaxListeners: any;

                static errorMonitor: any;

                static getEventListeners: any;

                static init: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static setMaxListeners: any;

                static usingDomains: any;

            }

            class EventEmitterAsyncResource {
                constructor(...args: any[]);

                emit(...args: any[]): void;

                emitDestroy(...args: any[]): void;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static defaultMaxListeners: any;

                static errorMonitor: any;

                static getEventListeners: any;

                static init: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static setMaxListeners: any;

                static usingDomains: any;

            }

            class Readable {
                constructor(options: any);

                addListener(ev: any, fn: any): any;

                destroy(err: any, cb: any): any;

                filter(args: any): any;

                isPaused(): any;

                iterator(options: any): any;

                map(args: any): any;

                off(ev: any, fn: any): any;

                on(ev: any, fn: any): any;

                pause(): any;

                pipe(dest: any, pipeOpts: any): any;

                push(chunk: any, encoding: any): any;

                read(n: any): any;

                removeAllListeners(ev: any, ...args: any[]): any;

                removeListener(ev: any, fn: any): any;

                resume(): any;

                setEncoding(enc: any): any;

                unpipe(dest: any): any;

                unshift(chunk: any, encoding: any): any;

                wrap(stream: any): any;

                static Duplex: any;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static PassThrough: any;

                static Readable: any;

                static ReadableState: any;

                static Stream: any;

                static Transform: any;

                static Writable: any;

                static addAbortSignal: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static compose: any;

                static defaultMaxListeners: any;

                static destroy: any;

                static errorMonitor: any;

                static finished: any;

                static from: any;

                static getEventListeners: any;

                static init: any;

                static isDisturbed: any;

                static isErrored: any;

                static isReadable: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static pipeline: any;

                static promises: any;

                static setMaxListeners: any;

                static usingDomains: any;

                static wrap: any;

            }

            class ReadableState {
                constructor(options: any, stream: any, isDuplex: any);

            }

            class Stream {
                constructor(opts: any);

                pipe(dest: any, options: any): any;

                static Duplex: any;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static PassThrough: any;

                static Readable: any;

                static Stream: any;

                static Transform: any;

                static Writable: any;

                static addAbortSignal: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static compose: any;

                static defaultMaxListeners: any;

                static destroy: any;

                static errorMonitor: any;

                static finished: any;

                static getEventListeners: any;

                static init: any;

                static isDisturbed: any;

                static isErrored: any;

                static isReadable: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static pipeline: any;

                static promises: any;

                static setMaxListeners: any;

                static usingDomains: any;

            }

            class Transform {
                constructor(options: any);

                static Duplex: any;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static PassThrough: any;

                static Readable: any;

                static ReadableState: any;

                static Stream: any;

                static Transform: any;

                static Writable: any;

                static addAbortSignal: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static compose: any;

                static defaultMaxListeners: any;

                static destroy: any;

                static errorMonitor: any;

                static finished: any;

                static from: any;

                static getEventListeners: any;

                static init: any;

                static isDisturbed: any;

                static isErrored: any;

                static isReadable: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static pipeline: any;

                static promises: any;

                static setMaxListeners: any;

                static usingDomains: any;

                static wrap: any;

            }

            class Writable {
                constructor(options: any);

                cork(): void;

                destroy(err: any, cb: any): any;

                end(chunk: any, encoding: any, cb: any): any;

                pipe(): void;

                setDefaultEncoding(encoding: any): any;

                uncork(): void;

                write(chunk: any, encoding: any, cb: any): any;

                static Duplex: any;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static PassThrough: any;

                static Readable: any;

                static Stream: any;

                static Transform: any;

                static Writable: any;

                static WritableState: any;

                static addAbortSignal: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static compose: any;

                static defaultMaxListeners: any;

                static destroy: any;

                static errorMonitor: any;

                static finished: any;

                static getEventListeners: any;

                static init: any;

                static isDisturbed: any;

                static isErrored: any;

                static isReadable: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static pipeline: any;

                static promises: any;

                static setMaxListeners: any;

                static usingDomains: any;

            }

            namespace promises {
                // Too-deep object hierarchy from fs.FileReadStream.PassThrough.Duplex.promises
                const finished: any;

                // Too-deep object hierarchy from fs.FileReadStream.PassThrough.Duplex.promises
                const pipeline: any;

            }

        }

        namespace EventEmitter {
            class EventEmitterAsyncResource {
                constructor(...args: any[]);

                emit(...args: any[]): void;

                emitDestroy(...args: any[]): void;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static defaultMaxListeners: any;

                static errorMonitor: any;

                static getEventListeners: any;

                static init: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static setMaxListeners: any;

                static usingDomains: any;

            }

        }

        namespace EventEmitterAsyncResource {
            class EventEmitter {
                constructor(opts: any);

                addListener(type: any, listener: any): any;

                emit(type: any, args: any): any;

                eventNames(): any;

                getMaxListeners(): any;

                listenerCount(type: any): any;

                listeners(type: any): any;

                off(type: any, listener: any): any;

                on(type: any, listener: any): any;

                once(type: any, listener: any): any;

                prependListener(type: any, listener: any): any;

                prependOnceListener(type: any, listener: any): any;

                rawListeners(type: any): any;

                removeAllListeners(type: any, ...args: any[]): any;

                removeListener(type: any, listener: any): any;

                setMaxListeners(n: any): any;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static defaultMaxListeners: any;

                static errorMonitor: any;

                static getEventListeners: any;

                static init: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static setMaxListeners: any;

                static usingDomains: any;

            }

        }

        namespace Readable {
            class Duplex {
                constructor(options: any);

                cork(): void;

                end(chunk: any, encoding: any, cb: any): any;

                setDefaultEncoding(encoding: any): any;

                uncork(): void;

                write(chunk: any, encoding: any, cb: any): any;

                static Duplex: any;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static PassThrough: any;

                static Readable: any;

                static ReadableState: any;

                static Stream: any;

                static Transform: any;

                static Writable: any;

                static addAbortSignal: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static compose: any;

                static defaultMaxListeners: any;

                static destroy: any;

                static errorMonitor: any;

                static finished: any;

                static from: any;

                static getEventListeners: any;

                static init: any;

                static isDisturbed: any;

                static isErrored: any;

                static isReadable: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static pipeline: any;

                static promises: any;

                static setMaxListeners: any;

                static usingDomains: any;

                static wrap: any;

            }

            class EventEmitter {
                constructor(opts: any);

                addListener(type: any, listener: any): any;

                emit(type: any, args: any): any;

                eventNames(): any;

                getMaxListeners(): any;

                listenerCount(type: any): any;

                listeners(type: any): any;

                off(type: any, listener: any): any;

                on(type: any, listener: any): any;

                once(type: any, listener: any): any;

                prependListener(type: any, listener: any): any;

                prependOnceListener(type: any, listener: any): any;

                rawListeners(type: any): any;

                removeAllListeners(type: any, ...args: any[]): any;

                removeListener(type: any, listener: any): any;

                setMaxListeners(n: any): any;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static defaultMaxListeners: any;

                static errorMonitor: any;

                static getEventListeners: any;

                static init: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static setMaxListeners: any;

                static usingDomains: any;

            }

            class EventEmitterAsyncResource {
                constructor(...args: any[]);

                emit(...args: any[]): void;

                emitDestroy(...args: any[]): void;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static defaultMaxListeners: any;

                static errorMonitor: any;

                static getEventListeners: any;

                static init: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static setMaxListeners: any;

                static usingDomains: any;

            }

            class ReadableState {
                constructor(options: any, stream: any, isDuplex: any);

            }

            class Stream {
                constructor(opts: any);

                pipe(dest: any, options: any): any;

                static Duplex: any;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static PassThrough: any;

                static Readable: any;

                static Stream: any;

                static Transform: any;

                static Writable: any;

                static addAbortSignal: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static compose: any;

                static defaultMaxListeners: any;

                static destroy: any;

                static errorMonitor: any;

                static finished: any;

                static getEventListeners: any;

                static init: any;

                static isDisturbed: any;

                static isErrored: any;

                static isReadable: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static pipeline: any;

                static promises: any;

                static setMaxListeners: any;

                static usingDomains: any;

            }

            class Transform {
                constructor(options: any);

                static Duplex: any;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static PassThrough: any;

                static Readable: any;

                static ReadableState: any;

                static Stream: any;

                static Transform: any;

                static Writable: any;

                static addAbortSignal: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static compose: any;

                static defaultMaxListeners: any;

                static destroy: any;

                static errorMonitor: any;

                static finished: any;

                static from: any;

                static getEventListeners: any;

                static init: any;

                static isDisturbed: any;

                static isErrored: any;

                static isReadable: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static pipeline: any;

                static promises: any;

                static setMaxListeners: any;

                static usingDomains: any;

                static wrap: any;

            }

            class Writable {
                constructor(options: any);

                cork(): void;

                destroy(err: any, cb: any): any;

                end(chunk: any, encoding: any, cb: any): any;

                pipe(): void;

                setDefaultEncoding(encoding: any): any;

                uncork(): void;

                write(chunk: any, encoding: any, cb: any): any;

                static Duplex: any;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static PassThrough: any;

                static Readable: any;

                static Stream: any;

                static Transform: any;

                static Writable: any;

                static WritableState: any;

                static addAbortSignal: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static compose: any;

                static defaultMaxListeners: any;

                static destroy: any;

                static errorMonitor: any;

                static finished: any;

                static getEventListeners: any;

                static init: any;

                static isDisturbed: any;

                static isErrored: any;

                static isReadable: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static pipeline: any;

                static promises: any;

                static setMaxListeners: any;

                static usingDomains: any;

            }

            namespace promises {
                // Too-deep object hierarchy from fs.FileReadStream.PassThrough.Readable.promises
                const finished: any;

                // Too-deep object hierarchy from fs.FileReadStream.PassThrough.Readable.promises
                const pipeline: any;

            }

        }

        namespace Stream {
            class Duplex {
                constructor(options: any);

                cork(): void;

                end(chunk: any, encoding: any, cb: any): any;

                setDefaultEncoding(encoding: any): any;

                uncork(): void;

                write(chunk: any, encoding: any, cb: any): any;

                static Duplex: any;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static PassThrough: any;

                static Readable: any;

                static ReadableState: any;

                static Stream: any;

                static Transform: any;

                static Writable: any;

                static addAbortSignal: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static compose: any;

                static defaultMaxListeners: any;

                static destroy: any;

                static errorMonitor: any;

                static finished: any;

                static from: any;

                static getEventListeners: any;

                static init: any;

                static isDisturbed: any;

                static isErrored: any;

                static isReadable: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static pipeline: any;

                static promises: any;

                static setMaxListeners: any;

                static usingDomains: any;

                static wrap: any;

            }

            class EventEmitter {
                constructor(opts: any);

                addListener(type: any, listener: any): any;

                emit(type: any, args: any): any;

                eventNames(): any;

                getMaxListeners(): any;

                listenerCount(type: any): any;

                listeners(type: any): any;

                off(type: any, listener: any): any;

                on(type: any, listener: any): any;

                once(type: any, listener: any): any;

                prependListener(type: any, listener: any): any;

                prependOnceListener(type: any, listener: any): any;

                rawListeners(type: any): any;

                removeAllListeners(type: any, ...args: any[]): any;

                removeListener(type: any, listener: any): any;

                setMaxListeners(n: any): any;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static defaultMaxListeners: any;

                static errorMonitor: any;

                static getEventListeners: any;

                static init: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static setMaxListeners: any;

                static usingDomains: any;

            }

            class EventEmitterAsyncResource {
                constructor(...args: any[]);

                emit(...args: any[]): void;

                emitDestroy(...args: any[]): void;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static defaultMaxListeners: any;

                static errorMonitor: any;

                static getEventListeners: any;

                static init: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static setMaxListeners: any;

                static usingDomains: any;

            }

            class Readable {
                constructor(options: any);

                addListener(ev: any, fn: any): any;

                destroy(err: any, cb: any): any;

                filter(args: any): any;

                isPaused(): any;

                iterator(options: any): any;

                map(args: any): any;

                off(ev: any, fn: any): any;

                on(ev: any, fn: any): any;

                pause(): any;

                pipe(dest: any, pipeOpts: any): any;

                push(chunk: any, encoding: any): any;

                read(n: any): any;

                removeAllListeners(ev: any, ...args: any[]): any;

                removeListener(ev: any, fn: any): any;

                resume(): any;

                setEncoding(enc: any): any;

                unpipe(dest: any): any;

                unshift(chunk: any, encoding: any): any;

                wrap(stream: any): any;

                static Duplex: any;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static PassThrough: any;

                static Readable: any;

                static ReadableState: any;

                static Stream: any;

                static Transform: any;

                static Writable: any;

                static addAbortSignal: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static compose: any;

                static defaultMaxListeners: any;

                static destroy: any;

                static errorMonitor: any;

                static finished: any;

                static from: any;

                static getEventListeners: any;

                static init: any;

                static isDisturbed: any;

                static isErrored: any;

                static isReadable: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static pipeline: any;

                static promises: any;

                static setMaxListeners: any;

                static usingDomains: any;

                static wrap: any;

            }

            class Transform {
                constructor(options: any);

                static Duplex: any;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static PassThrough: any;

                static Readable: any;

                static ReadableState: any;

                static Stream: any;

                static Transform: any;

                static Writable: any;

                static addAbortSignal: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static compose: any;

                static defaultMaxListeners: any;

                static destroy: any;

                static errorMonitor: any;

                static finished: any;

                static from: any;

                static getEventListeners: any;

                static init: any;

                static isDisturbed: any;

                static isErrored: any;

                static isReadable: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static pipeline: any;

                static promises: any;

                static setMaxListeners: any;

                static usingDomains: any;

                static wrap: any;

            }

            class Writable {
                constructor(options: any);

                cork(): void;

                destroy(err: any, cb: any): any;

                end(chunk: any, encoding: any, cb: any): any;

                pipe(): void;

                setDefaultEncoding(encoding: any): any;

                uncork(): void;

                write(chunk: any, encoding: any, cb: any): any;

                static Duplex: any;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static PassThrough: any;

                static Readable: any;

                static Stream: any;

                static Transform: any;

                static Writable: any;

                static WritableState: any;

                static addAbortSignal: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static compose: any;

                static defaultMaxListeners: any;

                static destroy: any;

                static errorMonitor: any;

                static finished: any;

                static getEventListeners: any;

                static init: any;

                static isDisturbed: any;

                static isErrored: any;

                static isReadable: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static pipeline: any;

                static promises: any;

                static setMaxListeners: any;

                static usingDomains: any;

            }

            namespace promises {
                // Too-deep object hierarchy from fs.FileReadStream.PassThrough.Stream.promises
                const finished: any;

                // Too-deep object hierarchy from fs.FileReadStream.PassThrough.Stream.promises
                const pipeline: any;

            }

        }

        namespace Transform {
            class Duplex {
                constructor(options: any);

                cork(): void;

                end(chunk: any, encoding: any, cb: any): any;

                setDefaultEncoding(encoding: any): any;

                uncork(): void;

                write(chunk: any, encoding: any, cb: any): any;

                static Duplex: any;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static PassThrough: any;

                static Readable: any;

                static ReadableState: any;

                static Stream: any;

                static Transform: any;

                static Writable: any;

                static addAbortSignal: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static compose: any;

                static defaultMaxListeners: any;

                static destroy: any;

                static errorMonitor: any;

                static finished: any;

                static from: any;

                static getEventListeners: any;

                static init: any;

                static isDisturbed: any;

                static isErrored: any;

                static isReadable: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static pipeline: any;

                static promises: any;

                static setMaxListeners: any;

                static usingDomains: any;

                static wrap: any;

            }

            class EventEmitter {
                constructor(opts: any);

                addListener(type: any, listener: any): any;

                emit(type: any, args: any): any;

                eventNames(): any;

                getMaxListeners(): any;

                listenerCount(type: any): any;

                listeners(type: any): any;

                off(type: any, listener: any): any;

                on(type: any, listener: any): any;

                once(type: any, listener: any): any;

                prependListener(type: any, listener: any): any;

                prependOnceListener(type: any, listener: any): any;

                rawListeners(type: any): any;

                removeAllListeners(type: any, ...args: any[]): any;

                removeListener(type: any, listener: any): any;

                setMaxListeners(n: any): any;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static defaultMaxListeners: any;

                static errorMonitor: any;

                static getEventListeners: any;

                static init: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static setMaxListeners: any;

                static usingDomains: any;

            }

            class EventEmitterAsyncResource {
                constructor(...args: any[]);

                emit(...args: any[]): void;

                emitDestroy(...args: any[]): void;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static defaultMaxListeners: any;

                static errorMonitor: any;

                static getEventListeners: any;

                static init: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static setMaxListeners: any;

                static usingDomains: any;

            }

            class Readable {
                constructor(options: any);

                addListener(ev: any, fn: any): any;

                destroy(err: any, cb: any): any;

                filter(args: any): any;

                isPaused(): any;

                iterator(options: any): any;

                map(args: any): any;

                off(ev: any, fn: any): any;

                on(ev: any, fn: any): any;

                pause(): any;

                pipe(dest: any, pipeOpts: any): any;

                push(chunk: any, encoding: any): any;

                read(n: any): any;

                removeAllListeners(ev: any, ...args: any[]): any;

                removeListener(ev: any, fn: any): any;

                resume(): any;

                setEncoding(enc: any): any;

                unpipe(dest: any): any;

                unshift(chunk: any, encoding: any): any;

                wrap(stream: any): any;

                static Duplex: any;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static PassThrough: any;

                static Readable: any;

                static ReadableState: any;

                static Stream: any;

                static Transform: any;

                static Writable: any;

                static addAbortSignal: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static compose: any;

                static defaultMaxListeners: any;

                static destroy: any;

                static errorMonitor: any;

                static finished: any;

                static from: any;

                static getEventListeners: any;

                static init: any;

                static isDisturbed: any;

                static isErrored: any;

                static isReadable: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static pipeline: any;

                static promises: any;

                static setMaxListeners: any;

                static usingDomains: any;

                static wrap: any;

            }

            class ReadableState {
                constructor(options: any, stream: any, isDuplex: any);

            }

            class Stream {
                constructor(opts: any);

                pipe(dest: any, options: any): any;

                static Duplex: any;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static PassThrough: any;

                static Readable: any;

                static Stream: any;

                static Transform: any;

                static Writable: any;

                static addAbortSignal: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static compose: any;

                static defaultMaxListeners: any;

                static destroy: any;

                static errorMonitor: any;

                static finished: any;

                static getEventListeners: any;

                static init: any;

                static isDisturbed: any;

                static isErrored: any;

                static isReadable: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static pipeline: any;

                static promises: any;

                static setMaxListeners: any;

                static usingDomains: any;

            }

            class Writable {
                constructor(options: any);

                cork(): void;

                destroy(err: any, cb: any): any;

                end(chunk: any, encoding: any, cb: any): any;

                pipe(): void;

                setDefaultEncoding(encoding: any): any;

                uncork(): void;

                write(chunk: any, encoding: any, cb: any): any;

                static Duplex: any;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static PassThrough: any;

                static Readable: any;

                static Stream: any;

                static Transform: any;

                static Writable: any;

                static WritableState: any;

                static addAbortSignal: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static compose: any;

                static defaultMaxListeners: any;

                static destroy: any;

                static errorMonitor: any;

                static finished: any;

                static getEventListeners: any;

                static init: any;

                static isDisturbed: any;

                static isErrored: any;

                static isReadable: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static pipeline: any;

                static promises: any;

                static setMaxListeners: any;

                static usingDomains: any;

            }

            namespace promises {
                // Too-deep object hierarchy from fs.FileReadStream.PassThrough.Transform.promises
                const finished: any;

                // Too-deep object hierarchy from fs.FileReadStream.PassThrough.Transform.promises
                const pipeline: any;

            }

        }

        namespace Writable {
            class Duplex {
                constructor(options: any);

                cork(): void;

                end(chunk: any, encoding: any, cb: any): any;

                setDefaultEncoding(encoding: any): any;

                uncork(): void;

                write(chunk: any, encoding: any, cb: any): any;

                static Duplex: any;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static PassThrough: any;

                static Readable: any;

                static ReadableState: any;

                static Stream: any;

                static Transform: any;

                static Writable: any;

                static addAbortSignal: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static compose: any;

                static defaultMaxListeners: any;

                static destroy: any;

                static errorMonitor: any;

                static finished: any;

                static from: any;

                static getEventListeners: any;

                static init: any;

                static isDisturbed: any;

                static isErrored: any;

                static isReadable: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static pipeline: any;

                static promises: any;

                static setMaxListeners: any;

                static usingDomains: any;

                static wrap: any;

            }

            class EventEmitter {
                constructor(opts: any);

                addListener(type: any, listener: any): any;

                emit(type: any, args: any): any;

                eventNames(): any;

                getMaxListeners(): any;

                listenerCount(type: any): any;

                listeners(type: any): any;

                off(type: any, listener: any): any;

                on(type: any, listener: any): any;

                once(type: any, listener: any): any;

                prependListener(type: any, listener: any): any;

                prependOnceListener(type: any, listener: any): any;

                rawListeners(type: any): any;

                removeAllListeners(type: any, ...args: any[]): any;

                removeListener(type: any, listener: any): any;

                setMaxListeners(n: any): any;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static defaultMaxListeners: any;

                static errorMonitor: any;

                static getEventListeners: any;

                static init: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static setMaxListeners: any;

                static usingDomains: any;

            }

            class EventEmitterAsyncResource {
                constructor(...args: any[]);

                emit(...args: any[]): void;

                emitDestroy(...args: any[]): void;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static defaultMaxListeners: any;

                static errorMonitor: any;

                static getEventListeners: any;

                static init: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static setMaxListeners: any;

                static usingDomains: any;

            }

            class Readable {
                constructor(options: any);

                addListener(ev: any, fn: any): any;

                destroy(err: any, cb: any): any;

                filter(args: any): any;

                isPaused(): any;

                iterator(options: any): any;

                map(args: any): any;

                off(ev: any, fn: any): any;

                on(ev: any, fn: any): any;

                pause(): any;

                pipe(dest: any, pipeOpts: any): any;

                push(chunk: any, encoding: any): any;

                read(n: any): any;

                removeAllListeners(ev: any, ...args: any[]): any;

                removeListener(ev: any, fn: any): any;

                resume(): any;

                setEncoding(enc: any): any;

                unpipe(dest: any): any;

                unshift(chunk: any, encoding: any): any;

                wrap(stream: any): any;

                static Duplex: any;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static PassThrough: any;

                static Readable: any;

                static ReadableState: any;

                static Stream: any;

                static Transform: any;

                static Writable: any;

                static addAbortSignal: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static compose: any;

                static defaultMaxListeners: any;

                static destroy: any;

                static errorMonitor: any;

                static finished: any;

                static from: any;

                static getEventListeners: any;

                static init: any;

                static isDisturbed: any;

                static isErrored: any;

                static isReadable: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static pipeline: any;

                static promises: any;

                static setMaxListeners: any;

                static usingDomains: any;

                static wrap: any;

            }

            class Stream {
                constructor(opts: any);

                pipe(dest: any, options: any): any;

                static Duplex: any;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static PassThrough: any;

                static Readable: any;

                static Stream: any;

                static Transform: any;

                static Writable: any;

                static addAbortSignal: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static compose: any;

                static defaultMaxListeners: any;

                static destroy: any;

                static errorMonitor: any;

                static finished: any;

                static getEventListeners: any;

                static init: any;

                static isDisturbed: any;

                static isErrored: any;

                static isReadable: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static pipeline: any;

                static promises: any;

                static setMaxListeners: any;

                static usingDomains: any;

            }

            class Transform {
                constructor(options: any);

                static Duplex: any;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static PassThrough: any;

                static Readable: any;

                static ReadableState: any;

                static Stream: any;

                static Transform: any;

                static Writable: any;

                static addAbortSignal: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static compose: any;

                static defaultMaxListeners: any;

                static destroy: any;

                static errorMonitor: any;

                static finished: any;

                static from: any;

                static getEventListeners: any;

                static init: any;

                static isDisturbed: any;

                static isErrored: any;

                static isReadable: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static pipeline: any;

                static promises: any;

                static setMaxListeners: any;

                static usingDomains: any;

                static wrap: any;

            }

            class WritableState {
                constructor(options: any, stream: any, isDuplex: any);

                getBuffer(): any;

            }

            namespace promises {
                // Too-deep object hierarchy from fs.FileReadStream.PassThrough.Writable.promises
                const finished: any;

                // Too-deep object hierarchy from fs.FileReadStream.PassThrough.Writable.promises
                const pipeline: any;

            }

        }

        namespace promises {
            function finished(stream: any, opts: any): any;

            function pipeline(streams: any): any;

        }

    }

    namespace Readable {
        class Duplex {
            constructor(options: any);

            cork(): void;

            end(chunk: any, encoding: any, cb: any): any;

            setDefaultEncoding(encoding: any): any;

            uncork(): void;

            write(chunk: any, encoding: any, cb: any): any;

            static Duplex: any;

            static Readable: any;

            static addAbortSignal(signal: any, stream: any): any;

            static captureRejectionSymbol: any;

            static captureRejections: boolean;

            static compose(streams: any): any;

            static defaultMaxListeners: number;

            static destroy(stream: any, err: any): any;

            static errorMonitor: any;

            static finished(stream: any, options: any, callback: any, ...args: any[]): any;

            static from(body: any): any;

            static getEventListeners(emitterOrTarget: any, type: any): any;

            static init(opts: any): void;

            static isDisturbed(stream: any): any;

            static isErrored(stream: any): any;

            static isReadable(stream: any): any;

            static kMaxEventTargetListeners: any;

            static kMaxEventTargetListenersWarned: any;

            static listenerCount(emitter: any, type: any): any;

            static on(emitter: any, event: any, options: any): any;

            static once(emitter: any, name: any, options: any): any;

            static pipeline(streams: any): any;

            static setMaxListeners(n: any, eventTargets: any): void;

            static usingDomains: boolean;

            static wrap(src: any, options: any): any;

        }

        class EventEmitter {
            constructor(opts: any);

            addListener(type: any, listener: any): any;

            emit(type: any, args: any): any;

            eventNames(): any;

            getMaxListeners(): any;

            listenerCount(type: any): any;

            listeners(type: any): any;

            off(type: any, listener: any): any;

            on(type: any, listener: any): any;

            once(type: any, listener: any): any;

            prependListener(type: any, listener: any): any;

            prependOnceListener(type: any, listener: any): any;

            rawListeners(type: any): any;

            removeAllListeners(type: any, ...args: any[]): any;

            removeListener(type: any, listener: any): any;

            setMaxListeners(n: any): any;

            static EventEmitter: any;

            static captureRejectionSymbol: any;

            static captureRejections: boolean;

            static defaultMaxListeners: number;

            static errorMonitor: any;

            static getEventListeners(emitterOrTarget: any, type: any): any;

            static init(opts: any): void;

            static kMaxEventTargetListeners: any;

            static kMaxEventTargetListenersWarned: any;

            static listenerCount(emitter: any, type: any): any;

            static on(emitter: any, event: any, options: any): any;

            static once(emitter: any, name: any, options: any): any;

            static setMaxListeners(n: any, eventTargets: any): void;

            static usingDomains: boolean;

        }

        class EventEmitterAsyncResource {
            constructor(...args: any[]);

            emit(...args: any[]): void;

            emitDestroy(...args: any[]): void;

            static EventEmitterAsyncResource: any;

            static captureRejectionSymbol: any;

            static captureRejections: boolean;

            static defaultMaxListeners: number;

            static errorMonitor: any;

            static getEventListeners(emitterOrTarget: any, type: any): any;

            static init(opts: any): void;

            static kMaxEventTargetListeners: any;

            static kMaxEventTargetListenersWarned: any;

            static listenerCount(emitter: any, type: any): any;

            static on(emitter: any, event: any, options: any): any;

            static once(emitter: any, name: any, options: any): any;

            static setMaxListeners(n: any, eventTargets: any): void;

            static usingDomains: boolean;

        }

        class PassThrough {
            constructor(options: any);

            static PassThrough: any;

            static Readable: any;

            static addAbortSignal(signal: any, stream: any): any;

            static captureRejectionSymbol: any;

            static captureRejections: boolean;

            static compose(streams: any): any;

            static defaultMaxListeners: number;

            static destroy(stream: any, err: any): any;

            static errorMonitor: any;

            static finished(stream: any, options: any, callback: any, ...args: any[]): any;

            static from(body: any): any;

            static getEventListeners(emitterOrTarget: any, type: any): any;

            static init(opts: any): void;

            static isDisturbed(stream: any): any;

            static isErrored(stream: any): any;

            static isReadable(stream: any): any;

            static kMaxEventTargetListeners: any;

            static kMaxEventTargetListenersWarned: any;

            static listenerCount(emitter: any, type: any): any;

            static on(emitter: any, event: any, options: any): any;

            static once(emitter: any, name: any, options: any): any;

            static pipeline(streams: any): any;

            static setMaxListeners(n: any, eventTargets: any): void;

            static usingDomains: boolean;

            static wrap(src: any, options: any): any;

        }

        class ReadableState {
            constructor(options: any, stream: any, isDuplex: any);

        }

        class Stream {
            constructor(opts: any);

            pipe(dest: any, options: any): any;

            static Readable: any;

            static Stream: any;

            static addAbortSignal(signal: any, stream: any): any;

            static captureRejectionSymbol: any;

            static captureRejections: boolean;

            static compose(streams: any): any;

            static defaultMaxListeners: number;

            static destroy(stream: any, err: any): any;

            static errorMonitor: any;

            static finished(stream: any, options: any, callback: any, ...args: any[]): any;

            static getEventListeners(emitterOrTarget: any, type: any): any;

            static init(opts: any): void;

            static isDisturbed(stream: any): any;

            static isErrored(stream: any): any;

            static isReadable(stream: any): any;

            static kMaxEventTargetListeners: any;

            static kMaxEventTargetListenersWarned: any;

            static listenerCount(emitter: any, type: any): any;

            static on(emitter: any, event: any, options: any): any;

            static once(emitter: any, name: any, options: any): any;

            static pipeline(streams: any): any;

            static setMaxListeners(n: any, eventTargets: any): void;

            static usingDomains: boolean;

        }

        class Transform {
            constructor(options: any);

            static Readable: any;

            static Transform: any;

            static addAbortSignal(signal: any, stream: any): any;

            static captureRejectionSymbol: any;

            static captureRejections: boolean;

            static compose(streams: any): any;

            static defaultMaxListeners: number;

            static destroy(stream: any, err: any): any;

            static errorMonitor: any;

            static finished(stream: any, options: any, callback: any, ...args: any[]): any;

            static from(body: any): any;

            static getEventListeners(emitterOrTarget: any, type: any): any;

            static init(opts: any): void;

            static isDisturbed(stream: any): any;

            static isErrored(stream: any): any;

            static isReadable(stream: any): any;

            static kMaxEventTargetListeners: any;

            static kMaxEventTargetListenersWarned: any;

            static listenerCount(emitter: any, type: any): any;

            static on(emitter: any, event: any, options: any): any;

            static once(emitter: any, name: any, options: any): any;

            static pipeline(streams: any): any;

            static setMaxListeners(n: any, eventTargets: any): void;

            static usingDomains: boolean;

            static wrap(src: any, options: any): any;

        }

        class Writable {
            constructor(options: any);

            cork(): void;

            destroy(err: any, cb: any): any;

            end(chunk: any, encoding: any, cb: any): any;

            pipe(): void;

            setDefaultEncoding(encoding: any): any;

            uncork(): void;

            write(chunk: any, encoding: any, cb: any): any;

            static Readable: any;

            static Writable: any;

            static addAbortSignal(signal: any, stream: any): any;

            static captureRejectionSymbol: any;

            static captureRejections: boolean;

            static compose(streams: any): any;

            static defaultMaxListeners: number;

            static destroy(stream: any, err: any): any;

            static errorMonitor: any;

            static finished(stream: any, options: any, callback: any, ...args: any[]): any;

            static getEventListeners(emitterOrTarget: any, type: any): any;

            static init(opts: any): void;

            static isDisturbed(stream: any): any;

            static isErrored(stream: any): any;

            static isReadable(stream: any): any;

            static kMaxEventTargetListeners: any;

            static kMaxEventTargetListenersWarned: any;

            static listenerCount(emitter: any, type: any): any;

            static on(emitter: any, event: any, options: any): any;

            static once(emitter: any, name: any, options: any): any;

            static pipeline(streams: any): any;

            static setMaxListeners(n: any, eventTargets: any): void;

            static usingDomains: boolean;

        }

        namespace Duplex {
            class EventEmitter {
                constructor(opts: any);

                addListener(type: any, listener: any): any;

                emit(type: any, args: any): any;

                eventNames(): any;

                getMaxListeners(): any;

                listenerCount(type: any): any;

                listeners(type: any): any;

                off(type: any, listener: any): any;

                on(type: any, listener: any): any;

                once(type: any, listener: any): any;

                prependListener(type: any, listener: any): any;

                prependOnceListener(type: any, listener: any): any;

                rawListeners(type: any): any;

                removeAllListeners(type: any, ...args: any[]): any;

                removeListener(type: any, listener: any): any;

                setMaxListeners(n: any): any;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static defaultMaxListeners: any;

                static errorMonitor: any;

                static getEventListeners: any;

                static init: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static setMaxListeners: any;

                static usingDomains: any;

            }

            class EventEmitterAsyncResource {
                constructor(...args: any[]);

                emit(...args: any[]): void;

                emitDestroy(...args: any[]): void;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static defaultMaxListeners: any;

                static errorMonitor: any;

                static getEventListeners: any;

                static init: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static setMaxListeners: any;

                static usingDomains: any;

            }

            class PassThrough {
                constructor(options: any);

                static Duplex: any;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static PassThrough: any;

                static Readable: any;

                static ReadableState: any;

                static Stream: any;

                static Transform: any;

                static Writable: any;

                static addAbortSignal: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static compose: any;

                static defaultMaxListeners: any;

                static destroy: any;

                static errorMonitor: any;

                static finished: any;

                static from: any;

                static getEventListeners: any;

                static init: any;

                static isDisturbed: any;

                static isErrored: any;

                static isReadable: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static pipeline: any;

                static promises: any;

                static setMaxListeners: any;

                static usingDomains: any;

                static wrap: any;

            }

            class ReadableState {
                constructor(options: any, stream: any, isDuplex: any);

            }

            class Stream {
                constructor(opts: any);

                pipe(dest: any, options: any): any;

                static Duplex: any;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static PassThrough: any;

                static Readable: any;

                static Stream: any;

                static Transform: any;

                static Writable: any;

                static addAbortSignal: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static compose: any;

                static defaultMaxListeners: any;

                static destroy: any;

                static errorMonitor: any;

                static finished: any;

                static getEventListeners: any;

                static init: any;

                static isDisturbed: any;

                static isErrored: any;

                static isReadable: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static pipeline: any;

                static promises: any;

                static setMaxListeners: any;

                static usingDomains: any;

            }

            class Transform {
                constructor(options: any);

                static Duplex: any;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static PassThrough: any;

                static Readable: any;

                static ReadableState: any;

                static Stream: any;

                static Transform: any;

                static Writable: any;

                static addAbortSignal: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static compose: any;

                static defaultMaxListeners: any;

                static destroy: any;

                static errorMonitor: any;

                static finished: any;

                static from: any;

                static getEventListeners: any;

                static init: any;

                static isDisturbed: any;

                static isErrored: any;

                static isReadable: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static pipeline: any;

                static promises: any;

                static setMaxListeners: any;

                static usingDomains: any;

                static wrap: any;

            }

            class Writable {
                constructor(options: any);

                cork(): void;

                destroy(err: any, cb: any): any;

                end(chunk: any, encoding: any, cb: any): any;

                pipe(): void;

                setDefaultEncoding(encoding: any): any;

                uncork(): void;

                write(chunk: any, encoding: any, cb: any): any;

                static Duplex: any;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static PassThrough: any;

                static Readable: any;

                static Stream: any;

                static Transform: any;

                static Writable: any;

                static WritableState: any;

                static addAbortSignal: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static compose: any;

                static defaultMaxListeners: any;

                static destroy: any;

                static errorMonitor: any;

                static finished: any;

                static getEventListeners: any;

                static init: any;

                static isDisturbed: any;

                static isErrored: any;

                static isReadable: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static pipeline: any;

                static promises: any;

                static setMaxListeners: any;

                static usingDomains: any;

            }

            namespace promises {
                // Too-deep object hierarchy from fs.FileReadStream.Readable.Duplex.promises
                const finished: any;

                // Too-deep object hierarchy from fs.FileReadStream.Readable.Duplex.promises
                const pipeline: any;

            }

        }

        namespace EventEmitter {
            class EventEmitterAsyncResource {
                constructor(...args: any[]);

                emit(...args: any[]): void;

                emitDestroy(...args: any[]): void;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static defaultMaxListeners: any;

                static errorMonitor: any;

                static getEventListeners: any;

                static init: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static setMaxListeners: any;

                static usingDomains: any;

            }

        }

        namespace EventEmitterAsyncResource {
            class EventEmitter {
                constructor(opts: any);

                addListener(type: any, listener: any): any;

                emit(type: any, args: any): any;

                eventNames(): any;

                getMaxListeners(): any;

                listenerCount(type: any): any;

                listeners(type: any): any;

                off(type: any, listener: any): any;

                on(type: any, listener: any): any;

                once(type: any, listener: any): any;

                prependListener(type: any, listener: any): any;

                prependOnceListener(type: any, listener: any): any;

                rawListeners(type: any): any;

                removeAllListeners(type: any, ...args: any[]): any;

                removeListener(type: any, listener: any): any;

                setMaxListeners(n: any): any;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static defaultMaxListeners: any;

                static errorMonitor: any;

                static getEventListeners: any;

                static init: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static setMaxListeners: any;

                static usingDomains: any;

            }

        }

        namespace PassThrough {
            class Duplex {
                constructor(options: any);

                cork(): void;

                end(chunk: any, encoding: any, cb: any): any;

                setDefaultEncoding(encoding: any): any;

                uncork(): void;

                write(chunk: any, encoding: any, cb: any): any;

                static Duplex: any;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static PassThrough: any;

                static Readable: any;

                static ReadableState: any;

                static Stream: any;

                static Transform: any;

                static Writable: any;

                static addAbortSignal: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static compose: any;

                static defaultMaxListeners: any;

                static destroy: any;

                static errorMonitor: any;

                static finished: any;

                static from: any;

                static getEventListeners: any;

                static init: any;

                static isDisturbed: any;

                static isErrored: any;

                static isReadable: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static pipeline: any;

                static promises: any;

                static setMaxListeners: any;

                static usingDomains: any;

                static wrap: any;

            }

            class EventEmitter {
                constructor(opts: any);

                addListener(type: any, listener: any): any;

                emit(type: any, args: any): any;

                eventNames(): any;

                getMaxListeners(): any;

                listenerCount(type: any): any;

                listeners(type: any): any;

                off(type: any, listener: any): any;

                on(type: any, listener: any): any;

                once(type: any, listener: any): any;

                prependListener(type: any, listener: any): any;

                prependOnceListener(type: any, listener: any): any;

                rawListeners(type: any): any;

                removeAllListeners(type: any, ...args: any[]): any;

                removeListener(type: any, listener: any): any;

                setMaxListeners(n: any): any;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static defaultMaxListeners: any;

                static errorMonitor: any;

                static getEventListeners: any;

                static init: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static setMaxListeners: any;

                static usingDomains: any;

            }

            class EventEmitterAsyncResource {
                constructor(...args: any[]);

                emit(...args: any[]): void;

                emitDestroy(...args: any[]): void;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static defaultMaxListeners: any;

                static errorMonitor: any;

                static getEventListeners: any;

                static init: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static setMaxListeners: any;

                static usingDomains: any;

            }

            class ReadableState {
                constructor(options: any, stream: any, isDuplex: any);

            }

            class Stream {
                constructor(opts: any);

                pipe(dest: any, options: any): any;

                static Duplex: any;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static PassThrough: any;

                static Readable: any;

                static Stream: any;

                static Transform: any;

                static Writable: any;

                static addAbortSignal: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static compose: any;

                static defaultMaxListeners: any;

                static destroy: any;

                static errorMonitor: any;

                static finished: any;

                static getEventListeners: any;

                static init: any;

                static isDisturbed: any;

                static isErrored: any;

                static isReadable: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static pipeline: any;

                static promises: any;

                static setMaxListeners: any;

                static usingDomains: any;

            }

            class Transform {
                constructor(options: any);

                static Duplex: any;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static PassThrough: any;

                static Readable: any;

                static ReadableState: any;

                static Stream: any;

                static Transform: any;

                static Writable: any;

                static addAbortSignal: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static compose: any;

                static defaultMaxListeners: any;

                static destroy: any;

                static errorMonitor: any;

                static finished: any;

                static from: any;

                static getEventListeners: any;

                static init: any;

                static isDisturbed: any;

                static isErrored: any;

                static isReadable: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static pipeline: any;

                static promises: any;

                static setMaxListeners: any;

                static usingDomains: any;

                static wrap: any;

            }

            class Writable {
                constructor(options: any);

                cork(): void;

                destroy(err: any, cb: any): any;

                end(chunk: any, encoding: any, cb: any): any;

                pipe(): void;

                setDefaultEncoding(encoding: any): any;

                uncork(): void;

                write(chunk: any, encoding: any, cb: any): any;

                static Duplex: any;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static PassThrough: any;

                static Readable: any;

                static Stream: any;

                static Transform: any;

                static Writable: any;

                static WritableState: any;

                static addAbortSignal: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static compose: any;

                static defaultMaxListeners: any;

                static destroy: any;

                static errorMonitor: any;

                static finished: any;

                static getEventListeners: any;

                static init: any;

                static isDisturbed: any;

                static isErrored: any;

                static isReadable: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static pipeline: any;

                static promises: any;

                static setMaxListeners: any;

                static usingDomains: any;

            }

            namespace promises {
                // Too-deep object hierarchy from fs.FileReadStream.Readable.PassThrough.promises
                const finished: any;

                // Too-deep object hierarchy from fs.FileReadStream.Readable.PassThrough.promises
                const pipeline: any;

            }

        }

        namespace Stream {
            class Duplex {
                constructor(options: any);

                cork(): void;

                end(chunk: any, encoding: any, cb: any): any;

                setDefaultEncoding(encoding: any): any;

                uncork(): void;

                write(chunk: any, encoding: any, cb: any): any;

                static Duplex: any;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static PassThrough: any;

                static Readable: any;

                static ReadableState: any;

                static Stream: any;

                static Transform: any;

                static Writable: any;

                static addAbortSignal: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static compose: any;

                static defaultMaxListeners: any;

                static destroy: any;

                static errorMonitor: any;

                static finished: any;

                static from: any;

                static getEventListeners: any;

                static init: any;

                static isDisturbed: any;

                static isErrored: any;

                static isReadable: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static pipeline: any;

                static promises: any;

                static setMaxListeners: any;

                static usingDomains: any;

                static wrap: any;

            }

            class EventEmitter {
                constructor(opts: any);

                addListener(type: any, listener: any): any;

                emit(type: any, args: any): any;

                eventNames(): any;

                getMaxListeners(): any;

                listenerCount(type: any): any;

                listeners(type: any): any;

                off(type: any, listener: any): any;

                on(type: any, listener: any): any;

                once(type: any, listener: any): any;

                prependListener(type: any, listener: any): any;

                prependOnceListener(type: any, listener: any): any;

                rawListeners(type: any): any;

                removeAllListeners(type: any, ...args: any[]): any;

                removeListener(type: any, listener: any): any;

                setMaxListeners(n: any): any;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static defaultMaxListeners: any;

                static errorMonitor: any;

                static getEventListeners: any;

                static init: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static setMaxListeners: any;

                static usingDomains: any;

            }

            class EventEmitterAsyncResource {
                constructor(...args: any[]);

                emit(...args: any[]): void;

                emitDestroy(...args: any[]): void;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static defaultMaxListeners: any;

                static errorMonitor: any;

                static getEventListeners: any;

                static init: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static setMaxListeners: any;

                static usingDomains: any;

            }

            class PassThrough {
                constructor(options: any);

                static Duplex: any;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static PassThrough: any;

                static Readable: any;

                static ReadableState: any;

                static Stream: any;

                static Transform: any;

                static Writable: any;

                static addAbortSignal: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static compose: any;

                static defaultMaxListeners: any;

                static destroy: any;

                static errorMonitor: any;

                static finished: any;

                static from: any;

                static getEventListeners: any;

                static init: any;

                static isDisturbed: any;

                static isErrored: any;

                static isReadable: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static pipeline: any;

                static promises: any;

                static setMaxListeners: any;

                static usingDomains: any;

                static wrap: any;

            }

            class Transform {
                constructor(options: any);

                static Duplex: any;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static PassThrough: any;

                static Readable: any;

                static ReadableState: any;

                static Stream: any;

                static Transform: any;

                static Writable: any;

                static addAbortSignal: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static compose: any;

                static defaultMaxListeners: any;

                static destroy: any;

                static errorMonitor: any;

                static finished: any;

                static from: any;

                static getEventListeners: any;

                static init: any;

                static isDisturbed: any;

                static isErrored: any;

                static isReadable: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static pipeline: any;

                static promises: any;

                static setMaxListeners: any;

                static usingDomains: any;

                static wrap: any;

            }

            class Writable {
                constructor(options: any);

                cork(): void;

                destroy(err: any, cb: any): any;

                end(chunk: any, encoding: any, cb: any): any;

                pipe(): void;

                setDefaultEncoding(encoding: any): any;

                uncork(): void;

                write(chunk: any, encoding: any, cb: any): any;

                static Duplex: any;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static PassThrough: any;

                static Readable: any;

                static Stream: any;

                static Transform: any;

                static Writable: any;

                static WritableState: any;

                static addAbortSignal: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static compose: any;

                static defaultMaxListeners: any;

                static destroy: any;

                static errorMonitor: any;

                static finished: any;

                static getEventListeners: any;

                static init: any;

                static isDisturbed: any;

                static isErrored: any;

                static isReadable: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static pipeline: any;

                static promises: any;

                static setMaxListeners: any;

                static usingDomains: any;

            }

            namespace promises {
                // Too-deep object hierarchy from fs.FileReadStream.Readable.Stream.promises
                const finished: any;

                // Too-deep object hierarchy from fs.FileReadStream.Readable.Stream.promises
                const pipeline: any;

            }

        }

        namespace Transform {
            class Duplex {
                constructor(options: any);

                cork(): void;

                end(chunk: any, encoding: any, cb: any): any;

                setDefaultEncoding(encoding: any): any;

                uncork(): void;

                write(chunk: any, encoding: any, cb: any): any;

                static Duplex: any;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static PassThrough: any;

                static Readable: any;

                static ReadableState: any;

                static Stream: any;

                static Transform: any;

                static Writable: any;

                static addAbortSignal: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static compose: any;

                static defaultMaxListeners: any;

                static destroy: any;

                static errorMonitor: any;

                static finished: any;

                static from: any;

                static getEventListeners: any;

                static init: any;

                static isDisturbed: any;

                static isErrored: any;

                static isReadable: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static pipeline: any;

                static promises: any;

                static setMaxListeners: any;

                static usingDomains: any;

                static wrap: any;

            }

            class EventEmitter {
                constructor(opts: any);

                addListener(type: any, listener: any): any;

                emit(type: any, args: any): any;

                eventNames(): any;

                getMaxListeners(): any;

                listenerCount(type: any): any;

                listeners(type: any): any;

                off(type: any, listener: any): any;

                on(type: any, listener: any): any;

                once(type: any, listener: any): any;

                prependListener(type: any, listener: any): any;

                prependOnceListener(type: any, listener: any): any;

                rawListeners(type: any): any;

                removeAllListeners(type: any, ...args: any[]): any;

                removeListener(type: any, listener: any): any;

                setMaxListeners(n: any): any;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static defaultMaxListeners: any;

                static errorMonitor: any;

                static getEventListeners: any;

                static init: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static setMaxListeners: any;

                static usingDomains: any;

            }

            class EventEmitterAsyncResource {
                constructor(...args: any[]);

                emit(...args: any[]): void;

                emitDestroy(...args: any[]): void;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static defaultMaxListeners: any;

                static errorMonitor: any;

                static getEventListeners: any;

                static init: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static setMaxListeners: any;

                static usingDomains: any;

            }

            class PassThrough {
                constructor(options: any);

                static Duplex: any;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static PassThrough: any;

                static Readable: any;

                static ReadableState: any;

                static Stream: any;

                static Transform: any;

                static Writable: any;

                static addAbortSignal: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static compose: any;

                static defaultMaxListeners: any;

                static destroy: any;

                static errorMonitor: any;

                static finished: any;

                static from: any;

                static getEventListeners: any;

                static init: any;

                static isDisturbed: any;

                static isErrored: any;

                static isReadable: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static pipeline: any;

                static promises: any;

                static setMaxListeners: any;

                static usingDomains: any;

                static wrap: any;

            }

            class ReadableState {
                constructor(options: any, stream: any, isDuplex: any);

            }

            class Stream {
                constructor(opts: any);

                pipe(dest: any, options: any): any;

                static Duplex: any;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static PassThrough: any;

                static Readable: any;

                static Stream: any;

                static Transform: any;

                static Writable: any;

                static addAbortSignal: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static compose: any;

                static defaultMaxListeners: any;

                static destroy: any;

                static errorMonitor: any;

                static finished: any;

                static getEventListeners: any;

                static init: any;

                static isDisturbed: any;

                static isErrored: any;

                static isReadable: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static pipeline: any;

                static promises: any;

                static setMaxListeners: any;

                static usingDomains: any;

            }

            class Writable {
                constructor(options: any);

                cork(): void;

                destroy(err: any, cb: any): any;

                end(chunk: any, encoding: any, cb: any): any;

                pipe(): void;

                setDefaultEncoding(encoding: any): any;

                uncork(): void;

                write(chunk: any, encoding: any, cb: any): any;

                static Duplex: any;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static PassThrough: any;

                static Readable: any;

                static Stream: any;

                static Transform: any;

                static Writable: any;

                static WritableState: any;

                static addAbortSignal: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static compose: any;

                static defaultMaxListeners: any;

                static destroy: any;

                static errorMonitor: any;

                static finished: any;

                static getEventListeners: any;

                static init: any;

                static isDisturbed: any;

                static isErrored: any;

                static isReadable: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static pipeline: any;

                static promises: any;

                static setMaxListeners: any;

                static usingDomains: any;

            }

            namespace promises {
                // Too-deep object hierarchy from fs.FileReadStream.Readable.Transform.promises
                const finished: any;

                // Too-deep object hierarchy from fs.FileReadStream.Readable.Transform.promises
                const pipeline: any;

            }

        }

        namespace Writable {
            class Duplex {
                constructor(options: any);

                cork(): void;

                end(chunk: any, encoding: any, cb: any): any;

                setDefaultEncoding(encoding: any): any;

                uncork(): void;

                write(chunk: any, encoding: any, cb: any): any;

                static Duplex: any;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static PassThrough: any;

                static Readable: any;

                static ReadableState: any;

                static Stream: any;

                static Transform: any;

                static Writable: any;

                static addAbortSignal: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static compose: any;

                static defaultMaxListeners: any;

                static destroy: any;

                static errorMonitor: any;

                static finished: any;

                static from: any;

                static getEventListeners: any;

                static init: any;

                static isDisturbed: any;

                static isErrored: any;

                static isReadable: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static pipeline: any;

                static promises: any;

                static setMaxListeners: any;

                static usingDomains: any;

                static wrap: any;

            }

            class EventEmitter {
                constructor(opts: any);

                addListener(type: any, listener: any): any;

                emit(type: any, args: any): any;

                eventNames(): any;

                getMaxListeners(): any;

                listenerCount(type: any): any;

                listeners(type: any): any;

                off(type: any, listener: any): any;

                on(type: any, listener: any): any;

                once(type: any, listener: any): any;

                prependListener(type: any, listener: any): any;

                prependOnceListener(type: any, listener: any): any;

                rawListeners(type: any): any;

                removeAllListeners(type: any, ...args: any[]): any;

                removeListener(type: any, listener: any): any;

                setMaxListeners(n: any): any;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static defaultMaxListeners: any;

                static errorMonitor: any;

                static getEventListeners: any;

                static init: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static setMaxListeners: any;

                static usingDomains: any;

            }

            class EventEmitterAsyncResource {
                constructor(...args: any[]);

                emit(...args: any[]): void;

                emitDestroy(...args: any[]): void;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static defaultMaxListeners: any;

                static errorMonitor: any;

                static getEventListeners: any;

                static init: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static setMaxListeners: any;

                static usingDomains: any;

            }

            class PassThrough {
                constructor(options: any);

                static Duplex: any;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static PassThrough: any;

                static Readable: any;

                static ReadableState: any;

                static Stream: any;

                static Transform: any;

                static Writable: any;

                static addAbortSignal: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static compose: any;

                static defaultMaxListeners: any;

                static destroy: any;

                static errorMonitor: any;

                static finished: any;

                static from: any;

                static getEventListeners: any;

                static init: any;

                static isDisturbed: any;

                static isErrored: any;

                static isReadable: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static pipeline: any;

                static promises: any;

                static setMaxListeners: any;

                static usingDomains: any;

                static wrap: any;

            }

            class Stream {
                constructor(opts: any);

                pipe(dest: any, options: any): any;

                static Duplex: any;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static PassThrough: any;

                static Readable: any;

                static Stream: any;

                static Transform: any;

                static Writable: any;

                static addAbortSignal: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static compose: any;

                static defaultMaxListeners: any;

                static destroy: any;

                static errorMonitor: any;

                static finished: any;

                static getEventListeners: any;

                static init: any;

                static isDisturbed: any;

                static isErrored: any;

                static isReadable: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static pipeline: any;

                static promises: any;

                static setMaxListeners: any;

                static usingDomains: any;

            }

            class Transform {
                constructor(options: any);

                static Duplex: any;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static PassThrough: any;

                static Readable: any;

                static ReadableState: any;

                static Stream: any;

                static Transform: any;

                static Writable: any;

                static addAbortSignal: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static compose: any;

                static defaultMaxListeners: any;

                static destroy: any;

                static errorMonitor: any;

                static finished: any;

                static from: any;

                static getEventListeners: any;

                static init: any;

                static isDisturbed: any;

                static isErrored: any;

                static isReadable: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static pipeline: any;

                static promises: any;

                static setMaxListeners: any;

                static usingDomains: any;

                static wrap: any;

            }

            class WritableState {
                constructor(options: any, stream: any, isDuplex: any);

                getBuffer(): any;

            }

            namespace promises {
                // Too-deep object hierarchy from fs.FileReadStream.Readable.Writable.promises
                const finished: any;

                // Too-deep object hierarchy from fs.FileReadStream.Readable.Writable.promises
                const pipeline: any;

            }

        }

        namespace promises {
            function finished(stream: any, opts: any): any;

            function pipeline(streams: any): any;

        }

    }

    namespace Stream {
        class Duplex {
            constructor(options: any);

            cork(): void;

            end(chunk: any, encoding: any, cb: any): any;

            setDefaultEncoding(encoding: any): any;

            uncork(): void;

            write(chunk: any, encoding: any, cb: any): any;

            static Duplex: any;

            static Stream: any;

            static addAbortSignal(signal: any, stream: any): any;

            static captureRejectionSymbol: any;

            static captureRejections: boolean;

            static compose(streams: any): any;

            static defaultMaxListeners: number;

            static destroy(stream: any, err: any): any;

            static errorMonitor: any;

            static finished(stream: any, options: any, callback: any, ...args: any[]): any;

            static from(body: any): any;

            static getEventListeners(emitterOrTarget: any, type: any): any;

            static init(opts: any): void;

            static isDisturbed(stream: any): any;

            static isErrored(stream: any): any;

            static isReadable(stream: any): any;

            static kMaxEventTargetListeners: any;

            static kMaxEventTargetListenersWarned: any;

            static listenerCount(emitter: any, type: any): any;

            static on(emitter: any, event: any, options: any): any;

            static once(emitter: any, name: any, options: any): any;

            static pipeline(streams: any): any;

            static setMaxListeners(n: any, eventTargets: any): void;

            static usingDomains: boolean;

            static wrap(src: any, options: any): any;

        }

        class EventEmitter {
            constructor(opts: any);

            addListener(type: any, listener: any): any;

            emit(type: any, args: any): any;

            eventNames(): any;

            getMaxListeners(): any;

            listenerCount(type: any): any;

            listeners(type: any): any;

            off(type: any, listener: any): any;

            on(type: any, listener: any): any;

            once(type: any, listener: any): any;

            prependListener(type: any, listener: any): any;

            prependOnceListener(type: any, listener: any): any;

            rawListeners(type: any): any;

            removeAllListeners(type: any, ...args: any[]): any;

            removeListener(type: any, listener: any): any;

            setMaxListeners(n: any): any;

            static EventEmitter: any;

            static captureRejectionSymbol: any;

            static captureRejections: boolean;

            static defaultMaxListeners: number;

            static errorMonitor: any;

            static getEventListeners(emitterOrTarget: any, type: any): any;

            static init(opts: any): void;

            static kMaxEventTargetListeners: any;

            static kMaxEventTargetListenersWarned: any;

            static listenerCount(emitter: any, type: any): any;

            static on(emitter: any, event: any, options: any): any;

            static once(emitter: any, name: any, options: any): any;

            static setMaxListeners(n: any, eventTargets: any): void;

            static usingDomains: boolean;

        }

        class EventEmitterAsyncResource {
            constructor(...args: any[]);

            emit(...args: any[]): void;

            emitDestroy(...args: any[]): void;

            static EventEmitterAsyncResource: any;

            static captureRejectionSymbol: any;

            static captureRejections: boolean;

            static defaultMaxListeners: number;

            static errorMonitor: any;

            static getEventListeners(emitterOrTarget: any, type: any): any;

            static init(opts: any): void;

            static kMaxEventTargetListeners: any;

            static kMaxEventTargetListenersWarned: any;

            static listenerCount(emitter: any, type: any): any;

            static on(emitter: any, event: any, options: any): any;

            static once(emitter: any, name: any, options: any): any;

            static setMaxListeners(n: any, eventTargets: any): void;

            static usingDomains: boolean;

        }

        class PassThrough {
            constructor(options: any);

            static PassThrough: any;

            static Stream: any;

            static addAbortSignal(signal: any, stream: any): any;

            static captureRejectionSymbol: any;

            static captureRejections: boolean;

            static compose(streams: any): any;

            static defaultMaxListeners: number;

            static destroy(stream: any, err: any): any;

            static errorMonitor: any;

            static finished(stream: any, options: any, callback: any, ...args: any[]): any;

            static from(body: any): any;

            static getEventListeners(emitterOrTarget: any, type: any): any;

            static init(opts: any): void;

            static isDisturbed(stream: any): any;

            static isErrored(stream: any): any;

            static isReadable(stream: any): any;

            static kMaxEventTargetListeners: any;

            static kMaxEventTargetListenersWarned: any;

            static listenerCount(emitter: any, type: any): any;

            static on(emitter: any, event: any, options: any): any;

            static once(emitter: any, name: any, options: any): any;

            static pipeline(streams: any): any;

            static setMaxListeners(n: any, eventTargets: any): void;

            static usingDomains: boolean;

            static wrap(src: any, options: any): any;

        }

        class Readable {
            constructor(options: any);

            addListener(ev: any, fn: any): any;

            destroy(err: any, cb: any): any;

            filter(args: any): any;

            isPaused(): any;

            iterator(options: any): any;

            map(args: any): any;

            off(ev: any, fn: any): any;

            on(ev: any, fn: any): any;

            pause(): any;

            pipe(dest: any, pipeOpts: any): any;

            push(chunk: any, encoding: any): any;

            read(n: any): any;

            removeAllListeners(ev: any, ...args: any[]): any;

            removeListener(ev: any, fn: any): any;

            resume(): any;

            setEncoding(enc: any): any;

            unpipe(dest: any): any;

            unshift(chunk: any, encoding: any): any;

            wrap(stream: any): any;

            static Readable: any;

            static Stream: any;

            static addAbortSignal(signal: any, stream: any): any;

            static captureRejectionSymbol: any;

            static captureRejections: boolean;

            static compose(streams: any): any;

            static defaultMaxListeners: number;

            static destroy(stream: any, err: any): any;

            static errorMonitor: any;

            static finished(stream: any, options: any, callback: any, ...args: any[]): any;

            static from(iterable: any, opts: any): any;

            static getEventListeners(emitterOrTarget: any, type: any): any;

            static init(opts: any): void;

            static isDisturbed(stream: any): any;

            static isErrored(stream: any): any;

            static isReadable(stream: any): any;

            static kMaxEventTargetListeners: any;

            static kMaxEventTargetListenersWarned: any;

            static listenerCount(emitter: any, type: any): any;

            static on(emitter: any, event: any, options: any): any;

            static once(emitter: any, name: any, options: any): any;

            static pipeline(streams: any): any;

            static setMaxListeners(n: any, eventTargets: any): void;

            static usingDomains: boolean;

            static wrap(src: any, options: any): any;

        }

        class Transform {
            constructor(options: any);

            static Stream: any;

            static Transform: any;

            static addAbortSignal(signal: any, stream: any): any;

            static captureRejectionSymbol: any;

            static captureRejections: boolean;

            static compose(streams: any): any;

            static defaultMaxListeners: number;

            static destroy(stream: any, err: any): any;

            static errorMonitor: any;

            static finished(stream: any, options: any, callback: any, ...args: any[]): any;

            static from(body: any): any;

            static getEventListeners(emitterOrTarget: any, type: any): any;

            static init(opts: any): void;

            static isDisturbed(stream: any): any;

            static isErrored(stream: any): any;

            static isReadable(stream: any): any;

            static kMaxEventTargetListeners: any;

            static kMaxEventTargetListenersWarned: any;

            static listenerCount(emitter: any, type: any): any;

            static on(emitter: any, event: any, options: any): any;

            static once(emitter: any, name: any, options: any): any;

            static pipeline(streams: any): any;

            static setMaxListeners(n: any, eventTargets: any): void;

            static usingDomains: boolean;

            static wrap(src: any, options: any): any;

        }

        class Writable {
            constructor(options: any);

            cork(): void;

            destroy(err: any, cb: any): any;

            end(chunk: any, encoding: any, cb: any): any;

            pipe(): void;

            setDefaultEncoding(encoding: any): any;

            uncork(): void;

            write(chunk: any, encoding: any, cb: any): any;

            static Stream: any;

            static Writable: any;

            static addAbortSignal(signal: any, stream: any): any;

            static captureRejectionSymbol: any;

            static captureRejections: boolean;

            static compose(streams: any): any;

            static defaultMaxListeners: number;

            static destroy(stream: any, err: any): any;

            static errorMonitor: any;

            static finished(stream: any, options: any, callback: any, ...args: any[]): any;

            static getEventListeners(emitterOrTarget: any, type: any): any;

            static init(opts: any): void;

            static isDisturbed(stream: any): any;

            static isErrored(stream: any): any;

            static isReadable(stream: any): any;

            static kMaxEventTargetListeners: any;

            static kMaxEventTargetListenersWarned: any;

            static listenerCount(emitter: any, type: any): any;

            static on(emitter: any, event: any, options: any): any;

            static once(emitter: any, name: any, options: any): any;

            static pipeline(streams: any): any;

            static setMaxListeners(n: any, eventTargets: any): void;

            static usingDomains: boolean;

        }

        namespace Duplex {
            class EventEmitter {
                constructor(opts: any);

                addListener(type: any, listener: any): any;

                emit(type: any, args: any): any;

                eventNames(): any;

                getMaxListeners(): any;

                listenerCount(type: any): any;

                listeners(type: any): any;

                off(type: any, listener: any): any;

                on(type: any, listener: any): any;

                once(type: any, listener: any): any;

                prependListener(type: any, listener: any): any;

                prependOnceListener(type: any, listener: any): any;

                rawListeners(type: any): any;

                removeAllListeners(type: any, ...args: any[]): any;

                removeListener(type: any, listener: any): any;

                setMaxListeners(n: any): any;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static defaultMaxListeners: any;

                static errorMonitor: any;

                static getEventListeners: any;

                static init: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static setMaxListeners: any;

                static usingDomains: any;

            }

            class EventEmitterAsyncResource {
                constructor(...args: any[]);

                emit(...args: any[]): void;

                emitDestroy(...args: any[]): void;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static defaultMaxListeners: any;

                static errorMonitor: any;

                static getEventListeners: any;

                static init: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static setMaxListeners: any;

                static usingDomains: any;

            }

            class PassThrough {
                constructor(options: any);

                static Duplex: any;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static PassThrough: any;

                static Readable: any;

                static ReadableState: any;

                static Stream: any;

                static Transform: any;

                static Writable: any;

                static addAbortSignal: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static compose: any;

                static defaultMaxListeners: any;

                static destroy: any;

                static errorMonitor: any;

                static finished: any;

                static from: any;

                static getEventListeners: any;

                static init: any;

                static isDisturbed: any;

                static isErrored: any;

                static isReadable: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static pipeline: any;

                static promises: any;

                static setMaxListeners: any;

                static usingDomains: any;

                static wrap: any;

            }

            class Readable {
                constructor(options: any);

                addListener(ev: any, fn: any): any;

                destroy(err: any, cb: any): any;

                filter(args: any): any;

                isPaused(): any;

                iterator(options: any): any;

                map(args: any): any;

                off(ev: any, fn: any): any;

                on(ev: any, fn: any): any;

                pause(): any;

                pipe(dest: any, pipeOpts: any): any;

                push(chunk: any, encoding: any): any;

                read(n: any): any;

                removeAllListeners(ev: any, ...args: any[]): any;

                removeListener(ev: any, fn: any): any;

                resume(): any;

                setEncoding(enc: any): any;

                unpipe(dest: any): any;

                unshift(chunk: any, encoding: any): any;

                wrap(stream: any): any;

                static Duplex: any;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static PassThrough: any;

                static Readable: any;

                static ReadableState: any;

                static Stream: any;

                static Transform: any;

                static Writable: any;

                static addAbortSignal: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static compose: any;

                static defaultMaxListeners: any;

                static destroy: any;

                static errorMonitor: any;

                static finished: any;

                static from: any;

                static getEventListeners: any;

                static init: any;

                static isDisturbed: any;

                static isErrored: any;

                static isReadable: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static pipeline: any;

                static promises: any;

                static setMaxListeners: any;

                static usingDomains: any;

                static wrap: any;

            }

            class ReadableState {
                constructor(options: any, stream: any, isDuplex: any);

            }

            class Transform {
                constructor(options: any);

                static Duplex: any;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static PassThrough: any;

                static Readable: any;

                static ReadableState: any;

                static Stream: any;

                static Transform: any;

                static Writable: any;

                static addAbortSignal: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static compose: any;

                static defaultMaxListeners: any;

                static destroy: any;

                static errorMonitor: any;

                static finished: any;

                static from: any;

                static getEventListeners: any;

                static init: any;

                static isDisturbed: any;

                static isErrored: any;

                static isReadable: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static pipeline: any;

                static promises: any;

                static setMaxListeners: any;

                static usingDomains: any;

                static wrap: any;

            }

            class Writable {
                constructor(options: any);

                cork(): void;

                destroy(err: any, cb: any): any;

                end(chunk: any, encoding: any, cb: any): any;

                pipe(): void;

                setDefaultEncoding(encoding: any): any;

                uncork(): void;

                write(chunk: any, encoding: any, cb: any): any;

                static Duplex: any;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static PassThrough: any;

                static Readable: any;

                static Stream: any;

                static Transform: any;

                static Writable: any;

                static WritableState: any;

                static addAbortSignal: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static compose: any;

                static defaultMaxListeners: any;

                static destroy: any;

                static errorMonitor: any;

                static finished: any;

                static getEventListeners: any;

                static init: any;

                static isDisturbed: any;

                static isErrored: any;

                static isReadable: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static pipeline: any;

                static promises: any;

                static setMaxListeners: any;

                static usingDomains: any;

            }

            namespace promises {
                // Too-deep object hierarchy from fs.FileReadStream.Stream.Duplex.promises
                const finished: any;

                // Too-deep object hierarchy from fs.FileReadStream.Stream.Duplex.promises
                const pipeline: any;

            }

        }

        namespace EventEmitter {
            class EventEmitterAsyncResource {
                constructor(...args: any[]);

                emit(...args: any[]): void;

                emitDestroy(...args: any[]): void;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static defaultMaxListeners: any;

                static errorMonitor: any;

                static getEventListeners: any;

                static init: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static setMaxListeners: any;

                static usingDomains: any;

            }

        }

        namespace EventEmitterAsyncResource {
            class EventEmitter {
                constructor(opts: any);

                addListener(type: any, listener: any): any;

                emit(type: any, args: any): any;

                eventNames(): any;

                getMaxListeners(): any;

                listenerCount(type: any): any;

                listeners(type: any): any;

                off(type: any, listener: any): any;

                on(type: any, listener: any): any;

                once(type: any, listener: any): any;

                prependListener(type: any, listener: any): any;

                prependOnceListener(type: any, listener: any): any;

                rawListeners(type: any): any;

                removeAllListeners(type: any, ...args: any[]): any;

                removeListener(type: any, listener: any): any;

                setMaxListeners(n: any): any;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static defaultMaxListeners: any;

                static errorMonitor: any;

                static getEventListeners: any;

                static init: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static setMaxListeners: any;

                static usingDomains: any;

            }

        }

        namespace PassThrough {
            class Duplex {
                constructor(options: any);

                cork(): void;

                end(chunk: any, encoding: any, cb: any): any;

                setDefaultEncoding(encoding: any): any;

                uncork(): void;

                write(chunk: any, encoding: any, cb: any): any;

                static Duplex: any;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static PassThrough: any;

                static Readable: any;

                static ReadableState: any;

                static Stream: any;

                static Transform: any;

                static Writable: any;

                static addAbortSignal: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static compose: any;

                static defaultMaxListeners: any;

                static destroy: any;

                static errorMonitor: any;

                static finished: any;

                static from: any;

                static getEventListeners: any;

                static init: any;

                static isDisturbed: any;

                static isErrored: any;

                static isReadable: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static pipeline: any;

                static promises: any;

                static setMaxListeners: any;

                static usingDomains: any;

                static wrap: any;

            }

            class EventEmitter {
                constructor(opts: any);

                addListener(type: any, listener: any): any;

                emit(type: any, args: any): any;

                eventNames(): any;

                getMaxListeners(): any;

                listenerCount(type: any): any;

                listeners(type: any): any;

                off(type: any, listener: any): any;

                on(type: any, listener: any): any;

                once(type: any, listener: any): any;

                prependListener(type: any, listener: any): any;

                prependOnceListener(type: any, listener: any): any;

                rawListeners(type: any): any;

                removeAllListeners(type: any, ...args: any[]): any;

                removeListener(type: any, listener: any): any;

                setMaxListeners(n: any): any;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static defaultMaxListeners: any;

                static errorMonitor: any;

                static getEventListeners: any;

                static init: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static setMaxListeners: any;

                static usingDomains: any;

            }

            class EventEmitterAsyncResource {
                constructor(...args: any[]);

                emit(...args: any[]): void;

                emitDestroy(...args: any[]): void;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static defaultMaxListeners: any;

                static errorMonitor: any;

                static getEventListeners: any;

                static init: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static setMaxListeners: any;

                static usingDomains: any;

            }

            class Readable {
                constructor(options: any);

                addListener(ev: any, fn: any): any;

                destroy(err: any, cb: any): any;

                filter(args: any): any;

                isPaused(): any;

                iterator(options: any): any;

                map(args: any): any;

                off(ev: any, fn: any): any;

                on(ev: any, fn: any): any;

                pause(): any;

                pipe(dest: any, pipeOpts: any): any;

                push(chunk: any, encoding: any): any;

                read(n: any): any;

                removeAllListeners(ev: any, ...args: any[]): any;

                removeListener(ev: any, fn: any): any;

                resume(): any;

                setEncoding(enc: any): any;

                unpipe(dest: any): any;

                unshift(chunk: any, encoding: any): any;

                wrap(stream: any): any;

                static Duplex: any;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static PassThrough: any;

                static Readable: any;

                static ReadableState: any;

                static Stream: any;

                static Transform: any;

                static Writable: any;

                static addAbortSignal: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static compose: any;

                static defaultMaxListeners: any;

                static destroy: any;

                static errorMonitor: any;

                static finished: any;

                static from: any;

                static getEventListeners: any;

                static init: any;

                static isDisturbed: any;

                static isErrored: any;

                static isReadable: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static pipeline: any;

                static promises: any;

                static setMaxListeners: any;

                static usingDomains: any;

                static wrap: any;

            }

            class ReadableState {
                constructor(options: any, stream: any, isDuplex: any);

            }

            class Transform {
                constructor(options: any);

                static Duplex: any;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static PassThrough: any;

                static Readable: any;

                static ReadableState: any;

                static Stream: any;

                static Transform: any;

                static Writable: any;

                static addAbortSignal: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static compose: any;

                static defaultMaxListeners: any;

                static destroy: any;

                static errorMonitor: any;

                static finished: any;

                static from: any;

                static getEventListeners: any;

                static init: any;

                static isDisturbed: any;

                static isErrored: any;

                static isReadable: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static pipeline: any;

                static promises: any;

                static setMaxListeners: any;

                static usingDomains: any;

                static wrap: any;

            }

            class Writable {
                constructor(options: any);

                cork(): void;

                destroy(err: any, cb: any): any;

                end(chunk: any, encoding: any, cb: any): any;

                pipe(): void;

                setDefaultEncoding(encoding: any): any;

                uncork(): void;

                write(chunk: any, encoding: any, cb: any): any;

                static Duplex: any;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static PassThrough: any;

                static Readable: any;

                static Stream: any;

                static Transform: any;

                static Writable: any;

                static WritableState: any;

                static addAbortSignal: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static compose: any;

                static defaultMaxListeners: any;

                static destroy: any;

                static errorMonitor: any;

                static finished: any;

                static getEventListeners: any;

                static init: any;

                static isDisturbed: any;

                static isErrored: any;

                static isReadable: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static pipeline: any;

                static promises: any;

                static setMaxListeners: any;

                static usingDomains: any;

            }

            namespace promises {
                // Too-deep object hierarchy from fs.FileReadStream.Stream.PassThrough.promises
                const finished: any;

                // Too-deep object hierarchy from fs.FileReadStream.Stream.PassThrough.promises
                const pipeline: any;

            }

        }

        namespace Readable {
            class Duplex {
                constructor(options: any);

                cork(): void;

                end(chunk: any, encoding: any, cb: any): any;

                setDefaultEncoding(encoding: any): any;

                uncork(): void;

                write(chunk: any, encoding: any, cb: any): any;

                static Duplex: any;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static PassThrough: any;

                static Readable: any;

                static ReadableState: any;

                static Stream: any;

                static Transform: any;

                static Writable: any;

                static addAbortSignal: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static compose: any;

                static defaultMaxListeners: any;

                static destroy: any;

                static errorMonitor: any;

                static finished: any;

                static from: any;

                static getEventListeners: any;

                static init: any;

                static isDisturbed: any;

                static isErrored: any;

                static isReadable: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static pipeline: any;

                static promises: any;

                static setMaxListeners: any;

                static usingDomains: any;

                static wrap: any;

            }

            class EventEmitter {
                constructor(opts: any);

                addListener(type: any, listener: any): any;

                emit(type: any, args: any): any;

                eventNames(): any;

                getMaxListeners(): any;

                listenerCount(type: any): any;

                listeners(type: any): any;

                off(type: any, listener: any): any;

                on(type: any, listener: any): any;

                once(type: any, listener: any): any;

                prependListener(type: any, listener: any): any;

                prependOnceListener(type: any, listener: any): any;

                rawListeners(type: any): any;

                removeAllListeners(type: any, ...args: any[]): any;

                removeListener(type: any, listener: any): any;

                setMaxListeners(n: any): any;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static defaultMaxListeners: any;

                static errorMonitor: any;

                static getEventListeners: any;

                static init: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static setMaxListeners: any;

                static usingDomains: any;

            }

            class EventEmitterAsyncResource {
                constructor(...args: any[]);

                emit(...args: any[]): void;

                emitDestroy(...args: any[]): void;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static defaultMaxListeners: any;

                static errorMonitor: any;

                static getEventListeners: any;

                static init: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static setMaxListeners: any;

                static usingDomains: any;

            }

            class PassThrough {
                constructor(options: any);

                static Duplex: any;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static PassThrough: any;

                static Readable: any;

                static ReadableState: any;

                static Stream: any;

                static Transform: any;

                static Writable: any;

                static addAbortSignal: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static compose: any;

                static defaultMaxListeners: any;

                static destroy: any;

                static errorMonitor: any;

                static finished: any;

                static from: any;

                static getEventListeners: any;

                static init: any;

                static isDisturbed: any;

                static isErrored: any;

                static isReadable: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static pipeline: any;

                static promises: any;

                static setMaxListeners: any;

                static usingDomains: any;

                static wrap: any;

            }

            class ReadableState {
                constructor(options: any, stream: any, isDuplex: any);

            }

            class Transform {
                constructor(options: any);

                static Duplex: any;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static PassThrough: any;

                static Readable: any;

                static ReadableState: any;

                static Stream: any;

                static Transform: any;

                static Writable: any;

                static addAbortSignal: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static compose: any;

                static defaultMaxListeners: any;

                static destroy: any;

                static errorMonitor: any;

                static finished: any;

                static from: any;

                static getEventListeners: any;

                static init: any;

                static isDisturbed: any;

                static isErrored: any;

                static isReadable: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static pipeline: any;

                static promises: any;

                static setMaxListeners: any;

                static usingDomains: any;

                static wrap: any;

            }

            class Writable {
                constructor(options: any);

                cork(): void;

                destroy(err: any, cb: any): any;

                end(chunk: any, encoding: any, cb: any): any;

                pipe(): void;

                setDefaultEncoding(encoding: any): any;

                uncork(): void;

                write(chunk: any, encoding: any, cb: any): any;

                static Duplex: any;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static PassThrough: any;

                static Readable: any;

                static Stream: any;

                static Transform: any;

                static Writable: any;

                static WritableState: any;

                static addAbortSignal: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static compose: any;

                static defaultMaxListeners: any;

                static destroy: any;

                static errorMonitor: any;

                static finished: any;

                static getEventListeners: any;

                static init: any;

                static isDisturbed: any;

                static isErrored: any;

                static isReadable: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static pipeline: any;

                static promises: any;

                static setMaxListeners: any;

                static usingDomains: any;

            }

            namespace promises {
                // Too-deep object hierarchy from fs.FileReadStream.Stream.Readable.promises
                const finished: any;

                // Too-deep object hierarchy from fs.FileReadStream.Stream.Readable.promises
                const pipeline: any;

            }

        }

        namespace Transform {
            class Duplex {
                constructor(options: any);

                cork(): void;

                end(chunk: any, encoding: any, cb: any): any;

                setDefaultEncoding(encoding: any): any;

                uncork(): void;

                write(chunk: any, encoding: any, cb: any): any;

                static Duplex: any;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static PassThrough: any;

                static Readable: any;

                static ReadableState: any;

                static Stream: any;

                static Transform: any;

                static Writable: any;

                static addAbortSignal: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static compose: any;

                static defaultMaxListeners: any;

                static destroy: any;

                static errorMonitor: any;

                static finished: any;

                static from: any;

                static getEventListeners: any;

                static init: any;

                static isDisturbed: any;

                static isErrored: any;

                static isReadable: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static pipeline: any;

                static promises: any;

                static setMaxListeners: any;

                static usingDomains: any;

                static wrap: any;

            }

            class EventEmitter {
                constructor(opts: any);

                addListener(type: any, listener: any): any;

                emit(type: any, args: any): any;

                eventNames(): any;

                getMaxListeners(): any;

                listenerCount(type: any): any;

                listeners(type: any): any;

                off(type: any, listener: any): any;

                on(type: any, listener: any): any;

                once(type: any, listener: any): any;

                prependListener(type: any, listener: any): any;

                prependOnceListener(type: any, listener: any): any;

                rawListeners(type: any): any;

                removeAllListeners(type: any, ...args: any[]): any;

                removeListener(type: any, listener: any): any;

                setMaxListeners(n: any): any;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static defaultMaxListeners: any;

                static errorMonitor: any;

                static getEventListeners: any;

                static init: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static setMaxListeners: any;

                static usingDomains: any;

            }

            class EventEmitterAsyncResource {
                constructor(...args: any[]);

                emit(...args: any[]): void;

                emitDestroy(...args: any[]): void;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static defaultMaxListeners: any;

                static errorMonitor: any;

                static getEventListeners: any;

                static init: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static setMaxListeners: any;

                static usingDomains: any;

            }

            class PassThrough {
                constructor(options: any);

                static Duplex: any;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static PassThrough: any;

                static Readable: any;

                static ReadableState: any;

                static Stream: any;

                static Transform: any;

                static Writable: any;

                static addAbortSignal: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static compose: any;

                static defaultMaxListeners: any;

                static destroy: any;

                static errorMonitor: any;

                static finished: any;

                static from: any;

                static getEventListeners: any;

                static init: any;

                static isDisturbed: any;

                static isErrored: any;

                static isReadable: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static pipeline: any;

                static promises: any;

                static setMaxListeners: any;

                static usingDomains: any;

                static wrap: any;

            }

            class Readable {
                constructor(options: any);

                addListener(ev: any, fn: any): any;

                destroy(err: any, cb: any): any;

                filter(args: any): any;

                isPaused(): any;

                iterator(options: any): any;

                map(args: any): any;

                off(ev: any, fn: any): any;

                on(ev: any, fn: any): any;

                pause(): any;

                pipe(dest: any, pipeOpts: any): any;

                push(chunk: any, encoding: any): any;

                read(n: any): any;

                removeAllListeners(ev: any, ...args: any[]): any;

                removeListener(ev: any, fn: any): any;

                resume(): any;

                setEncoding(enc: any): any;

                unpipe(dest: any): any;

                unshift(chunk: any, encoding: any): any;

                wrap(stream: any): any;

                static Duplex: any;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static PassThrough: any;

                static Readable: any;

                static ReadableState: any;

                static Stream: any;

                static Transform: any;

                static Writable: any;

                static addAbortSignal: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static compose: any;

                static defaultMaxListeners: any;

                static destroy: any;

                static errorMonitor: any;

                static finished: any;

                static from: any;

                static getEventListeners: any;

                static init: any;

                static isDisturbed: any;

                static isErrored: any;

                static isReadable: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static pipeline: any;

                static promises: any;

                static setMaxListeners: any;

                static usingDomains: any;

                static wrap: any;

            }

            class ReadableState {
                constructor(options: any, stream: any, isDuplex: any);

            }

            class Writable {
                constructor(options: any);

                cork(): void;

                destroy(err: any, cb: any): any;

                end(chunk: any, encoding: any, cb: any): any;

                pipe(): void;

                setDefaultEncoding(encoding: any): any;

                uncork(): void;

                write(chunk: any, encoding: any, cb: any): any;

                static Duplex: any;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static PassThrough: any;

                static Readable: any;

                static Stream: any;

                static Transform: any;

                static Writable: any;

                static WritableState: any;

                static addAbortSignal: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static compose: any;

                static defaultMaxListeners: any;

                static destroy: any;

                static errorMonitor: any;

                static finished: any;

                static getEventListeners: any;

                static init: any;

                static isDisturbed: any;

                static isErrored: any;

                static isReadable: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static pipeline: any;

                static promises: any;

                static setMaxListeners: any;

                static usingDomains: any;

            }

            namespace promises {
                // Too-deep object hierarchy from fs.FileReadStream.Stream.Transform.promises
                const finished: any;

                // Too-deep object hierarchy from fs.FileReadStream.Stream.Transform.promises
                const pipeline: any;

            }

        }

        namespace Writable {
            class Duplex {
                constructor(options: any);

                cork(): void;

                end(chunk: any, encoding: any, cb: any): any;

                setDefaultEncoding(encoding: any): any;

                uncork(): void;

                write(chunk: any, encoding: any, cb: any): any;

                static Duplex: any;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static PassThrough: any;

                static Readable: any;

                static ReadableState: any;

                static Stream: any;

                static Transform: any;

                static Writable: any;

                static addAbortSignal: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static compose: any;

                static defaultMaxListeners: any;

                static destroy: any;

                static errorMonitor: any;

                static finished: any;

                static from: any;

                static getEventListeners: any;

                static init: any;

                static isDisturbed: any;

                static isErrored: any;

                static isReadable: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static pipeline: any;

                static promises: any;

                static setMaxListeners: any;

                static usingDomains: any;

                static wrap: any;

            }

            class EventEmitter {
                constructor(opts: any);

                addListener(type: any, listener: any): any;

                emit(type: any, args: any): any;

                eventNames(): any;

                getMaxListeners(): any;

                listenerCount(type: any): any;

                listeners(type: any): any;

                off(type: any, listener: any): any;

                on(type: any, listener: any): any;

                once(type: any, listener: any): any;

                prependListener(type: any, listener: any): any;

                prependOnceListener(type: any, listener: any): any;

                rawListeners(type: any): any;

                removeAllListeners(type: any, ...args: any[]): any;

                removeListener(type: any, listener: any): any;

                setMaxListeners(n: any): any;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static defaultMaxListeners: any;

                static errorMonitor: any;

                static getEventListeners: any;

                static init: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static setMaxListeners: any;

                static usingDomains: any;

            }

            class EventEmitterAsyncResource {
                constructor(...args: any[]);

                emit(...args: any[]): void;

                emitDestroy(...args: any[]): void;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static defaultMaxListeners: any;

                static errorMonitor: any;

                static getEventListeners: any;

                static init: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static setMaxListeners: any;

                static usingDomains: any;

            }

            class PassThrough {
                constructor(options: any);

                static Duplex: any;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static PassThrough: any;

                static Readable: any;

                static ReadableState: any;

                static Stream: any;

                static Transform: any;

                static Writable: any;

                static addAbortSignal: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static compose: any;

                static defaultMaxListeners: any;

                static destroy: any;

                static errorMonitor: any;

                static finished: any;

                static from: any;

                static getEventListeners: any;

                static init: any;

                static isDisturbed: any;

                static isErrored: any;

                static isReadable: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static pipeline: any;

                static promises: any;

                static setMaxListeners: any;

                static usingDomains: any;

                static wrap: any;

            }

            class Readable {
                constructor(options: any);

                addListener(ev: any, fn: any): any;

                destroy(err: any, cb: any): any;

                filter(args: any): any;

                isPaused(): any;

                iterator(options: any): any;

                map(args: any): any;

                off(ev: any, fn: any): any;

                on(ev: any, fn: any): any;

                pause(): any;

                pipe(dest: any, pipeOpts: any): any;

                push(chunk: any, encoding: any): any;

                read(n: any): any;

                removeAllListeners(ev: any, ...args: any[]): any;

                removeListener(ev: any, fn: any): any;

                resume(): any;

                setEncoding(enc: any): any;

                unpipe(dest: any): any;

                unshift(chunk: any, encoding: any): any;

                wrap(stream: any): any;

                static Duplex: any;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static PassThrough: any;

                static Readable: any;

                static ReadableState: any;

                static Stream: any;

                static Transform: any;

                static Writable: any;

                static addAbortSignal: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static compose: any;

                static defaultMaxListeners: any;

                static destroy: any;

                static errorMonitor: any;

                static finished: any;

                static from: any;

                static getEventListeners: any;

                static init: any;

                static isDisturbed: any;

                static isErrored: any;

                static isReadable: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static pipeline: any;

                static promises: any;

                static setMaxListeners: any;

                static usingDomains: any;

                static wrap: any;

            }

            class Transform {
                constructor(options: any);

                static Duplex: any;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static PassThrough: any;

                static Readable: any;

                static ReadableState: any;

                static Stream: any;

                static Transform: any;

                static Writable: any;

                static addAbortSignal: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static compose: any;

                static defaultMaxListeners: any;

                static destroy: any;

                static errorMonitor: any;

                static finished: any;

                static from: any;

                static getEventListeners: any;

                static init: any;

                static isDisturbed: any;

                static isErrored: any;

                static isReadable: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static pipeline: any;

                static promises: any;

                static setMaxListeners: any;

                static usingDomains: any;

                static wrap: any;

            }

            class WritableState {
                constructor(options: any, stream: any, isDuplex: any);

                getBuffer(): any;

            }

            namespace promises {
                // Too-deep object hierarchy from fs.FileReadStream.Stream.Writable.promises
                const finished: any;

                // Too-deep object hierarchy from fs.FileReadStream.Stream.Writable.promises
                const pipeline: any;

            }

        }

        namespace promises {
            function finished(stream: any, opts: any): any;

            function pipeline(streams: any): any;

        }

    }

    namespace Transform {
        class Duplex {
            constructor(options: any);

            cork(): void;

            end(chunk: any, encoding: any, cb: any): any;

            setDefaultEncoding(encoding: any): any;

            uncork(): void;

            write(chunk: any, encoding: any, cb: any): any;

            static Duplex: any;

            static Transform: any;

            static addAbortSignal(signal: any, stream: any): any;

            static captureRejectionSymbol: any;

            static captureRejections: boolean;

            static compose(streams: any): any;

            static defaultMaxListeners: number;

            static destroy(stream: any, err: any): any;

            static errorMonitor: any;

            static finished(stream: any, options: any, callback: any, ...args: any[]): any;

            static from(body: any): any;

            static getEventListeners(emitterOrTarget: any, type: any): any;

            static init(opts: any): void;

            static isDisturbed(stream: any): any;

            static isErrored(stream: any): any;

            static isReadable(stream: any): any;

            static kMaxEventTargetListeners: any;

            static kMaxEventTargetListenersWarned: any;

            static listenerCount(emitter: any, type: any): any;

            static on(emitter: any, event: any, options: any): any;

            static once(emitter: any, name: any, options: any): any;

            static pipeline(streams: any): any;

            static setMaxListeners(n: any, eventTargets: any): void;

            static usingDomains: boolean;

            static wrap(src: any, options: any): any;

        }

        class EventEmitter {
            constructor(opts: any);

            addListener(type: any, listener: any): any;

            emit(type: any, args: any): any;

            eventNames(): any;

            getMaxListeners(): any;

            listenerCount(type: any): any;

            listeners(type: any): any;

            off(type: any, listener: any): any;

            on(type: any, listener: any): any;

            once(type: any, listener: any): any;

            prependListener(type: any, listener: any): any;

            prependOnceListener(type: any, listener: any): any;

            rawListeners(type: any): any;

            removeAllListeners(type: any, ...args: any[]): any;

            removeListener(type: any, listener: any): any;

            setMaxListeners(n: any): any;

            static EventEmitter: any;

            static captureRejectionSymbol: any;

            static captureRejections: boolean;

            static defaultMaxListeners: number;

            static errorMonitor: any;

            static getEventListeners(emitterOrTarget: any, type: any): any;

            static init(opts: any): void;

            static kMaxEventTargetListeners: any;

            static kMaxEventTargetListenersWarned: any;

            static listenerCount(emitter: any, type: any): any;

            static on(emitter: any, event: any, options: any): any;

            static once(emitter: any, name: any, options: any): any;

            static setMaxListeners(n: any, eventTargets: any): void;

            static usingDomains: boolean;

        }

        class EventEmitterAsyncResource {
            constructor(...args: any[]);

            emit(...args: any[]): void;

            emitDestroy(...args: any[]): void;

            static EventEmitterAsyncResource: any;

            static captureRejectionSymbol: any;

            static captureRejections: boolean;

            static defaultMaxListeners: number;

            static errorMonitor: any;

            static getEventListeners(emitterOrTarget: any, type: any): any;

            static init(opts: any): void;

            static kMaxEventTargetListeners: any;

            static kMaxEventTargetListenersWarned: any;

            static listenerCount(emitter: any, type: any): any;

            static on(emitter: any, event: any, options: any): any;

            static once(emitter: any, name: any, options: any): any;

            static setMaxListeners(n: any, eventTargets: any): void;

            static usingDomains: boolean;

        }

        class PassThrough {
            constructor(options: any);

            static PassThrough: any;

            static Transform: any;

            static addAbortSignal(signal: any, stream: any): any;

            static captureRejectionSymbol: any;

            static captureRejections: boolean;

            static compose(streams: any): any;

            static defaultMaxListeners: number;

            static destroy(stream: any, err: any): any;

            static errorMonitor: any;

            static finished(stream: any, options: any, callback: any, ...args: any[]): any;

            static from(body: any): any;

            static getEventListeners(emitterOrTarget: any, type: any): any;

            static init(opts: any): void;

            static isDisturbed(stream: any): any;

            static isErrored(stream: any): any;

            static isReadable(stream: any): any;

            static kMaxEventTargetListeners: any;

            static kMaxEventTargetListenersWarned: any;

            static listenerCount(emitter: any, type: any): any;

            static on(emitter: any, event: any, options: any): any;

            static once(emitter: any, name: any, options: any): any;

            static pipeline(streams: any): any;

            static setMaxListeners(n: any, eventTargets: any): void;

            static usingDomains: boolean;

            static wrap(src: any, options: any): any;

        }

        class Readable {
            constructor(options: any);

            addListener(ev: any, fn: any): any;

            destroy(err: any, cb: any): any;

            filter(args: any): any;

            isPaused(): any;

            iterator(options: any): any;

            map(args: any): any;

            off(ev: any, fn: any): any;

            on(ev: any, fn: any): any;

            pause(): any;

            pipe(dest: any, pipeOpts: any): any;

            push(chunk: any, encoding: any): any;

            read(n: any): any;

            removeAllListeners(ev: any, ...args: any[]): any;

            removeListener(ev: any, fn: any): any;

            resume(): any;

            setEncoding(enc: any): any;

            unpipe(dest: any): any;

            unshift(chunk: any, encoding: any): any;

            wrap(stream: any): any;

            static Readable: any;

            static Transform: any;

            static addAbortSignal(signal: any, stream: any): any;

            static captureRejectionSymbol: any;

            static captureRejections: boolean;

            static compose(streams: any): any;

            static defaultMaxListeners: number;

            static destroy(stream: any, err: any): any;

            static errorMonitor: any;

            static finished(stream: any, options: any, callback: any, ...args: any[]): any;

            static from(iterable: any, opts: any): any;

            static getEventListeners(emitterOrTarget: any, type: any): any;

            static init(opts: any): void;

            static isDisturbed(stream: any): any;

            static isErrored(stream: any): any;

            static isReadable(stream: any): any;

            static kMaxEventTargetListeners: any;

            static kMaxEventTargetListenersWarned: any;

            static listenerCount(emitter: any, type: any): any;

            static on(emitter: any, event: any, options: any): any;

            static once(emitter: any, name: any, options: any): any;

            static pipeline(streams: any): any;

            static setMaxListeners(n: any, eventTargets: any): void;

            static usingDomains: boolean;

            static wrap(src: any, options: any): any;

        }

        class ReadableState {
            constructor(options: any, stream: any, isDuplex: any);

        }

        class Stream {
            constructor(opts: any);

            pipe(dest: any, options: any): any;

            static Stream: any;

            static Transform: any;

            static addAbortSignal(signal: any, stream: any): any;

            static captureRejectionSymbol: any;

            static captureRejections: boolean;

            static compose(streams: any): any;

            static defaultMaxListeners: number;

            static destroy(stream: any, err: any): any;

            static errorMonitor: any;

            static finished(stream: any, options: any, callback: any, ...args: any[]): any;

            static getEventListeners(emitterOrTarget: any, type: any): any;

            static init(opts: any): void;

            static isDisturbed(stream: any): any;

            static isErrored(stream: any): any;

            static isReadable(stream: any): any;

            static kMaxEventTargetListeners: any;

            static kMaxEventTargetListenersWarned: any;

            static listenerCount(emitter: any, type: any): any;

            static on(emitter: any, event: any, options: any): any;

            static once(emitter: any, name: any, options: any): any;

            static pipeline(streams: any): any;

            static setMaxListeners(n: any, eventTargets: any): void;

            static usingDomains: boolean;

        }

        class Writable {
            constructor(options: any);

            cork(): void;

            destroy(err: any, cb: any): any;

            end(chunk: any, encoding: any, cb: any): any;

            pipe(): void;

            setDefaultEncoding(encoding: any): any;

            uncork(): void;

            write(chunk: any, encoding: any, cb: any): any;

            static Transform: any;

            static Writable: any;

            static addAbortSignal(signal: any, stream: any): any;

            static captureRejectionSymbol: any;

            static captureRejections: boolean;

            static compose(streams: any): any;

            static defaultMaxListeners: number;

            static destroy(stream: any, err: any): any;

            static errorMonitor: any;

            static finished(stream: any, options: any, callback: any, ...args: any[]): any;

            static getEventListeners(emitterOrTarget: any, type: any): any;

            static init(opts: any): void;

            static isDisturbed(stream: any): any;

            static isErrored(stream: any): any;

            static isReadable(stream: any): any;

            static kMaxEventTargetListeners: any;

            static kMaxEventTargetListenersWarned: any;

            static listenerCount(emitter: any, type: any): any;

            static on(emitter: any, event: any, options: any): any;

            static once(emitter: any, name: any, options: any): any;

            static pipeline(streams: any): any;

            static setMaxListeners(n: any, eventTargets: any): void;

            static usingDomains: boolean;

        }

        namespace Duplex {
            class EventEmitter {
                constructor(opts: any);

                addListener(type: any, listener: any): any;

                emit(type: any, args: any): any;

                eventNames(): any;

                getMaxListeners(): any;

                listenerCount(type: any): any;

                listeners(type: any): any;

                off(type: any, listener: any): any;

                on(type: any, listener: any): any;

                once(type: any, listener: any): any;

                prependListener(type: any, listener: any): any;

                prependOnceListener(type: any, listener: any): any;

                rawListeners(type: any): any;

                removeAllListeners(type: any, ...args: any[]): any;

                removeListener(type: any, listener: any): any;

                setMaxListeners(n: any): any;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static defaultMaxListeners: any;

                static errorMonitor: any;

                static getEventListeners: any;

                static init: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static setMaxListeners: any;

                static usingDomains: any;

            }

            class EventEmitterAsyncResource {
                constructor(...args: any[]);

                emit(...args: any[]): void;

                emitDestroy(...args: any[]): void;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static defaultMaxListeners: any;

                static errorMonitor: any;

                static getEventListeners: any;

                static init: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static setMaxListeners: any;

                static usingDomains: any;

            }

            class PassThrough {
                constructor(options: any);

                static Duplex: any;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static PassThrough: any;

                static Readable: any;

                static ReadableState: any;

                static Stream: any;

                static Transform: any;

                static Writable: any;

                static addAbortSignal: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static compose: any;

                static defaultMaxListeners: any;

                static destroy: any;

                static errorMonitor: any;

                static finished: any;

                static from: any;

                static getEventListeners: any;

                static init: any;

                static isDisturbed: any;

                static isErrored: any;

                static isReadable: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static pipeline: any;

                static promises: any;

                static setMaxListeners: any;

                static usingDomains: any;

                static wrap: any;

            }

            class Readable {
                constructor(options: any);

                addListener(ev: any, fn: any): any;

                destroy(err: any, cb: any): any;

                filter(args: any): any;

                isPaused(): any;

                iterator(options: any): any;

                map(args: any): any;

                off(ev: any, fn: any): any;

                on(ev: any, fn: any): any;

                pause(): any;

                pipe(dest: any, pipeOpts: any): any;

                push(chunk: any, encoding: any): any;

                read(n: any): any;

                removeAllListeners(ev: any, ...args: any[]): any;

                removeListener(ev: any, fn: any): any;

                resume(): any;

                setEncoding(enc: any): any;

                unpipe(dest: any): any;

                unshift(chunk: any, encoding: any): any;

                wrap(stream: any): any;

                static Duplex: any;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static PassThrough: any;

                static Readable: any;

                static ReadableState: any;

                static Stream: any;

                static Transform: any;

                static Writable: any;

                static addAbortSignal: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static compose: any;

                static defaultMaxListeners: any;

                static destroy: any;

                static errorMonitor: any;

                static finished: any;

                static from: any;

                static getEventListeners: any;

                static init: any;

                static isDisturbed: any;

                static isErrored: any;

                static isReadable: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static pipeline: any;

                static promises: any;

                static setMaxListeners: any;

                static usingDomains: any;

                static wrap: any;

            }

            class ReadableState {
                constructor(options: any, stream: any, isDuplex: any);

            }

            class Stream {
                constructor(opts: any);

                pipe(dest: any, options: any): any;

                static Duplex: any;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static PassThrough: any;

                static Readable: any;

                static Stream: any;

                static Transform: any;

                static Writable: any;

                static addAbortSignal: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static compose: any;

                static defaultMaxListeners: any;

                static destroy: any;

                static errorMonitor: any;

                static finished: any;

                static getEventListeners: any;

                static init: any;

                static isDisturbed: any;

                static isErrored: any;

                static isReadable: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static pipeline: any;

                static promises: any;

                static setMaxListeners: any;

                static usingDomains: any;

            }

            class Writable {
                constructor(options: any);

                cork(): void;

                destroy(err: any, cb: any): any;

                end(chunk: any, encoding: any, cb: any): any;

                pipe(): void;

                setDefaultEncoding(encoding: any): any;

                uncork(): void;

                write(chunk: any, encoding: any, cb: any): any;

                static Duplex: any;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static PassThrough: any;

                static Readable: any;

                static Stream: any;

                static Transform: any;

                static Writable: any;

                static WritableState: any;

                static addAbortSignal: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static compose: any;

                static defaultMaxListeners: any;

                static destroy: any;

                static errorMonitor: any;

                static finished: any;

                static getEventListeners: any;

                static init: any;

                static isDisturbed: any;

                static isErrored: any;

                static isReadable: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static pipeline: any;

                static promises: any;

                static setMaxListeners: any;

                static usingDomains: any;

            }

            namespace promises {
                // Too-deep object hierarchy from fs.FileReadStream.Transform.Duplex.promises
                const finished: any;

                // Too-deep object hierarchy from fs.FileReadStream.Transform.Duplex.promises
                const pipeline: any;

            }

        }

        namespace EventEmitter {
            class EventEmitterAsyncResource {
                constructor(...args: any[]);

                emit(...args: any[]): void;

                emitDestroy(...args: any[]): void;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static defaultMaxListeners: any;

                static errorMonitor: any;

                static getEventListeners: any;

                static init: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static setMaxListeners: any;

                static usingDomains: any;

            }

        }

        namespace EventEmitterAsyncResource {
            class EventEmitter {
                constructor(opts: any);

                addListener(type: any, listener: any): any;

                emit(type: any, args: any): any;

                eventNames(): any;

                getMaxListeners(): any;

                listenerCount(type: any): any;

                listeners(type: any): any;

                off(type: any, listener: any): any;

                on(type: any, listener: any): any;

                once(type: any, listener: any): any;

                prependListener(type: any, listener: any): any;

                prependOnceListener(type: any, listener: any): any;

                rawListeners(type: any): any;

                removeAllListeners(type: any, ...args: any[]): any;

                removeListener(type: any, listener: any): any;

                setMaxListeners(n: any): any;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static defaultMaxListeners: any;

                static errorMonitor: any;

                static getEventListeners: any;

                static init: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static setMaxListeners: any;

                static usingDomains: any;

            }

        }

        namespace PassThrough {
            class Duplex {
                constructor(options: any);

                cork(): void;

                end(chunk: any, encoding: any, cb: any): any;

                setDefaultEncoding(encoding: any): any;

                uncork(): void;

                write(chunk: any, encoding: any, cb: any): any;

                static Duplex: any;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static PassThrough: any;

                static Readable: any;

                static ReadableState: any;

                static Stream: any;

                static Transform: any;

                static Writable: any;

                static addAbortSignal: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static compose: any;

                static defaultMaxListeners: any;

                static destroy: any;

                static errorMonitor: any;

                static finished: any;

                static from: any;

                static getEventListeners: any;

                static init: any;

                static isDisturbed: any;

                static isErrored: any;

                static isReadable: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static pipeline: any;

                static promises: any;

                static setMaxListeners: any;

                static usingDomains: any;

                static wrap: any;

            }

            class EventEmitter {
                constructor(opts: any);

                addListener(type: any, listener: any): any;

                emit(type: any, args: any): any;

                eventNames(): any;

                getMaxListeners(): any;

                listenerCount(type: any): any;

                listeners(type: any): any;

                off(type: any, listener: any): any;

                on(type: any, listener: any): any;

                once(type: any, listener: any): any;

                prependListener(type: any, listener: any): any;

                prependOnceListener(type: any, listener: any): any;

                rawListeners(type: any): any;

                removeAllListeners(type: any, ...args: any[]): any;

                removeListener(type: any, listener: any): any;

                setMaxListeners(n: any): any;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static defaultMaxListeners: any;

                static errorMonitor: any;

                static getEventListeners: any;

                static init: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static setMaxListeners: any;

                static usingDomains: any;

            }

            class EventEmitterAsyncResource {
                constructor(...args: any[]);

                emit(...args: any[]): void;

                emitDestroy(...args: any[]): void;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static defaultMaxListeners: any;

                static errorMonitor: any;

                static getEventListeners: any;

                static init: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static setMaxListeners: any;

                static usingDomains: any;

            }

            class Readable {
                constructor(options: any);

                addListener(ev: any, fn: any): any;

                destroy(err: any, cb: any): any;

                filter(args: any): any;

                isPaused(): any;

                iterator(options: any): any;

                map(args: any): any;

                off(ev: any, fn: any): any;

                on(ev: any, fn: any): any;

                pause(): any;

                pipe(dest: any, pipeOpts: any): any;

                push(chunk: any, encoding: any): any;

                read(n: any): any;

                removeAllListeners(ev: any, ...args: any[]): any;

                removeListener(ev: any, fn: any): any;

                resume(): any;

                setEncoding(enc: any): any;

                unpipe(dest: any): any;

                unshift(chunk: any, encoding: any): any;

                wrap(stream: any): any;

                static Duplex: any;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static PassThrough: any;

                static Readable: any;

                static ReadableState: any;

                static Stream: any;

                static Transform: any;

                static Writable: any;

                static addAbortSignal: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static compose: any;

                static defaultMaxListeners: any;

                static destroy: any;

                static errorMonitor: any;

                static finished: any;

                static from: any;

                static getEventListeners: any;

                static init: any;

                static isDisturbed: any;

                static isErrored: any;

                static isReadable: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static pipeline: any;

                static promises: any;

                static setMaxListeners: any;

                static usingDomains: any;

                static wrap: any;

            }

            class ReadableState {
                constructor(options: any, stream: any, isDuplex: any);

            }

            class Stream {
                constructor(opts: any);

                pipe(dest: any, options: any): any;

                static Duplex: any;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static PassThrough: any;

                static Readable: any;

                static Stream: any;

                static Transform: any;

                static Writable: any;

                static addAbortSignal: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static compose: any;

                static defaultMaxListeners: any;

                static destroy: any;

                static errorMonitor: any;

                static finished: any;

                static getEventListeners: any;

                static init: any;

                static isDisturbed: any;

                static isErrored: any;

                static isReadable: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static pipeline: any;

                static promises: any;

                static setMaxListeners: any;

                static usingDomains: any;

            }

            class Writable {
                constructor(options: any);

                cork(): void;

                destroy(err: any, cb: any): any;

                end(chunk: any, encoding: any, cb: any): any;

                pipe(): void;

                setDefaultEncoding(encoding: any): any;

                uncork(): void;

                write(chunk: any, encoding: any, cb: any): any;

                static Duplex: any;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static PassThrough: any;

                static Readable: any;

                static Stream: any;

                static Transform: any;

                static Writable: any;

                static WritableState: any;

                static addAbortSignal: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static compose: any;

                static defaultMaxListeners: any;

                static destroy: any;

                static errorMonitor: any;

                static finished: any;

                static getEventListeners: any;

                static init: any;

                static isDisturbed: any;

                static isErrored: any;

                static isReadable: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static pipeline: any;

                static promises: any;

                static setMaxListeners: any;

                static usingDomains: any;

            }

            namespace promises {
                // Too-deep object hierarchy from fs.FileReadStream.Transform.PassThrough.promises
                const finished: any;

                // Too-deep object hierarchy from fs.FileReadStream.Transform.PassThrough.promises
                const pipeline: any;

            }

        }

        namespace Readable {
            class Duplex {
                constructor(options: any);

                cork(): void;

                end(chunk: any, encoding: any, cb: any): any;

                setDefaultEncoding(encoding: any): any;

                uncork(): void;

                write(chunk: any, encoding: any, cb: any): any;

                static Duplex: any;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static PassThrough: any;

                static Readable: any;

                static ReadableState: any;

                static Stream: any;

                static Transform: any;

                static Writable: any;

                static addAbortSignal: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static compose: any;

                static defaultMaxListeners: any;

                static destroy: any;

                static errorMonitor: any;

                static finished: any;

                static from: any;

                static getEventListeners: any;

                static init: any;

                static isDisturbed: any;

                static isErrored: any;

                static isReadable: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static pipeline: any;

                static promises: any;

                static setMaxListeners: any;

                static usingDomains: any;

                static wrap: any;

            }

            class EventEmitter {
                constructor(opts: any);

                addListener(type: any, listener: any): any;

                emit(type: any, args: any): any;

                eventNames(): any;

                getMaxListeners(): any;

                listenerCount(type: any): any;

                listeners(type: any): any;

                off(type: any, listener: any): any;

                on(type: any, listener: any): any;

                once(type: any, listener: any): any;

                prependListener(type: any, listener: any): any;

                prependOnceListener(type: any, listener: any): any;

                rawListeners(type: any): any;

                removeAllListeners(type: any, ...args: any[]): any;

                removeListener(type: any, listener: any): any;

                setMaxListeners(n: any): any;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static defaultMaxListeners: any;

                static errorMonitor: any;

                static getEventListeners: any;

                static init: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static setMaxListeners: any;

                static usingDomains: any;

            }

            class EventEmitterAsyncResource {
                constructor(...args: any[]);

                emit(...args: any[]): void;

                emitDestroy(...args: any[]): void;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static defaultMaxListeners: any;

                static errorMonitor: any;

                static getEventListeners: any;

                static init: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static setMaxListeners: any;

                static usingDomains: any;

            }

            class PassThrough {
                constructor(options: any);

                static Duplex: any;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static PassThrough: any;

                static Readable: any;

                static ReadableState: any;

                static Stream: any;

                static Transform: any;

                static Writable: any;

                static addAbortSignal: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static compose: any;

                static defaultMaxListeners: any;

                static destroy: any;

                static errorMonitor: any;

                static finished: any;

                static from: any;

                static getEventListeners: any;

                static init: any;

                static isDisturbed: any;

                static isErrored: any;

                static isReadable: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static pipeline: any;

                static promises: any;

                static setMaxListeners: any;

                static usingDomains: any;

                static wrap: any;

            }

            class ReadableState {
                constructor(options: any, stream: any, isDuplex: any);

            }

            class Stream {
                constructor(opts: any);

                pipe(dest: any, options: any): any;

                static Duplex: any;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static PassThrough: any;

                static Readable: any;

                static Stream: any;

                static Transform: any;

                static Writable: any;

                static addAbortSignal: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static compose: any;

                static defaultMaxListeners: any;

                static destroy: any;

                static errorMonitor: any;

                static finished: any;

                static getEventListeners: any;

                static init: any;

                static isDisturbed: any;

                static isErrored: any;

                static isReadable: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static pipeline: any;

                static promises: any;

                static setMaxListeners: any;

                static usingDomains: any;

            }

            class Writable {
                constructor(options: any);

                cork(): void;

                destroy(err: any, cb: any): any;

                end(chunk: any, encoding: any, cb: any): any;

                pipe(): void;

                setDefaultEncoding(encoding: any): any;

                uncork(): void;

                write(chunk: any, encoding: any, cb: any): any;

                static Duplex: any;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static PassThrough: any;

                static Readable: any;

                static Stream: any;

                static Transform: any;

                static Writable: any;

                static WritableState: any;

                static addAbortSignal: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static compose: any;

                static defaultMaxListeners: any;

                static destroy: any;

                static errorMonitor: any;

                static finished: any;

                static getEventListeners: any;

                static init: any;

                static isDisturbed: any;

                static isErrored: any;

                static isReadable: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static pipeline: any;

                static promises: any;

                static setMaxListeners: any;

                static usingDomains: any;

            }

            namespace promises {
                // Too-deep object hierarchy from fs.FileReadStream.Transform.Readable.promises
                const finished: any;

                // Too-deep object hierarchy from fs.FileReadStream.Transform.Readable.promises
                const pipeline: any;

            }

        }

        namespace Stream {
            class Duplex {
                constructor(options: any);

                cork(): void;

                end(chunk: any, encoding: any, cb: any): any;

                setDefaultEncoding(encoding: any): any;

                uncork(): void;

                write(chunk: any, encoding: any, cb: any): any;

                static Duplex: any;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static PassThrough: any;

                static Readable: any;

                static ReadableState: any;

                static Stream: any;

                static Transform: any;

                static Writable: any;

                static addAbortSignal: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static compose: any;

                static defaultMaxListeners: any;

                static destroy: any;

                static errorMonitor: any;

                static finished: any;

                static from: any;

                static getEventListeners: any;

                static init: any;

                static isDisturbed: any;

                static isErrored: any;

                static isReadable: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static pipeline: any;

                static promises: any;

                static setMaxListeners: any;

                static usingDomains: any;

                static wrap: any;

            }

            class EventEmitter {
                constructor(opts: any);

                addListener(type: any, listener: any): any;

                emit(type: any, args: any): any;

                eventNames(): any;

                getMaxListeners(): any;

                listenerCount(type: any): any;

                listeners(type: any): any;

                off(type: any, listener: any): any;

                on(type: any, listener: any): any;

                once(type: any, listener: any): any;

                prependListener(type: any, listener: any): any;

                prependOnceListener(type: any, listener: any): any;

                rawListeners(type: any): any;

                removeAllListeners(type: any, ...args: any[]): any;

                removeListener(type: any, listener: any): any;

                setMaxListeners(n: any): any;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static defaultMaxListeners: any;

                static errorMonitor: any;

                static getEventListeners: any;

                static init: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static setMaxListeners: any;

                static usingDomains: any;

            }

            class EventEmitterAsyncResource {
                constructor(...args: any[]);

                emit(...args: any[]): void;

                emitDestroy(...args: any[]): void;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static defaultMaxListeners: any;

                static errorMonitor: any;

                static getEventListeners: any;

                static init: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static setMaxListeners: any;

                static usingDomains: any;

            }

            class PassThrough {
                constructor(options: any);

                static Duplex: any;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static PassThrough: any;

                static Readable: any;

                static ReadableState: any;

                static Stream: any;

                static Transform: any;

                static Writable: any;

                static addAbortSignal: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static compose: any;

                static defaultMaxListeners: any;

                static destroy: any;

                static errorMonitor: any;

                static finished: any;

                static from: any;

                static getEventListeners: any;

                static init: any;

                static isDisturbed: any;

                static isErrored: any;

                static isReadable: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static pipeline: any;

                static promises: any;

                static setMaxListeners: any;

                static usingDomains: any;

                static wrap: any;

            }

            class Readable {
                constructor(options: any);

                addListener(ev: any, fn: any): any;

                destroy(err: any, cb: any): any;

                filter(args: any): any;

                isPaused(): any;

                iterator(options: any): any;

                map(args: any): any;

                off(ev: any, fn: any): any;

                on(ev: any, fn: any): any;

                pause(): any;

                pipe(dest: any, pipeOpts: any): any;

                push(chunk: any, encoding: any): any;

                read(n: any): any;

                removeAllListeners(ev: any, ...args: any[]): any;

                removeListener(ev: any, fn: any): any;

                resume(): any;

                setEncoding(enc: any): any;

                unpipe(dest: any): any;

                unshift(chunk: any, encoding: any): any;

                wrap(stream: any): any;

                static Duplex: any;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static PassThrough: any;

                static Readable: any;

                static ReadableState: any;

                static Stream: any;

                static Transform: any;

                static Writable: any;

                static addAbortSignal: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static compose: any;

                static defaultMaxListeners: any;

                static destroy: any;

                static errorMonitor: any;

                static finished: any;

                static from: any;

                static getEventListeners: any;

                static init: any;

                static isDisturbed: any;

                static isErrored: any;

                static isReadable: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static pipeline: any;

                static promises: any;

                static setMaxListeners: any;

                static usingDomains: any;

                static wrap: any;

            }

            class Writable {
                constructor(options: any);

                cork(): void;

                destroy(err: any, cb: any): any;

                end(chunk: any, encoding: any, cb: any): any;

                pipe(): void;

                setDefaultEncoding(encoding: any): any;

                uncork(): void;

                write(chunk: any, encoding: any, cb: any): any;

                static Duplex: any;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static PassThrough: any;

                static Readable: any;

                static Stream: any;

                static Transform: any;

                static Writable: any;

                static WritableState: any;

                static addAbortSignal: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static compose: any;

                static defaultMaxListeners: any;

                static destroy: any;

                static errorMonitor: any;

                static finished: any;

                static getEventListeners: any;

                static init: any;

                static isDisturbed: any;

                static isErrored: any;

                static isReadable: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static pipeline: any;

                static promises: any;

                static setMaxListeners: any;

                static usingDomains: any;

            }

            namespace promises {
                // Too-deep object hierarchy from fs.FileReadStream.Transform.Stream.promises
                const finished: any;

                // Too-deep object hierarchy from fs.FileReadStream.Transform.Stream.promises
                const pipeline: any;

            }

        }

        namespace Writable {
            class Duplex {
                constructor(options: any);

                cork(): void;

                end(chunk: any, encoding: any, cb: any): any;

                setDefaultEncoding(encoding: any): any;

                uncork(): void;

                write(chunk: any, encoding: any, cb: any): any;

                static Duplex: any;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static PassThrough: any;

                static Readable: any;

                static ReadableState: any;

                static Stream: any;

                static Transform: any;

                static Writable: any;

                static addAbortSignal: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static compose: any;

                static defaultMaxListeners: any;

                static destroy: any;

                static errorMonitor: any;

                static finished: any;

                static from: any;

                static getEventListeners: any;

                static init: any;

                static isDisturbed: any;

                static isErrored: any;

                static isReadable: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static pipeline: any;

                static promises: any;

                static setMaxListeners: any;

                static usingDomains: any;

                static wrap: any;

            }

            class EventEmitter {
                constructor(opts: any);

                addListener(type: any, listener: any): any;

                emit(type: any, args: any): any;

                eventNames(): any;

                getMaxListeners(): any;

                listenerCount(type: any): any;

                listeners(type: any): any;

                off(type: any, listener: any): any;

                on(type: any, listener: any): any;

                once(type: any, listener: any): any;

                prependListener(type: any, listener: any): any;

                prependOnceListener(type: any, listener: any): any;

                rawListeners(type: any): any;

                removeAllListeners(type: any, ...args: any[]): any;

                removeListener(type: any, listener: any): any;

                setMaxListeners(n: any): any;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static defaultMaxListeners: any;

                static errorMonitor: any;

                static getEventListeners: any;

                static init: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static setMaxListeners: any;

                static usingDomains: any;

            }

            class EventEmitterAsyncResource {
                constructor(...args: any[]);

                emit(...args: any[]): void;

                emitDestroy(...args: any[]): void;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static defaultMaxListeners: any;

                static errorMonitor: any;

                static getEventListeners: any;

                static init: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static setMaxListeners: any;

                static usingDomains: any;

            }

            class PassThrough {
                constructor(options: any);

                static Duplex: any;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static PassThrough: any;

                static Readable: any;

                static ReadableState: any;

                static Stream: any;

                static Transform: any;

                static Writable: any;

                static addAbortSignal: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static compose: any;

                static defaultMaxListeners: any;

                static destroy: any;

                static errorMonitor: any;

                static finished: any;

                static from: any;

                static getEventListeners: any;

                static init: any;

                static isDisturbed: any;

                static isErrored: any;

                static isReadable: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static pipeline: any;

                static promises: any;

                static setMaxListeners: any;

                static usingDomains: any;

                static wrap: any;

            }

            class Readable {
                constructor(options: any);

                addListener(ev: any, fn: any): any;

                destroy(err: any, cb: any): any;

                filter(args: any): any;

                isPaused(): any;

                iterator(options: any): any;

                map(args: any): any;

                off(ev: any, fn: any): any;

                on(ev: any, fn: any): any;

                pause(): any;

                pipe(dest: any, pipeOpts: any): any;

                push(chunk: any, encoding: any): any;

                read(n: any): any;

                removeAllListeners(ev: any, ...args: any[]): any;

                removeListener(ev: any, fn: any): any;

                resume(): any;

                setEncoding(enc: any): any;

                unpipe(dest: any): any;

                unshift(chunk: any, encoding: any): any;

                wrap(stream: any): any;

                static Duplex: any;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static PassThrough: any;

                static Readable: any;

                static ReadableState: any;

                static Stream: any;

                static Transform: any;

                static Writable: any;

                static addAbortSignal: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static compose: any;

                static defaultMaxListeners: any;

                static destroy: any;

                static errorMonitor: any;

                static finished: any;

                static from: any;

                static getEventListeners: any;

                static init: any;

                static isDisturbed: any;

                static isErrored: any;

                static isReadable: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static pipeline: any;

                static promises: any;

                static setMaxListeners: any;

                static usingDomains: any;

                static wrap: any;

            }

            class Stream {
                constructor(opts: any);

                pipe(dest: any, options: any): any;

                static Duplex: any;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static PassThrough: any;

                static Readable: any;

                static Stream: any;

                static Transform: any;

                static Writable: any;

                static addAbortSignal: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static compose: any;

                static defaultMaxListeners: any;

                static destroy: any;

                static errorMonitor: any;

                static finished: any;

                static getEventListeners: any;

                static init: any;

                static isDisturbed: any;

                static isErrored: any;

                static isReadable: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static pipeline: any;

                static promises: any;

                static setMaxListeners: any;

                static usingDomains: any;

            }

            class WritableState {
                constructor(options: any, stream: any, isDuplex: any);

                getBuffer(): any;

            }

            namespace promises {
                // Too-deep object hierarchy from fs.FileReadStream.Transform.Writable.promises
                const finished: any;

                // Too-deep object hierarchy from fs.FileReadStream.Transform.Writable.promises
                const pipeline: any;

            }

        }

        namespace promises {
            function finished(stream: any, opts: any): any;

            function pipeline(streams: any): any;

        }

    }

    namespace Writable {
        class Duplex {
            constructor(options: any);

            cork(): void;

            end(chunk: any, encoding: any, cb: any): any;

            setDefaultEncoding(encoding: any): any;

            uncork(): void;

            write(chunk: any, encoding: any, cb: any): any;

            static Duplex: any;

            static Writable: any;

            static addAbortSignal(signal: any, stream: any): any;

            static captureRejectionSymbol: any;

            static captureRejections: boolean;

            static compose(streams: any): any;

            static defaultMaxListeners: number;

            static destroy(stream: any, err: any): any;

            static errorMonitor: any;

            static finished(stream: any, options: any, callback: any, ...args: any[]): any;

            static from(body: any): any;

            static getEventListeners(emitterOrTarget: any, type: any): any;

            static init(opts: any): void;

            static isDisturbed(stream: any): any;

            static isErrored(stream: any): any;

            static isReadable(stream: any): any;

            static kMaxEventTargetListeners: any;

            static kMaxEventTargetListenersWarned: any;

            static listenerCount(emitter: any, type: any): any;

            static on(emitter: any, event: any, options: any): any;

            static once(emitter: any, name: any, options: any): any;

            static pipeline(streams: any): any;

            static setMaxListeners(n: any, eventTargets: any): void;

            static usingDomains: boolean;

            static wrap(src: any, options: any): any;

        }

        class EventEmitter {
            constructor(opts: any);

            addListener(type: any, listener: any): any;

            emit(type: any, args: any): any;

            eventNames(): any;

            getMaxListeners(): any;

            listenerCount(type: any): any;

            listeners(type: any): any;

            off(type: any, listener: any): any;

            on(type: any, listener: any): any;

            once(type: any, listener: any): any;

            prependListener(type: any, listener: any): any;

            prependOnceListener(type: any, listener: any): any;

            rawListeners(type: any): any;

            removeAllListeners(type: any, ...args: any[]): any;

            removeListener(type: any, listener: any): any;

            setMaxListeners(n: any): any;

            static EventEmitter: any;

            static captureRejectionSymbol: any;

            static captureRejections: boolean;

            static defaultMaxListeners: number;

            static errorMonitor: any;

            static getEventListeners(emitterOrTarget: any, type: any): any;

            static init(opts: any): void;

            static kMaxEventTargetListeners: any;

            static kMaxEventTargetListenersWarned: any;

            static listenerCount(emitter: any, type: any): any;

            static on(emitter: any, event: any, options: any): any;

            static once(emitter: any, name: any, options: any): any;

            static setMaxListeners(n: any, eventTargets: any): void;

            static usingDomains: boolean;

        }

        class EventEmitterAsyncResource {
            constructor(...args: any[]);

            emit(...args: any[]): void;

            emitDestroy(...args: any[]): void;

            static EventEmitterAsyncResource: any;

            static captureRejectionSymbol: any;

            static captureRejections: boolean;

            static defaultMaxListeners: number;

            static errorMonitor: any;

            static getEventListeners(emitterOrTarget: any, type: any): any;

            static init(opts: any): void;

            static kMaxEventTargetListeners: any;

            static kMaxEventTargetListenersWarned: any;

            static listenerCount(emitter: any, type: any): any;

            static on(emitter: any, event: any, options: any): any;

            static once(emitter: any, name: any, options: any): any;

            static setMaxListeners(n: any, eventTargets: any): void;

            static usingDomains: boolean;

        }

        class PassThrough {
            constructor(options: any);

            static PassThrough: any;

            static Writable: any;

            static addAbortSignal(signal: any, stream: any): any;

            static captureRejectionSymbol: any;

            static captureRejections: boolean;

            static compose(streams: any): any;

            static defaultMaxListeners: number;

            static destroy(stream: any, err: any): any;

            static errorMonitor: any;

            static finished(stream: any, options: any, callback: any, ...args: any[]): any;

            static from(body: any): any;

            static getEventListeners(emitterOrTarget: any, type: any): any;

            static init(opts: any): void;

            static isDisturbed(stream: any): any;

            static isErrored(stream: any): any;

            static isReadable(stream: any): any;

            static kMaxEventTargetListeners: any;

            static kMaxEventTargetListenersWarned: any;

            static listenerCount(emitter: any, type: any): any;

            static on(emitter: any, event: any, options: any): any;

            static once(emitter: any, name: any, options: any): any;

            static pipeline(streams: any): any;

            static setMaxListeners(n: any, eventTargets: any): void;

            static usingDomains: boolean;

            static wrap(src: any, options: any): any;

        }

        class Readable {
            constructor(options: any);

            addListener(ev: any, fn: any): any;

            destroy(err: any, cb: any): any;

            filter(args: any): any;

            isPaused(): any;

            iterator(options: any): any;

            map(args: any): any;

            off(ev: any, fn: any): any;

            on(ev: any, fn: any): any;

            pause(): any;

            pipe(dest: any, pipeOpts: any): any;

            push(chunk: any, encoding: any): any;

            read(n: any): any;

            removeAllListeners(ev: any, ...args: any[]): any;

            removeListener(ev: any, fn: any): any;

            resume(): any;

            setEncoding(enc: any): any;

            unpipe(dest: any): any;

            unshift(chunk: any, encoding: any): any;

            wrap(stream: any): any;

            static Readable: any;

            static Writable: any;

            static addAbortSignal(signal: any, stream: any): any;

            static captureRejectionSymbol: any;

            static captureRejections: boolean;

            static compose(streams: any): any;

            static defaultMaxListeners: number;

            static destroy(stream: any, err: any): any;

            static errorMonitor: any;

            static finished(stream: any, options: any, callback: any, ...args: any[]): any;

            static from(iterable: any, opts: any): any;

            static getEventListeners(emitterOrTarget: any, type: any): any;

            static init(opts: any): void;

            static isDisturbed(stream: any): any;

            static isErrored(stream: any): any;

            static isReadable(stream: any): any;

            static kMaxEventTargetListeners: any;

            static kMaxEventTargetListenersWarned: any;

            static listenerCount(emitter: any, type: any): any;

            static on(emitter: any, event: any, options: any): any;

            static once(emitter: any, name: any, options: any): any;

            static pipeline(streams: any): any;

            static setMaxListeners(n: any, eventTargets: any): void;

            static usingDomains: boolean;

            static wrap(src: any, options: any): any;

        }

        class Stream {
            constructor(opts: any);

            pipe(dest: any, options: any): any;

            static Stream: any;

            static Writable: any;

            static addAbortSignal(signal: any, stream: any): any;

            static captureRejectionSymbol: any;

            static captureRejections: boolean;

            static compose(streams: any): any;

            static defaultMaxListeners: number;

            static destroy(stream: any, err: any): any;

            static errorMonitor: any;

            static finished(stream: any, options: any, callback: any, ...args: any[]): any;

            static getEventListeners(emitterOrTarget: any, type: any): any;

            static init(opts: any): void;

            static isDisturbed(stream: any): any;

            static isErrored(stream: any): any;

            static isReadable(stream: any): any;

            static kMaxEventTargetListeners: any;

            static kMaxEventTargetListenersWarned: any;

            static listenerCount(emitter: any, type: any): any;

            static on(emitter: any, event: any, options: any): any;

            static once(emitter: any, name: any, options: any): any;

            static pipeline(streams: any): any;

            static setMaxListeners(n: any, eventTargets: any): void;

            static usingDomains: boolean;

        }

        class Transform {
            constructor(options: any);

            static Transform: any;

            static Writable: any;

            static addAbortSignal(signal: any, stream: any): any;

            static captureRejectionSymbol: any;

            static captureRejections: boolean;

            static compose(streams: any): any;

            static defaultMaxListeners: number;

            static destroy(stream: any, err: any): any;

            static errorMonitor: any;

            static finished(stream: any, options: any, callback: any, ...args: any[]): any;

            static from(body: any): any;

            static getEventListeners(emitterOrTarget: any, type: any): any;

            static init(opts: any): void;

            static isDisturbed(stream: any): any;

            static isErrored(stream: any): any;

            static isReadable(stream: any): any;

            static kMaxEventTargetListeners: any;

            static kMaxEventTargetListenersWarned: any;

            static listenerCount(emitter: any, type: any): any;

            static on(emitter: any, event: any, options: any): any;

            static once(emitter: any, name: any, options: any): any;

            static pipeline(streams: any): any;

            static setMaxListeners(n: any, eventTargets: any): void;

            static usingDomains: boolean;

            static wrap(src: any, options: any): any;

        }

        class WritableState {
            constructor(options: any, stream: any, isDuplex: any);

            getBuffer(): any;

        }

        namespace Duplex {
            class EventEmitter {
                constructor(opts: any);

                addListener(type: any, listener: any): any;

                emit(type: any, args: any): any;

                eventNames(): any;

                getMaxListeners(): any;

                listenerCount(type: any): any;

                listeners(type: any): any;

                off(type: any, listener: any): any;

                on(type: any, listener: any): any;

                once(type: any, listener: any): any;

                prependListener(type: any, listener: any): any;

                prependOnceListener(type: any, listener: any): any;

                rawListeners(type: any): any;

                removeAllListeners(type: any, ...args: any[]): any;

                removeListener(type: any, listener: any): any;

                setMaxListeners(n: any): any;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static defaultMaxListeners: any;

                static errorMonitor: any;

                static getEventListeners: any;

                static init: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static setMaxListeners: any;

                static usingDomains: any;

            }

            class EventEmitterAsyncResource {
                constructor(...args: any[]);

                emit(...args: any[]): void;

                emitDestroy(...args: any[]): void;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static defaultMaxListeners: any;

                static errorMonitor: any;

                static getEventListeners: any;

                static init: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static setMaxListeners: any;

                static usingDomains: any;

            }

            class PassThrough {
                constructor(options: any);

                static Duplex: any;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static PassThrough: any;

                static Readable: any;

                static ReadableState: any;

                static Stream: any;

                static Transform: any;

                static Writable: any;

                static addAbortSignal: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static compose: any;

                static defaultMaxListeners: any;

                static destroy: any;

                static errorMonitor: any;

                static finished: any;

                static from: any;

                static getEventListeners: any;

                static init: any;

                static isDisturbed: any;

                static isErrored: any;

                static isReadable: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static pipeline: any;

                static promises: any;

                static setMaxListeners: any;

                static usingDomains: any;

                static wrap: any;

            }

            class Readable {
                constructor(options: any);

                addListener(ev: any, fn: any): any;

                destroy(err: any, cb: any): any;

                filter(args: any): any;

                isPaused(): any;

                iterator(options: any): any;

                map(args: any): any;

                off(ev: any, fn: any): any;

                on(ev: any, fn: any): any;

                pause(): any;

                pipe(dest: any, pipeOpts: any): any;

                push(chunk: any, encoding: any): any;

                read(n: any): any;

                removeAllListeners(ev: any, ...args: any[]): any;

                removeListener(ev: any, fn: any): any;

                resume(): any;

                setEncoding(enc: any): any;

                unpipe(dest: any): any;

                unshift(chunk: any, encoding: any): any;

                wrap(stream: any): any;

                static Duplex: any;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static PassThrough: any;

                static Readable: any;

                static ReadableState: any;

                static Stream: any;

                static Transform: any;

                static Writable: any;

                static addAbortSignal: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static compose: any;

                static defaultMaxListeners: any;

                static destroy: any;

                static errorMonitor: any;

                static finished: any;

                static from: any;

                static getEventListeners: any;

                static init: any;

                static isDisturbed: any;

                static isErrored: any;

                static isReadable: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static pipeline: any;

                static promises: any;

                static setMaxListeners: any;

                static usingDomains: any;

                static wrap: any;

            }

            class ReadableState {
                constructor(options: any, stream: any, isDuplex: any);

            }

            class Stream {
                constructor(opts: any);

                pipe(dest: any, options: any): any;

                static Duplex: any;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static PassThrough: any;

                static Readable: any;

                static Stream: any;

                static Transform: any;

                static Writable: any;

                static addAbortSignal: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static compose: any;

                static defaultMaxListeners: any;

                static destroy: any;

                static errorMonitor: any;

                static finished: any;

                static getEventListeners: any;

                static init: any;

                static isDisturbed: any;

                static isErrored: any;

                static isReadable: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static pipeline: any;

                static promises: any;

                static setMaxListeners: any;

                static usingDomains: any;

            }

            class Transform {
                constructor(options: any);

                static Duplex: any;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static PassThrough: any;

                static Readable: any;

                static ReadableState: any;

                static Stream: any;

                static Transform: any;

                static Writable: any;

                static addAbortSignal: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static compose: any;

                static defaultMaxListeners: any;

                static destroy: any;

                static errorMonitor: any;

                static finished: any;

                static from: any;

                static getEventListeners: any;

                static init: any;

                static isDisturbed: any;

                static isErrored: any;

                static isReadable: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static pipeline: any;

                static promises: any;

                static setMaxListeners: any;

                static usingDomains: any;

                static wrap: any;

            }

            namespace promises {
                // Too-deep object hierarchy from fs.FileReadStream.Writable.Duplex.promises
                const finished: any;

                // Too-deep object hierarchy from fs.FileReadStream.Writable.Duplex.promises
                const pipeline: any;

            }

        }

        namespace EventEmitter {
            class EventEmitterAsyncResource {
                constructor(...args: any[]);

                emit(...args: any[]): void;

                emitDestroy(...args: any[]): void;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static defaultMaxListeners: any;

                static errorMonitor: any;

                static getEventListeners: any;

                static init: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static setMaxListeners: any;

                static usingDomains: any;

            }

        }

        namespace EventEmitterAsyncResource {
            class EventEmitter {
                constructor(opts: any);

                addListener(type: any, listener: any): any;

                emit(type: any, args: any): any;

                eventNames(): any;

                getMaxListeners(): any;

                listenerCount(type: any): any;

                listeners(type: any): any;

                off(type: any, listener: any): any;

                on(type: any, listener: any): any;

                once(type: any, listener: any): any;

                prependListener(type: any, listener: any): any;

                prependOnceListener(type: any, listener: any): any;

                rawListeners(type: any): any;

                removeAllListeners(type: any, ...args: any[]): any;

                removeListener(type: any, listener: any): any;

                setMaxListeners(n: any): any;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static defaultMaxListeners: any;

                static errorMonitor: any;

                static getEventListeners: any;

                static init: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static setMaxListeners: any;

                static usingDomains: any;

            }

        }

        namespace PassThrough {
            class Duplex {
                constructor(options: any);

                cork(): void;

                end(chunk: any, encoding: any, cb: any): any;

                setDefaultEncoding(encoding: any): any;

                uncork(): void;

                write(chunk: any, encoding: any, cb: any): any;

                static Duplex: any;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static PassThrough: any;

                static Readable: any;

                static ReadableState: any;

                static Stream: any;

                static Transform: any;

                static Writable: any;

                static addAbortSignal: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static compose: any;

                static defaultMaxListeners: any;

                static destroy: any;

                static errorMonitor: any;

                static finished: any;

                static from: any;

                static getEventListeners: any;

                static init: any;

                static isDisturbed: any;

                static isErrored: any;

                static isReadable: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static pipeline: any;

                static promises: any;

                static setMaxListeners: any;

                static usingDomains: any;

                static wrap: any;

            }

            class EventEmitter {
                constructor(opts: any);

                addListener(type: any, listener: any): any;

                emit(type: any, args: any): any;

                eventNames(): any;

                getMaxListeners(): any;

                listenerCount(type: any): any;

                listeners(type: any): any;

                off(type: any, listener: any): any;

                on(type: any, listener: any): any;

                once(type: any, listener: any): any;

                prependListener(type: any, listener: any): any;

                prependOnceListener(type: any, listener: any): any;

                rawListeners(type: any): any;

                removeAllListeners(type: any, ...args: any[]): any;

                removeListener(type: any, listener: any): any;

                setMaxListeners(n: any): any;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static defaultMaxListeners: any;

                static errorMonitor: any;

                static getEventListeners: any;

                static init: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static setMaxListeners: any;

                static usingDomains: any;

            }

            class EventEmitterAsyncResource {
                constructor(...args: any[]);

                emit(...args: any[]): void;

                emitDestroy(...args: any[]): void;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static defaultMaxListeners: any;

                static errorMonitor: any;

                static getEventListeners: any;

                static init: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static setMaxListeners: any;

                static usingDomains: any;

            }

            class Readable {
                constructor(options: any);

                addListener(ev: any, fn: any): any;

                destroy(err: any, cb: any): any;

                filter(args: any): any;

                isPaused(): any;

                iterator(options: any): any;

                map(args: any): any;

                off(ev: any, fn: any): any;

                on(ev: any, fn: any): any;

                pause(): any;

                pipe(dest: any, pipeOpts: any): any;

                push(chunk: any, encoding: any): any;

                read(n: any): any;

                removeAllListeners(ev: any, ...args: any[]): any;

                removeListener(ev: any, fn: any): any;

                resume(): any;

                setEncoding(enc: any): any;

                unpipe(dest: any): any;

                unshift(chunk: any, encoding: any): any;

                wrap(stream: any): any;

                static Duplex: any;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static PassThrough: any;

                static Readable: any;

                static ReadableState: any;

                static Stream: any;

                static Transform: any;

                static Writable: any;

                static addAbortSignal: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static compose: any;

                static defaultMaxListeners: any;

                static destroy: any;

                static errorMonitor: any;

                static finished: any;

                static from: any;

                static getEventListeners: any;

                static init: any;

                static isDisturbed: any;

                static isErrored: any;

                static isReadable: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static pipeline: any;

                static promises: any;

                static setMaxListeners: any;

                static usingDomains: any;

                static wrap: any;

            }

            class ReadableState {
                constructor(options: any, stream: any, isDuplex: any);

            }

            class Stream {
                constructor(opts: any);

                pipe(dest: any, options: any): any;

                static Duplex: any;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static PassThrough: any;

                static Readable: any;

                static Stream: any;

                static Transform: any;

                static Writable: any;

                static addAbortSignal: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static compose: any;

                static defaultMaxListeners: any;

                static destroy: any;

                static errorMonitor: any;

                static finished: any;

                static getEventListeners: any;

                static init: any;

                static isDisturbed: any;

                static isErrored: any;

                static isReadable: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static pipeline: any;

                static promises: any;

                static setMaxListeners: any;

                static usingDomains: any;

            }

            class Transform {
                constructor(options: any);

                static Duplex: any;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static PassThrough: any;

                static Readable: any;

                static ReadableState: any;

                static Stream: any;

                static Transform: any;

                static Writable: any;

                static addAbortSignal: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static compose: any;

                static defaultMaxListeners: any;

                static destroy: any;

                static errorMonitor: any;

                static finished: any;

                static from: any;

                static getEventListeners: any;

                static init: any;

                static isDisturbed: any;

                static isErrored: any;

                static isReadable: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static pipeline: any;

                static promises: any;

                static setMaxListeners: any;

                static usingDomains: any;

                static wrap: any;

            }

            namespace promises {
                // Too-deep object hierarchy from fs.FileReadStream.Writable.PassThrough.promises
                const finished: any;

                // Too-deep object hierarchy from fs.FileReadStream.Writable.PassThrough.promises
                const pipeline: any;

            }

        }

        namespace Readable {
            class Duplex {
                constructor(options: any);

                cork(): void;

                end(chunk: any, encoding: any, cb: any): any;

                setDefaultEncoding(encoding: any): any;

                uncork(): void;

                write(chunk: any, encoding: any, cb: any): any;

                static Duplex: any;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static PassThrough: any;

                static Readable: any;

                static ReadableState: any;

                static Stream: any;

                static Transform: any;

                static Writable: any;

                static addAbortSignal: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static compose: any;

                static defaultMaxListeners: any;

                static destroy: any;

                static errorMonitor: any;

                static finished: any;

                static from: any;

                static getEventListeners: any;

                static init: any;

                static isDisturbed: any;

                static isErrored: any;

                static isReadable: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static pipeline: any;

                static promises: any;

                static setMaxListeners: any;

                static usingDomains: any;

                static wrap: any;

            }

            class EventEmitter {
                constructor(opts: any);

                addListener(type: any, listener: any): any;

                emit(type: any, args: any): any;

                eventNames(): any;

                getMaxListeners(): any;

                listenerCount(type: any): any;

                listeners(type: any): any;

                off(type: any, listener: any): any;

                on(type: any, listener: any): any;

                once(type: any, listener: any): any;

                prependListener(type: any, listener: any): any;

                prependOnceListener(type: any, listener: any): any;

                rawListeners(type: any): any;

                removeAllListeners(type: any, ...args: any[]): any;

                removeListener(type: any, listener: any): any;

                setMaxListeners(n: any): any;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static defaultMaxListeners: any;

                static errorMonitor: any;

                static getEventListeners: any;

                static init: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static setMaxListeners: any;

                static usingDomains: any;

            }

            class EventEmitterAsyncResource {
                constructor(...args: any[]);

                emit(...args: any[]): void;

                emitDestroy(...args: any[]): void;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static defaultMaxListeners: any;

                static errorMonitor: any;

                static getEventListeners: any;

                static init: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static setMaxListeners: any;

                static usingDomains: any;

            }

            class PassThrough {
                constructor(options: any);

                static Duplex: any;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static PassThrough: any;

                static Readable: any;

                static ReadableState: any;

                static Stream: any;

                static Transform: any;

                static Writable: any;

                static addAbortSignal: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static compose: any;

                static defaultMaxListeners: any;

                static destroy: any;

                static errorMonitor: any;

                static finished: any;

                static from: any;

                static getEventListeners: any;

                static init: any;

                static isDisturbed: any;

                static isErrored: any;

                static isReadable: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static pipeline: any;

                static promises: any;

                static setMaxListeners: any;

                static usingDomains: any;

                static wrap: any;

            }

            class ReadableState {
                constructor(options: any, stream: any, isDuplex: any);

            }

            class Stream {
                constructor(opts: any);

                pipe(dest: any, options: any): any;

                static Duplex: any;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static PassThrough: any;

                static Readable: any;

                static Stream: any;

                static Transform: any;

                static Writable: any;

                static addAbortSignal: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static compose: any;

                static defaultMaxListeners: any;

                static destroy: any;

                static errorMonitor: any;

                static finished: any;

                static getEventListeners: any;

                static init: any;

                static isDisturbed: any;

                static isErrored: any;

                static isReadable: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static pipeline: any;

                static promises: any;

                static setMaxListeners: any;

                static usingDomains: any;

            }

            class Transform {
                constructor(options: any);

                static Duplex: any;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static PassThrough: any;

                static Readable: any;

                static ReadableState: any;

                static Stream: any;

                static Transform: any;

                static Writable: any;

                static addAbortSignal: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static compose: any;

                static defaultMaxListeners: any;

                static destroy: any;

                static errorMonitor: any;

                static finished: any;

                static from: any;

                static getEventListeners: any;

                static init: any;

                static isDisturbed: any;

                static isErrored: any;

                static isReadable: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static pipeline: any;

                static promises: any;

                static setMaxListeners: any;

                static usingDomains: any;

                static wrap: any;

            }

            namespace promises {
                // Too-deep object hierarchy from fs.FileReadStream.Writable.Readable.promises
                const finished: any;

                // Too-deep object hierarchy from fs.FileReadStream.Writable.Readable.promises
                const pipeline: any;

            }

        }

        namespace Stream {
            class Duplex {
                constructor(options: any);

                cork(): void;

                end(chunk: any, encoding: any, cb: any): any;

                setDefaultEncoding(encoding: any): any;

                uncork(): void;

                write(chunk: any, encoding: any, cb: any): any;

                static Duplex: any;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static PassThrough: any;

                static Readable: any;

                static ReadableState: any;

                static Stream: any;

                static Transform: any;

                static Writable: any;

                static addAbortSignal: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static compose: any;

                static defaultMaxListeners: any;

                static destroy: any;

                static errorMonitor: any;

                static finished: any;

                static from: any;

                static getEventListeners: any;

                static init: any;

                static isDisturbed: any;

                static isErrored: any;

                static isReadable: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static pipeline: any;

                static promises: any;

                static setMaxListeners: any;

                static usingDomains: any;

                static wrap: any;

            }

            class EventEmitter {
                constructor(opts: any);

                addListener(type: any, listener: any): any;

                emit(type: any, args: any): any;

                eventNames(): any;

                getMaxListeners(): any;

                listenerCount(type: any): any;

                listeners(type: any): any;

                off(type: any, listener: any): any;

                on(type: any, listener: any): any;

                once(type: any, listener: any): any;

                prependListener(type: any, listener: any): any;

                prependOnceListener(type: any, listener: any): any;

                rawListeners(type: any): any;

                removeAllListeners(type: any, ...args: any[]): any;

                removeListener(type: any, listener: any): any;

                setMaxListeners(n: any): any;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static defaultMaxListeners: any;

                static errorMonitor: any;

                static getEventListeners: any;

                static init: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static setMaxListeners: any;

                static usingDomains: any;

            }

            class EventEmitterAsyncResource {
                constructor(...args: any[]);

                emit(...args: any[]): void;

                emitDestroy(...args: any[]): void;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static defaultMaxListeners: any;

                static errorMonitor: any;

                static getEventListeners: any;

                static init: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static setMaxListeners: any;

                static usingDomains: any;

            }

            class PassThrough {
                constructor(options: any);

                static Duplex: any;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static PassThrough: any;

                static Readable: any;

                static ReadableState: any;

                static Stream: any;

                static Transform: any;

                static Writable: any;

                static addAbortSignal: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static compose: any;

                static defaultMaxListeners: any;

                static destroy: any;

                static errorMonitor: any;

                static finished: any;

                static from: any;

                static getEventListeners: any;

                static init: any;

                static isDisturbed: any;

                static isErrored: any;

                static isReadable: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static pipeline: any;

                static promises: any;

                static setMaxListeners: any;

                static usingDomains: any;

                static wrap: any;

            }

            class Readable {
                constructor(options: any);

                addListener(ev: any, fn: any): any;

                destroy(err: any, cb: any): any;

                filter(args: any): any;

                isPaused(): any;

                iterator(options: any): any;

                map(args: any): any;

                off(ev: any, fn: any): any;

                on(ev: any, fn: any): any;

                pause(): any;

                pipe(dest: any, pipeOpts: any): any;

                push(chunk: any, encoding: any): any;

                read(n: any): any;

                removeAllListeners(ev: any, ...args: any[]): any;

                removeListener(ev: any, fn: any): any;

                resume(): any;

                setEncoding(enc: any): any;

                unpipe(dest: any): any;

                unshift(chunk: any, encoding: any): any;

                wrap(stream: any): any;

                static Duplex: any;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static PassThrough: any;

                static Readable: any;

                static ReadableState: any;

                static Stream: any;

                static Transform: any;

                static Writable: any;

                static addAbortSignal: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static compose: any;

                static defaultMaxListeners: any;

                static destroy: any;

                static errorMonitor: any;

                static finished: any;

                static from: any;

                static getEventListeners: any;

                static init: any;

                static isDisturbed: any;

                static isErrored: any;

                static isReadable: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static pipeline: any;

                static promises: any;

                static setMaxListeners: any;

                static usingDomains: any;

                static wrap: any;

            }

            class Transform {
                constructor(options: any);

                static Duplex: any;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static PassThrough: any;

                static Readable: any;

                static ReadableState: any;

                static Stream: any;

                static Transform: any;

                static Writable: any;

                static addAbortSignal: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static compose: any;

                static defaultMaxListeners: any;

                static destroy: any;

                static errorMonitor: any;

                static finished: any;

                static from: any;

                static getEventListeners: any;

                static init: any;

                static isDisturbed: any;

                static isErrored: any;

                static isReadable: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static pipeline: any;

                static promises: any;

                static setMaxListeners: any;

                static usingDomains: any;

                static wrap: any;

            }

            namespace promises {
                // Too-deep object hierarchy from fs.FileReadStream.Writable.Stream.promises
                const finished: any;

                // Too-deep object hierarchy from fs.FileReadStream.Writable.Stream.promises
                const pipeline: any;

            }

        }

        namespace Transform {
            class Duplex {
                constructor(options: any);

                cork(): void;

                end(chunk: any, encoding: any, cb: any): any;

                setDefaultEncoding(encoding: any): any;

                uncork(): void;

                write(chunk: any, encoding: any, cb: any): any;

                static Duplex: any;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static PassThrough: any;

                static Readable: any;

                static ReadableState: any;

                static Stream: any;

                static Transform: any;

                static Writable: any;

                static addAbortSignal: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static compose: any;

                static defaultMaxListeners: any;

                static destroy: any;

                static errorMonitor: any;

                static finished: any;

                static from: any;

                static getEventListeners: any;

                static init: any;

                static isDisturbed: any;

                static isErrored: any;

                static isReadable: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static pipeline: any;

                static promises: any;

                static setMaxListeners: any;

                static usingDomains: any;

                static wrap: any;

            }

            class EventEmitter {
                constructor(opts: any);

                addListener(type: any, listener: any): any;

                emit(type: any, args: any): any;

                eventNames(): any;

                getMaxListeners(): any;

                listenerCount(type: any): any;

                listeners(type: any): any;

                off(type: any, listener: any): any;

                on(type: any, listener: any): any;

                once(type: any, listener: any): any;

                prependListener(type: any, listener: any): any;

                prependOnceListener(type: any, listener: any): any;

                rawListeners(type: any): any;

                removeAllListeners(type: any, ...args: any[]): any;

                removeListener(type: any, listener: any): any;

                setMaxListeners(n: any): any;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static defaultMaxListeners: any;

                static errorMonitor: any;

                static getEventListeners: any;

                static init: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static setMaxListeners: any;

                static usingDomains: any;

            }

            class EventEmitterAsyncResource {
                constructor(...args: any[]);

                emit(...args: any[]): void;

                emitDestroy(...args: any[]): void;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static defaultMaxListeners: any;

                static errorMonitor: any;

                static getEventListeners: any;

                static init: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static setMaxListeners: any;

                static usingDomains: any;

            }

            class PassThrough {
                constructor(options: any);

                static Duplex: any;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static PassThrough: any;

                static Readable: any;

                static ReadableState: any;

                static Stream: any;

                static Transform: any;

                static Writable: any;

                static addAbortSignal: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static compose: any;

                static defaultMaxListeners: any;

                static destroy: any;

                static errorMonitor: any;

                static finished: any;

                static from: any;

                static getEventListeners: any;

                static init: any;

                static isDisturbed: any;

                static isErrored: any;

                static isReadable: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static pipeline: any;

                static promises: any;

                static setMaxListeners: any;

                static usingDomains: any;

                static wrap: any;

            }

            class Readable {
                constructor(options: any);

                addListener(ev: any, fn: any): any;

                destroy(err: any, cb: any): any;

                filter(args: any): any;

                isPaused(): any;

                iterator(options: any): any;

                map(args: any): any;

                off(ev: any, fn: any): any;

                on(ev: any, fn: any): any;

                pause(): any;

                pipe(dest: any, pipeOpts: any): any;

                push(chunk: any, encoding: any): any;

                read(n: any): any;

                removeAllListeners(ev: any, ...args: any[]): any;

                removeListener(ev: any, fn: any): any;

                resume(): any;

                setEncoding(enc: any): any;

                unpipe(dest: any): any;

                unshift(chunk: any, encoding: any): any;

                wrap(stream: any): any;

                static Duplex: any;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static PassThrough: any;

                static Readable: any;

                static ReadableState: any;

                static Stream: any;

                static Transform: any;

                static Writable: any;

                static addAbortSignal: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static compose: any;

                static defaultMaxListeners: any;

                static destroy: any;

                static errorMonitor: any;

                static finished: any;

                static from: any;

                static getEventListeners: any;

                static init: any;

                static isDisturbed: any;

                static isErrored: any;

                static isReadable: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static pipeline: any;

                static promises: any;

                static setMaxListeners: any;

                static usingDomains: any;

                static wrap: any;

            }

            class ReadableState {
                constructor(options: any, stream: any, isDuplex: any);

            }

            class Stream {
                constructor(opts: any);

                pipe(dest: any, options: any): any;

                static Duplex: any;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static PassThrough: any;

                static Readable: any;

                static Stream: any;

                static Transform: any;

                static Writable: any;

                static addAbortSignal: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static compose: any;

                static defaultMaxListeners: any;

                static destroy: any;

                static errorMonitor: any;

                static finished: any;

                static getEventListeners: any;

                static init: any;

                static isDisturbed: any;

                static isErrored: any;

                static isReadable: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static pipeline: any;

                static promises: any;

                static setMaxListeners: any;

                static usingDomains: any;

            }

            namespace promises {
                // Too-deep object hierarchy from fs.FileReadStream.Writable.Transform.promises
                const finished: any;

                // Too-deep object hierarchy from fs.FileReadStream.Writable.Transform.promises
                const pipeline: any;

            }

        }

        namespace promises {
            function finished(stream: any, opts: any): any;

            function pipeline(streams: any): any;

        }

    }

    namespace promises {
        function finished(stream: any, opts: any): any;

        function pipeline(streams: any): any;

    }

}

export namespace FileWriteStream {
    class Duplex {
        constructor(options: any);

        cork(): void;

        end(chunk: any, encoding: any, cb: any): any;

        setDefaultEncoding(encoding: any): any;

        uncork(): void;

        write(chunk: any, encoding: any, cb: any): any;

        static Duplex: any;

        static addAbortSignal(signal: any, stream: any): any;

        static captureRejectionSymbol: any;

        static captureRejections: boolean;

        static compose(streams: any): any;

        static defaultMaxListeners: number;

        static destroy(stream: any, err: any): any;

        static errorMonitor: any;

        static finished(stream: any, options: any, callback: any, ...args: any[]): any;

        static from(body: any): any;

        static getEventListeners(emitterOrTarget: any, type: any): any;

        static init(opts: any): void;

        static isDisturbed(stream: any): any;

        static isErrored(stream: any): any;

        static isReadable(stream: any): any;

        static kMaxEventTargetListeners: any;

        static kMaxEventTargetListenersWarned: any;

        static listenerCount(emitter: any, type: any): any;

        static on(emitter: any, event: any, options: any): any;

        static once(emitter: any, name: any, options: any): any;

        static pipeline(streams: any): any;

        static setMaxListeners(n: any, eventTargets: any): void;

        static usingDomains: boolean;

        static wrap(src: any, options: any): any;

    }

    class EventEmitter {
        constructor(opts: any);

        addListener(type: any, listener: any): any;

        emit(type: any, args: any): any;

        eventNames(): any;

        getMaxListeners(): any;

        listenerCount(type: any): any;

        listeners(type: any): any;

        off(type: any, listener: any): any;

        on(type: any, listener: any): any;

        once(type: any, listener: any): any;

        prependListener(type: any, listener: any): any;

        prependOnceListener(type: any, listener: any): any;

        rawListeners(type: any): any;

        removeAllListeners(type: any, ...args: any[]): any;

        removeListener(type: any, listener: any): any;

        setMaxListeners(n: any): any;

        static EventEmitter: any;

        static captureRejectionSymbol: any;

        static captureRejections: boolean;

        static defaultMaxListeners: number;

        static errorMonitor: any;

        static getEventListeners(emitterOrTarget: any, type: any): any;

        static init(opts: any): void;

        static kMaxEventTargetListeners: any;

        static kMaxEventTargetListenersWarned: any;

        static listenerCount(emitter: any, type: any): any;

        static on(emitter: any, event: any, options: any): any;

        static once(emitter: any, name: any, options: any): any;

        static setMaxListeners(n: any, eventTargets: any): void;

        static usingDomains: boolean;

    }

    class EventEmitterAsyncResource {
        constructor(...args: any[]);

        emit(...args: any[]): void;

        emitDestroy(...args: any[]): void;

        static EventEmitterAsyncResource: any;

        static captureRejectionSymbol: any;

        static captureRejections: boolean;

        static defaultMaxListeners: number;

        static errorMonitor: any;

        static getEventListeners(emitterOrTarget: any, type: any): any;

        static init(opts: any): void;

        static kMaxEventTargetListeners: any;

        static kMaxEventTargetListenersWarned: any;

        static listenerCount(emitter: any, type: any): any;

        static on(emitter: any, event: any, options: any): any;

        static once(emitter: any, name: any, options: any): any;

        static setMaxListeners(n: any, eventTargets: any): void;

        static usingDomains: boolean;

    }

    class PassThrough {
        constructor(options: any);

        static PassThrough: any;

        static addAbortSignal(signal: any, stream: any): any;

        static captureRejectionSymbol: any;

        static captureRejections: boolean;

        static compose(streams: any): any;

        static defaultMaxListeners: number;

        static destroy(stream: any, err: any): any;

        static errorMonitor: any;

        static finished(stream: any, options: any, callback: any, ...args: any[]): any;

        static from(body: any): any;

        static getEventListeners(emitterOrTarget: any, type: any): any;

        static init(opts: any): void;

        static isDisturbed(stream: any): any;

        static isErrored(stream: any): any;

        static isReadable(stream: any): any;

        static kMaxEventTargetListeners: any;

        static kMaxEventTargetListenersWarned: any;

        static listenerCount(emitter: any, type: any): any;

        static on(emitter: any, event: any, options: any): any;

        static once(emitter: any, name: any, options: any): any;

        static pipeline(streams: any): any;

        static setMaxListeners(n: any, eventTargets: any): void;

        static usingDomains: boolean;

        static wrap(src: any, options: any): any;

    }

    class Readable {
        constructor(options: any);

        addListener(ev: any, fn: any): any;

        destroy(err: any, cb: any): any;

        filter(args: any): any;

        isPaused(): any;

        iterator(options: any): any;

        map(args: any): any;

        off(ev: any, fn: any): any;

        on(ev: any, fn: any): any;

        pause(): any;

        pipe(dest: any, pipeOpts: any): any;

        push(chunk: any, encoding: any): any;

        read(n: any): any;

        removeAllListeners(ev: any, ...args: any[]): any;

        removeListener(ev: any, fn: any): any;

        resume(): any;

        setEncoding(enc: any): any;

        unpipe(dest: any): any;

        unshift(chunk: any, encoding: any): any;

        wrap(stream: any): any;

        static Readable: any;

        static addAbortSignal(signal: any, stream: any): any;

        static captureRejectionSymbol: any;

        static captureRejections: boolean;

        static compose(streams: any): any;

        static defaultMaxListeners: number;

        static destroy(stream: any, err: any): any;

        static errorMonitor: any;

        static finished(stream: any, options: any, callback: any, ...args: any[]): any;

        static from(iterable: any, opts: any): any;

        static getEventListeners(emitterOrTarget: any, type: any): any;

        static init(opts: any): void;

        static isDisturbed(stream: any): any;

        static isErrored(stream: any): any;

        static isReadable(stream: any): any;

        static kMaxEventTargetListeners: any;

        static kMaxEventTargetListenersWarned: any;

        static listenerCount(emitter: any, type: any): any;

        static on(emitter: any, event: any, options: any): any;

        static once(emitter: any, name: any, options: any): any;

        static pipeline(streams: any): any;

        static setMaxListeners(n: any, eventTargets: any): void;

        static usingDomains: boolean;

        static wrap(src: any, options: any): any;

    }

    class Stream {
        constructor(opts: any);

        pipe(dest: any, options: any): any;

        static Stream: any;

        static addAbortSignal(signal: any, stream: any): any;

        static captureRejectionSymbol: any;

        static captureRejections: boolean;

        static compose(streams: any): any;

        static defaultMaxListeners: number;

        static destroy(stream: any, err: any): any;

        static errorMonitor: any;

        static finished(stream: any, options: any, callback: any, ...args: any[]): any;

        static getEventListeners(emitterOrTarget: any, type: any): any;

        static init(opts: any): void;

        static isDisturbed(stream: any): any;

        static isErrored(stream: any): any;

        static isReadable(stream: any): any;

        static kMaxEventTargetListeners: any;

        static kMaxEventTargetListenersWarned: any;

        static listenerCount(emitter: any, type: any): any;

        static on(emitter: any, event: any, options: any): any;

        static once(emitter: any, name: any, options: any): any;

        static pipeline(streams: any): any;

        static setMaxListeners(n: any, eventTargets: any): void;

        static usingDomains: boolean;

    }

    class Transform {
        constructor(options: any);

        static Transform: any;

        static addAbortSignal(signal: any, stream: any): any;

        static captureRejectionSymbol: any;

        static captureRejections: boolean;

        static compose(streams: any): any;

        static defaultMaxListeners: number;

        static destroy(stream: any, err: any): any;

        static errorMonitor: any;

        static finished(stream: any, options: any, callback: any, ...args: any[]): any;

        static from(body: any): any;

        static getEventListeners(emitterOrTarget: any, type: any): any;

        static init(opts: any): void;

        static isDisturbed(stream: any): any;

        static isErrored(stream: any): any;

        static isReadable(stream: any): any;

        static kMaxEventTargetListeners: any;

        static kMaxEventTargetListenersWarned: any;

        static listenerCount(emitter: any, type: any): any;

        static on(emitter: any, event: any, options: any): any;

        static once(emitter: any, name: any, options: any): any;

        static pipeline(streams: any): any;

        static setMaxListeners(n: any, eventTargets: any): void;

        static usingDomains: boolean;

        static wrap(src: any, options: any): any;

    }

    class Writable {
        constructor(options: any);

        cork(): void;

        destroy(err: any, cb: any): any;

        end(chunk: any, encoding: any, cb: any): any;

        pipe(): void;

        setDefaultEncoding(encoding: any): any;

        uncork(): void;

        write(chunk: any, encoding: any, cb: any): any;

        static Writable: any;

        static addAbortSignal(signal: any, stream: any): any;

        static captureRejectionSymbol: any;

        static captureRejections: boolean;

        static compose(streams: any): any;

        static defaultMaxListeners: number;

        static destroy(stream: any, err: any): any;

        static errorMonitor: any;

        static finished(stream: any, options: any, callback: any, ...args: any[]): any;

        static getEventListeners(emitterOrTarget: any, type: any): any;

        static init(opts: any): void;

        static isDisturbed(stream: any): any;

        static isErrored(stream: any): any;

        static isReadable(stream: any): any;

        static kMaxEventTargetListeners: any;

        static kMaxEventTargetListenersWarned: any;

        static listenerCount(emitter: any, type: any): any;

        static on(emitter: any, event: any, options: any): any;

        static once(emitter: any, name: any, options: any): any;

        static pipeline(streams: any): any;

        static setMaxListeners(n: any, eventTargets: any): void;

        static usingDomains: boolean;

    }

    class WritableState {
        constructor(options: any, stream: any, isDuplex: any);

        getBuffer(): any;

    }

    namespace Duplex {
        class EventEmitter {
            constructor(opts: any);

            addListener(type: any, listener: any): any;

            emit(type: any, args: any): any;

            eventNames(): any;

            getMaxListeners(): any;

            listenerCount(type: any): any;

            listeners(type: any): any;

            off(type: any, listener: any): any;

            on(type: any, listener: any): any;

            once(type: any, listener: any): any;

            prependListener(type: any, listener: any): any;

            prependOnceListener(type: any, listener: any): any;

            rawListeners(type: any): any;

            removeAllListeners(type: any, ...args: any[]): any;

            removeListener(type: any, listener: any): any;

            setMaxListeners(n: any): any;

            static EventEmitter: any;

            static captureRejectionSymbol: any;

            static captureRejections: boolean;

            static defaultMaxListeners: number;

            static errorMonitor: any;

            static getEventListeners(emitterOrTarget: any, type: any): any;

            static init(opts: any): void;

            static kMaxEventTargetListeners: any;

            static kMaxEventTargetListenersWarned: any;

            static listenerCount(emitter: any, type: any): any;

            static on(emitter: any, event: any, options: any): any;

            static once(emitter: any, name: any, options: any): any;

            static setMaxListeners(n: any, eventTargets: any): void;

            static usingDomains: boolean;

        }

        class EventEmitterAsyncResource {
            constructor(...args: any[]);

            emit(...args: any[]): void;

            emitDestroy(...args: any[]): void;

            static EventEmitterAsyncResource: any;

            static captureRejectionSymbol: any;

            static captureRejections: boolean;

            static defaultMaxListeners: number;

            static errorMonitor: any;

            static getEventListeners(emitterOrTarget: any, type: any): any;

            static init(opts: any): void;

            static kMaxEventTargetListeners: any;

            static kMaxEventTargetListenersWarned: any;

            static listenerCount(emitter: any, type: any): any;

            static on(emitter: any, event: any, options: any): any;

            static once(emitter: any, name: any, options: any): any;

            static setMaxListeners(n: any, eventTargets: any): void;

            static usingDomains: boolean;

        }

        class PassThrough {
            constructor(options: any);

            static Duplex: any;

            static PassThrough: any;

            static addAbortSignal(signal: any, stream: any): any;

            static captureRejectionSymbol: any;

            static captureRejections: boolean;

            static compose(streams: any): any;

            static defaultMaxListeners: number;

            static destroy(stream: any, err: any): any;

            static errorMonitor: any;

            static finished(stream: any, options: any, callback: any, ...args: any[]): any;

            static from(body: any): any;

            static getEventListeners(emitterOrTarget: any, type: any): any;

            static init(opts: any): void;

            static isDisturbed(stream: any): any;

            static isErrored(stream: any): any;

            static isReadable(stream: any): any;

            static kMaxEventTargetListeners: any;

            static kMaxEventTargetListenersWarned: any;

            static listenerCount(emitter: any, type: any): any;

            static on(emitter: any, event: any, options: any): any;

            static once(emitter: any, name: any, options: any): any;

            static pipeline(streams: any): any;

            static setMaxListeners(n: any, eventTargets: any): void;

            static usingDomains: boolean;

            static wrap(src: any, options: any): any;

        }

        class Readable {
            constructor(options: any);

            addListener(ev: any, fn: any): any;

            destroy(err: any, cb: any): any;

            filter(args: any): any;

            isPaused(): any;

            iterator(options: any): any;

            map(args: any): any;

            off(ev: any, fn: any): any;

            on(ev: any, fn: any): any;

            pause(): any;

            pipe(dest: any, pipeOpts: any): any;

            push(chunk: any, encoding: any): any;

            read(n: any): any;

            removeAllListeners(ev: any, ...args: any[]): any;

            removeListener(ev: any, fn: any): any;

            resume(): any;

            setEncoding(enc: any): any;

            unpipe(dest: any): any;

            unshift(chunk: any, encoding: any): any;

            wrap(stream: any): any;

            static Duplex: any;

            static Readable: any;

            static addAbortSignal(signal: any, stream: any): any;

            static captureRejectionSymbol: any;

            static captureRejections: boolean;

            static compose(streams: any): any;

            static defaultMaxListeners: number;

            static destroy(stream: any, err: any): any;

            static errorMonitor: any;

            static finished(stream: any, options: any, callback: any, ...args: any[]): any;

            static from(iterable: any, opts: any): any;

            static getEventListeners(emitterOrTarget: any, type: any): any;

            static init(opts: any): void;

            static isDisturbed(stream: any): any;

            static isErrored(stream: any): any;

            static isReadable(stream: any): any;

            static kMaxEventTargetListeners: any;

            static kMaxEventTargetListenersWarned: any;

            static listenerCount(emitter: any, type: any): any;

            static on(emitter: any, event: any, options: any): any;

            static once(emitter: any, name: any, options: any): any;

            static pipeline(streams: any): any;

            static setMaxListeners(n: any, eventTargets: any): void;

            static usingDomains: boolean;

            static wrap(src: any, options: any): any;

        }

        class ReadableState {
            constructor(options: any, stream: any, isDuplex: any);

        }

        class Stream {
            constructor(opts: any);

            pipe(dest: any, options: any): any;

            static Duplex: any;

            static Stream: any;

            static addAbortSignal(signal: any, stream: any): any;

            static captureRejectionSymbol: any;

            static captureRejections: boolean;

            static compose(streams: any): any;

            static defaultMaxListeners: number;

            static destroy(stream: any, err: any): any;

            static errorMonitor: any;

            static finished(stream: any, options: any, callback: any, ...args: any[]): any;

            static getEventListeners(emitterOrTarget: any, type: any): any;

            static init(opts: any): void;

            static isDisturbed(stream: any): any;

            static isErrored(stream: any): any;

            static isReadable(stream: any): any;

            static kMaxEventTargetListeners: any;

            static kMaxEventTargetListenersWarned: any;

            static listenerCount(emitter: any, type: any): any;

            static on(emitter: any, event: any, options: any): any;

            static once(emitter: any, name: any, options: any): any;

            static pipeline(streams: any): any;

            static setMaxListeners(n: any, eventTargets: any): void;

            static usingDomains: boolean;

        }

        class Transform {
            constructor(options: any);

            static Duplex: any;

            static Transform: any;

            static addAbortSignal(signal: any, stream: any): any;

            static captureRejectionSymbol: any;

            static captureRejections: boolean;

            static compose(streams: any): any;

            static defaultMaxListeners: number;

            static destroy(stream: any, err: any): any;

            static errorMonitor: any;

            static finished(stream: any, options: any, callback: any, ...args: any[]): any;

            static from(body: any): any;

            static getEventListeners(emitterOrTarget: any, type: any): any;

            static init(opts: any): void;

            static isDisturbed(stream: any): any;

            static isErrored(stream: any): any;

            static isReadable(stream: any): any;

            static kMaxEventTargetListeners: any;

            static kMaxEventTargetListenersWarned: any;

            static listenerCount(emitter: any, type: any): any;

            static on(emitter: any, event: any, options: any): any;

            static once(emitter: any, name: any, options: any): any;

            static pipeline(streams: any): any;

            static setMaxListeners(n: any, eventTargets: any): void;

            static usingDomains: boolean;

            static wrap(src: any, options: any): any;

        }

        class Writable {
            constructor(options: any);

            cork(): void;

            destroy(err: any, cb: any): any;

            end(chunk: any, encoding: any, cb: any): any;

            pipe(): void;

            setDefaultEncoding(encoding: any): any;

            uncork(): void;

            write(chunk: any, encoding: any, cb: any): any;

            static Duplex: any;

            static Writable: any;

            static addAbortSignal(signal: any, stream: any): any;

            static captureRejectionSymbol: any;

            static captureRejections: boolean;

            static compose(streams: any): any;

            static defaultMaxListeners: number;

            static destroy(stream: any, err: any): any;

            static errorMonitor: any;

            static finished(stream: any, options: any, callback: any, ...args: any[]): any;

            static getEventListeners(emitterOrTarget: any, type: any): any;

            static init(opts: any): void;

            static isDisturbed(stream: any): any;

            static isErrored(stream: any): any;

            static isReadable(stream: any): any;

            static kMaxEventTargetListeners: any;

            static kMaxEventTargetListenersWarned: any;

            static listenerCount(emitter: any, type: any): any;

            static on(emitter: any, event: any, options: any): any;

            static once(emitter: any, name: any, options: any): any;

            static pipeline(streams: any): any;

            static setMaxListeners(n: any, eventTargets: any): void;

            static usingDomains: boolean;

        }

        namespace EventEmitter {
            class EventEmitterAsyncResource {
                constructor(...args: any[]);

                emit(...args: any[]): void;

                emitDestroy(...args: any[]): void;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static defaultMaxListeners: any;

                static errorMonitor: any;

                static getEventListeners: any;

                static init: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static setMaxListeners: any;

                static usingDomains: any;

            }

        }

        namespace EventEmitterAsyncResource {
            class EventEmitter {
                constructor(opts: any);

                addListener(type: any, listener: any): any;

                emit(type: any, args: any): any;

                eventNames(): any;

                getMaxListeners(): any;

                listenerCount(type: any): any;

                listeners(type: any): any;

                off(type: any, listener: any): any;

                on(type: any, listener: any): any;

                once(type: any, listener: any): any;

                prependListener(type: any, listener: any): any;

                prependOnceListener(type: any, listener: any): any;

                rawListeners(type: any): any;

                removeAllListeners(type: any, ...args: any[]): any;

                removeListener(type: any, listener: any): any;

                setMaxListeners(n: any): any;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static defaultMaxListeners: any;

                static errorMonitor: any;

                static getEventListeners: any;

                static init: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static setMaxListeners: any;

                static usingDomains: any;

            }

        }

        namespace PassThrough {
            class EventEmitter {
                constructor(opts: any);

                addListener(type: any, listener: any): any;

                emit(type: any, args: any): any;

                eventNames(): any;

                getMaxListeners(): any;

                listenerCount(type: any): any;

                listeners(type: any): any;

                off(type: any, listener: any): any;

                on(type: any, listener: any): any;

                once(type: any, listener: any): any;

                prependListener(type: any, listener: any): any;

                prependOnceListener(type: any, listener: any): any;

                rawListeners(type: any): any;

                removeAllListeners(type: any, ...args: any[]): any;

                removeListener(type: any, listener: any): any;

                setMaxListeners(n: any): any;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static defaultMaxListeners: any;

                static errorMonitor: any;

                static getEventListeners: any;

                static init: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static setMaxListeners: any;

                static usingDomains: any;

            }

            class EventEmitterAsyncResource {
                constructor(...args: any[]);

                emit(...args: any[]): void;

                emitDestroy(...args: any[]): void;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static defaultMaxListeners: any;

                static errorMonitor: any;

                static getEventListeners: any;

                static init: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static setMaxListeners: any;

                static usingDomains: any;

            }

            class Readable {
                constructor(options: any);

                addListener(ev: any, fn: any): any;

                destroy(err: any, cb: any): any;

                filter(args: any): any;

                isPaused(): any;

                iterator(options: any): any;

                map(args: any): any;

                off(ev: any, fn: any): any;

                on(ev: any, fn: any): any;

                pause(): any;

                pipe(dest: any, pipeOpts: any): any;

                push(chunk: any, encoding: any): any;

                read(n: any): any;

                removeAllListeners(ev: any, ...args: any[]): any;

                removeListener(ev: any, fn: any): any;

                resume(): any;

                setEncoding(enc: any): any;

                unpipe(dest: any): any;

                unshift(chunk: any, encoding: any): any;

                wrap(stream: any): any;

                static Duplex: any;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static PassThrough: any;

                static Readable: any;

                static ReadableState: any;

                static Stream: any;

                static Transform: any;

                static Writable: any;

                static addAbortSignal: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static compose: any;

                static defaultMaxListeners: any;

                static destroy: any;

                static errorMonitor: any;

                static finished: any;

                static from: any;

                static getEventListeners: any;

                static init: any;

                static isDisturbed: any;

                static isErrored: any;

                static isReadable: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static pipeline: any;

                static promises: any;

                static setMaxListeners: any;

                static usingDomains: any;

                static wrap: any;

            }

            class ReadableState {
                constructor(options: any, stream: any, isDuplex: any);

            }

            class Stream {
                constructor(opts: any);

                pipe(dest: any, options: any): any;

                static Duplex: any;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static PassThrough: any;

                static Readable: any;

                static Stream: any;

                static Transform: any;

                static Writable: any;

                static addAbortSignal: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static compose: any;

                static defaultMaxListeners: any;

                static destroy: any;

                static errorMonitor: any;

                static finished: any;

                static getEventListeners: any;

                static init: any;

                static isDisturbed: any;

                static isErrored: any;

                static isReadable: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static pipeline: any;

                static promises: any;

                static setMaxListeners: any;

                static usingDomains: any;

            }

            class Transform {
                constructor(options: any);

                static Duplex: any;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static PassThrough: any;

                static Readable: any;

                static ReadableState: any;

                static Stream: any;

                static Transform: any;

                static Writable: any;

                static addAbortSignal: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static compose: any;

                static defaultMaxListeners: any;

                static destroy: any;

                static errorMonitor: any;

                static finished: any;

                static from: any;

                static getEventListeners: any;

                static init: any;

                static isDisturbed: any;

                static isErrored: any;

                static isReadable: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static pipeline: any;

                static promises: any;

                static setMaxListeners: any;

                static usingDomains: any;

                static wrap: any;

            }

            class Writable {
                constructor(options: any);

                cork(): void;

                destroy(err: any, cb: any): any;

                end(chunk: any, encoding: any, cb: any): any;

                pipe(): void;

                setDefaultEncoding(encoding: any): any;

                uncork(): void;

                write(chunk: any, encoding: any, cb: any): any;

                static Duplex: any;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static PassThrough: any;

                static Readable: any;

                static Stream: any;

                static Transform: any;

                static Writable: any;

                static WritableState: any;

                static addAbortSignal: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static compose: any;

                static defaultMaxListeners: any;

                static destroy: any;

                static errorMonitor: any;

                static finished: any;

                static getEventListeners: any;

                static init: any;

                static isDisturbed: any;

                static isErrored: any;

                static isReadable: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static pipeline: any;

                static promises: any;

                static setMaxListeners: any;

                static usingDomains: any;

            }

            namespace promises {
                // Too-deep object hierarchy from fs.FileWriteStream.Duplex.PassThrough.promises
                const finished: any;

                // Too-deep object hierarchy from fs.FileWriteStream.Duplex.PassThrough.promises
                const pipeline: any;

            }

        }

        namespace Readable {
            class EventEmitter {
                constructor(opts: any);

                addListener(type: any, listener: any): any;

                emit(type: any, args: any): any;

                eventNames(): any;

                getMaxListeners(): any;

                listenerCount(type: any): any;

                listeners(type: any): any;

                off(type: any, listener: any): any;

                on(type: any, listener: any): any;

                once(type: any, listener: any): any;

                prependListener(type: any, listener: any): any;

                prependOnceListener(type: any, listener: any): any;

                rawListeners(type: any): any;

                removeAllListeners(type: any, ...args: any[]): any;

                removeListener(type: any, listener: any): any;

                setMaxListeners(n: any): any;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static defaultMaxListeners: any;

                static errorMonitor: any;

                static getEventListeners: any;

                static init: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static setMaxListeners: any;

                static usingDomains: any;

            }

            class EventEmitterAsyncResource {
                constructor(...args: any[]);

                emit(...args: any[]): void;

                emitDestroy(...args: any[]): void;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static defaultMaxListeners: any;

                static errorMonitor: any;

                static getEventListeners: any;

                static init: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static setMaxListeners: any;

                static usingDomains: any;

            }

            class PassThrough {
                constructor(options: any);

                static Duplex: any;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static PassThrough: any;

                static Readable: any;

                static ReadableState: any;

                static Stream: any;

                static Transform: any;

                static Writable: any;

                static addAbortSignal: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static compose: any;

                static defaultMaxListeners: any;

                static destroy: any;

                static errorMonitor: any;

                static finished: any;

                static from: any;

                static getEventListeners: any;

                static init: any;

                static isDisturbed: any;

                static isErrored: any;

                static isReadable: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static pipeline: any;

                static promises: any;

                static setMaxListeners: any;

                static usingDomains: any;

                static wrap: any;

            }

            class ReadableState {
                constructor(options: any, stream: any, isDuplex: any);

            }

            class Stream {
                constructor(opts: any);

                pipe(dest: any, options: any): any;

                static Duplex: any;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static PassThrough: any;

                static Readable: any;

                static Stream: any;

                static Transform: any;

                static Writable: any;

                static addAbortSignal: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static compose: any;

                static defaultMaxListeners: any;

                static destroy: any;

                static errorMonitor: any;

                static finished: any;

                static getEventListeners: any;

                static init: any;

                static isDisturbed: any;

                static isErrored: any;

                static isReadable: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static pipeline: any;

                static promises: any;

                static setMaxListeners: any;

                static usingDomains: any;

            }

            class Transform {
                constructor(options: any);

                static Duplex: any;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static PassThrough: any;

                static Readable: any;

                static ReadableState: any;

                static Stream: any;

                static Transform: any;

                static Writable: any;

                static addAbortSignal: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static compose: any;

                static defaultMaxListeners: any;

                static destroy: any;

                static errorMonitor: any;

                static finished: any;

                static from: any;

                static getEventListeners: any;

                static init: any;

                static isDisturbed: any;

                static isErrored: any;

                static isReadable: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static pipeline: any;

                static promises: any;

                static setMaxListeners: any;

                static usingDomains: any;

                static wrap: any;

            }

            class Writable {
                constructor(options: any);

                cork(): void;

                destroy(err: any, cb: any): any;

                end(chunk: any, encoding: any, cb: any): any;

                pipe(): void;

                setDefaultEncoding(encoding: any): any;

                uncork(): void;

                write(chunk: any, encoding: any, cb: any): any;

                static Duplex: any;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static PassThrough: any;

                static Readable: any;

                static Stream: any;

                static Transform: any;

                static Writable: any;

                static WritableState: any;

                static addAbortSignal: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static compose: any;

                static defaultMaxListeners: any;

                static destroy: any;

                static errorMonitor: any;

                static finished: any;

                static getEventListeners: any;

                static init: any;

                static isDisturbed: any;

                static isErrored: any;

                static isReadable: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static pipeline: any;

                static promises: any;

                static setMaxListeners: any;

                static usingDomains: any;

            }

            namespace promises {
                // Too-deep object hierarchy from fs.FileWriteStream.Duplex.Readable.promises
                const finished: any;

                // Too-deep object hierarchy from fs.FileWriteStream.Duplex.Readable.promises
                const pipeline: any;

            }

        }

        namespace Stream {
            class EventEmitter {
                constructor(opts: any);

                addListener(type: any, listener: any): any;

                emit(type: any, args: any): any;

                eventNames(): any;

                getMaxListeners(): any;

                listenerCount(type: any): any;

                listeners(type: any): any;

                off(type: any, listener: any): any;

                on(type: any, listener: any): any;

                once(type: any, listener: any): any;

                prependListener(type: any, listener: any): any;

                prependOnceListener(type: any, listener: any): any;

                rawListeners(type: any): any;

                removeAllListeners(type: any, ...args: any[]): any;

                removeListener(type: any, listener: any): any;

                setMaxListeners(n: any): any;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static defaultMaxListeners: any;

                static errorMonitor: any;

                static getEventListeners: any;

                static init: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static setMaxListeners: any;

                static usingDomains: any;

            }

            class EventEmitterAsyncResource {
                constructor(...args: any[]);

                emit(...args: any[]): void;

                emitDestroy(...args: any[]): void;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static defaultMaxListeners: any;

                static errorMonitor: any;

                static getEventListeners: any;

                static init: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static setMaxListeners: any;

                static usingDomains: any;

            }

            class PassThrough {
                constructor(options: any);

                static Duplex: any;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static PassThrough: any;

                static Readable: any;

                static ReadableState: any;

                static Stream: any;

                static Transform: any;

                static Writable: any;

                static addAbortSignal: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static compose: any;

                static defaultMaxListeners: any;

                static destroy: any;

                static errorMonitor: any;

                static finished: any;

                static from: any;

                static getEventListeners: any;

                static init: any;

                static isDisturbed: any;

                static isErrored: any;

                static isReadable: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static pipeline: any;

                static promises: any;

                static setMaxListeners: any;

                static usingDomains: any;

                static wrap: any;

            }

            class Readable {
                constructor(options: any);

                addListener(ev: any, fn: any): any;

                destroy(err: any, cb: any): any;

                filter(args: any): any;

                isPaused(): any;

                iterator(options: any): any;

                map(args: any): any;

                off(ev: any, fn: any): any;

                on(ev: any, fn: any): any;

                pause(): any;

                pipe(dest: any, pipeOpts: any): any;

                push(chunk: any, encoding: any): any;

                read(n: any): any;

                removeAllListeners(ev: any, ...args: any[]): any;

                removeListener(ev: any, fn: any): any;

                resume(): any;

                setEncoding(enc: any): any;

                unpipe(dest: any): any;

                unshift(chunk: any, encoding: any): any;

                wrap(stream: any): any;

                static Duplex: any;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static PassThrough: any;

                static Readable: any;

                static ReadableState: any;

                static Stream: any;

                static Transform: any;

                static Writable: any;

                static addAbortSignal: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static compose: any;

                static defaultMaxListeners: any;

                static destroy: any;

                static errorMonitor: any;

                static finished: any;

                static from: any;

                static getEventListeners: any;

                static init: any;

                static isDisturbed: any;

                static isErrored: any;

                static isReadable: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static pipeline: any;

                static promises: any;

                static setMaxListeners: any;

                static usingDomains: any;

                static wrap: any;

            }

            class Transform {
                constructor(options: any);

                static Duplex: any;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static PassThrough: any;

                static Readable: any;

                static ReadableState: any;

                static Stream: any;

                static Transform: any;

                static Writable: any;

                static addAbortSignal: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static compose: any;

                static defaultMaxListeners: any;

                static destroy: any;

                static errorMonitor: any;

                static finished: any;

                static from: any;

                static getEventListeners: any;

                static init: any;

                static isDisturbed: any;

                static isErrored: any;

                static isReadable: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static pipeline: any;

                static promises: any;

                static setMaxListeners: any;

                static usingDomains: any;

                static wrap: any;

            }

            class Writable {
                constructor(options: any);

                cork(): void;

                destroy(err: any, cb: any): any;

                end(chunk: any, encoding: any, cb: any): any;

                pipe(): void;

                setDefaultEncoding(encoding: any): any;

                uncork(): void;

                write(chunk: any, encoding: any, cb: any): any;

                static Duplex: any;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static PassThrough: any;

                static Readable: any;

                static Stream: any;

                static Transform: any;

                static Writable: any;

                static WritableState: any;

                static addAbortSignal: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static compose: any;

                static defaultMaxListeners: any;

                static destroy: any;

                static errorMonitor: any;

                static finished: any;

                static getEventListeners: any;

                static init: any;

                static isDisturbed: any;

                static isErrored: any;

                static isReadable: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static pipeline: any;

                static promises: any;

                static setMaxListeners: any;

                static usingDomains: any;

            }

            namespace promises {
                // Too-deep object hierarchy from fs.FileWriteStream.Duplex.Stream.promises
                const finished: any;

                // Too-deep object hierarchy from fs.FileWriteStream.Duplex.Stream.promises
                const pipeline: any;

            }

        }

        namespace Transform {
            class EventEmitter {
                constructor(opts: any);

                addListener(type: any, listener: any): any;

                emit(type: any, args: any): any;

                eventNames(): any;

                getMaxListeners(): any;

                listenerCount(type: any): any;

                listeners(type: any): any;

                off(type: any, listener: any): any;

                on(type: any, listener: any): any;

                once(type: any, listener: any): any;

                prependListener(type: any, listener: any): any;

                prependOnceListener(type: any, listener: any): any;

                rawListeners(type: any): any;

                removeAllListeners(type: any, ...args: any[]): any;

                removeListener(type: any, listener: any): any;

                setMaxListeners(n: any): any;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static defaultMaxListeners: any;

                static errorMonitor: any;

                static getEventListeners: any;

                static init: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static setMaxListeners: any;

                static usingDomains: any;

            }

            class EventEmitterAsyncResource {
                constructor(...args: any[]);

                emit(...args: any[]): void;

                emitDestroy(...args: any[]): void;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static defaultMaxListeners: any;

                static errorMonitor: any;

                static getEventListeners: any;

                static init: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static setMaxListeners: any;

                static usingDomains: any;

            }

            class PassThrough {
                constructor(options: any);

                static Duplex: any;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static PassThrough: any;

                static Readable: any;

                static ReadableState: any;

                static Stream: any;

                static Transform: any;

                static Writable: any;

                static addAbortSignal: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static compose: any;

                static defaultMaxListeners: any;

                static destroy: any;

                static errorMonitor: any;

                static finished: any;

                static from: any;

                static getEventListeners: any;

                static init: any;

                static isDisturbed: any;

                static isErrored: any;

                static isReadable: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static pipeline: any;

                static promises: any;

                static setMaxListeners: any;

                static usingDomains: any;

                static wrap: any;

            }

            class Readable {
                constructor(options: any);

                addListener(ev: any, fn: any): any;

                destroy(err: any, cb: any): any;

                filter(args: any): any;

                isPaused(): any;

                iterator(options: any): any;

                map(args: any): any;

                off(ev: any, fn: any): any;

                on(ev: any, fn: any): any;

                pause(): any;

                pipe(dest: any, pipeOpts: any): any;

                push(chunk: any, encoding: any): any;

                read(n: any): any;

                removeAllListeners(ev: any, ...args: any[]): any;

                removeListener(ev: any, fn: any): any;

                resume(): any;

                setEncoding(enc: any): any;

                unpipe(dest: any): any;

                unshift(chunk: any, encoding: any): any;

                wrap(stream: any): any;

                static Duplex: any;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static PassThrough: any;

                static Readable: any;

                static ReadableState: any;

                static Stream: any;

                static Transform: any;

                static Writable: any;

                static addAbortSignal: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static compose: any;

                static defaultMaxListeners: any;

                static destroy: any;

                static errorMonitor: any;

                static finished: any;

                static from: any;

                static getEventListeners: any;

                static init: any;

                static isDisturbed: any;

                static isErrored: any;

                static isReadable: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static pipeline: any;

                static promises: any;

                static setMaxListeners: any;

                static usingDomains: any;

                static wrap: any;

            }

            class ReadableState {
                constructor(options: any, stream: any, isDuplex: any);

            }

            class Stream {
                constructor(opts: any);

                pipe(dest: any, options: any): any;

                static Duplex: any;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static PassThrough: any;

                static Readable: any;

                static Stream: any;

                static Transform: any;

                static Writable: any;

                static addAbortSignal: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static compose: any;

                static defaultMaxListeners: any;

                static destroy: any;

                static errorMonitor: any;

                static finished: any;

                static getEventListeners: any;

                static init: any;

                static isDisturbed: any;

                static isErrored: any;

                static isReadable: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static pipeline: any;

                static promises: any;

                static setMaxListeners: any;

                static usingDomains: any;

            }

            class Writable {
                constructor(options: any);

                cork(): void;

                destroy(err: any, cb: any): any;

                end(chunk: any, encoding: any, cb: any): any;

                pipe(): void;

                setDefaultEncoding(encoding: any): any;

                uncork(): void;

                write(chunk: any, encoding: any, cb: any): any;

                static Duplex: any;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static PassThrough: any;

                static Readable: any;

                static Stream: any;

                static Transform: any;

                static Writable: any;

                static WritableState: any;

                static addAbortSignal: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static compose: any;

                static defaultMaxListeners: any;

                static destroy: any;

                static errorMonitor: any;

                static finished: any;

                static getEventListeners: any;

                static init: any;

                static isDisturbed: any;

                static isErrored: any;

                static isReadable: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static pipeline: any;

                static promises: any;

                static setMaxListeners: any;

                static usingDomains: any;

            }

            namespace promises {
                // Too-deep object hierarchy from fs.FileWriteStream.Duplex.Transform.promises
                const finished: any;

                // Too-deep object hierarchy from fs.FileWriteStream.Duplex.Transform.promises
                const pipeline: any;

            }

        }

        namespace Writable {
            class EventEmitter {
                constructor(opts: any);

                addListener(type: any, listener: any): any;

                emit(type: any, args: any): any;

                eventNames(): any;

                getMaxListeners(): any;

                listenerCount(type: any): any;

                listeners(type: any): any;

                off(type: any, listener: any): any;

                on(type: any, listener: any): any;

                once(type: any, listener: any): any;

                prependListener(type: any, listener: any): any;

                prependOnceListener(type: any, listener: any): any;

                rawListeners(type: any): any;

                removeAllListeners(type: any, ...args: any[]): any;

                removeListener(type: any, listener: any): any;

                setMaxListeners(n: any): any;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static defaultMaxListeners: any;

                static errorMonitor: any;

                static getEventListeners: any;

                static init: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static setMaxListeners: any;

                static usingDomains: any;

            }

            class EventEmitterAsyncResource {
                constructor(...args: any[]);

                emit(...args: any[]): void;

                emitDestroy(...args: any[]): void;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static defaultMaxListeners: any;

                static errorMonitor: any;

                static getEventListeners: any;

                static init: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static setMaxListeners: any;

                static usingDomains: any;

            }

            class PassThrough {
                constructor(options: any);

                static Duplex: any;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static PassThrough: any;

                static Readable: any;

                static ReadableState: any;

                static Stream: any;

                static Transform: any;

                static Writable: any;

                static addAbortSignal: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static compose: any;

                static defaultMaxListeners: any;

                static destroy: any;

                static errorMonitor: any;

                static finished: any;

                static from: any;

                static getEventListeners: any;

                static init: any;

                static isDisturbed: any;

                static isErrored: any;

                static isReadable: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static pipeline: any;

                static promises: any;

                static setMaxListeners: any;

                static usingDomains: any;

                static wrap: any;

            }

            class Readable {
                constructor(options: any);

                addListener(ev: any, fn: any): any;

                destroy(err: any, cb: any): any;

                filter(args: any): any;

                isPaused(): any;

                iterator(options: any): any;

                map(args: any): any;

                off(ev: any, fn: any): any;

                on(ev: any, fn: any): any;

                pause(): any;

                pipe(dest: any, pipeOpts: any): any;

                push(chunk: any, encoding: any): any;

                read(n: any): any;

                removeAllListeners(ev: any, ...args: any[]): any;

                removeListener(ev: any, fn: any): any;

                resume(): any;

                setEncoding(enc: any): any;

                unpipe(dest: any): any;

                unshift(chunk: any, encoding: any): any;

                wrap(stream: any): any;

                static Duplex: any;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static PassThrough: any;

                static Readable: any;

                static ReadableState: any;

                static Stream: any;

                static Transform: any;

                static Writable: any;

                static addAbortSignal: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static compose: any;

                static defaultMaxListeners: any;

                static destroy: any;

                static errorMonitor: any;

                static finished: any;

                static from: any;

                static getEventListeners: any;

                static init: any;

                static isDisturbed: any;

                static isErrored: any;

                static isReadable: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static pipeline: any;

                static promises: any;

                static setMaxListeners: any;

                static usingDomains: any;

                static wrap: any;

            }

            class Stream {
                constructor(opts: any);

                pipe(dest: any, options: any): any;

                static Duplex: any;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static PassThrough: any;

                static Readable: any;

                static Stream: any;

                static Transform: any;

                static Writable: any;

                static addAbortSignal: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static compose: any;

                static defaultMaxListeners: any;

                static destroy: any;

                static errorMonitor: any;

                static finished: any;

                static getEventListeners: any;

                static init: any;

                static isDisturbed: any;

                static isErrored: any;

                static isReadable: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static pipeline: any;

                static promises: any;

                static setMaxListeners: any;

                static usingDomains: any;

            }

            class Transform {
                constructor(options: any);

                static Duplex: any;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static PassThrough: any;

                static Readable: any;

                static ReadableState: any;

                static Stream: any;

                static Transform: any;

                static Writable: any;

                static addAbortSignal: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static compose: any;

                static defaultMaxListeners: any;

                static destroy: any;

                static errorMonitor: any;

                static finished: any;

                static from: any;

                static getEventListeners: any;

                static init: any;

                static isDisturbed: any;

                static isErrored: any;

                static isReadable: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static pipeline: any;

                static promises: any;

                static setMaxListeners: any;

                static usingDomains: any;

                static wrap: any;

            }

            class WritableState {
                constructor(options: any, stream: any, isDuplex: any);

                getBuffer(): any;

            }

            namespace promises {
                // Too-deep object hierarchy from fs.FileWriteStream.Duplex.Writable.promises
                const finished: any;

                // Too-deep object hierarchy from fs.FileWriteStream.Duplex.Writable.promises
                const pipeline: any;

            }

        }

        namespace promises {
            function finished(stream: any, opts: any): any;

            function pipeline(streams: any): any;

        }

    }

    namespace EventEmitter {
        class EventEmitterAsyncResource {
            constructor(...args: any[]);

            emit(...args: any[]): void;

            emitDestroy(...args: any[]): void;

            static EventEmitter: any;

            static EventEmitterAsyncResource: any;

            static captureRejectionSymbol: any;

            static captureRejections: boolean;

            static defaultMaxListeners: number;

            static errorMonitor: any;

            static getEventListeners(emitterOrTarget: any, type: any): any;

            static init(opts: any): void;

            static kMaxEventTargetListeners: any;

            static kMaxEventTargetListenersWarned: any;

            static listenerCount(emitter: any, type: any): any;

            static on(emitter: any, event: any, options: any): any;

            static once(emitter: any, name: any, options: any): any;

            static setMaxListeners(n: any, eventTargets: any): void;

            static usingDomains: boolean;

        }

    }

    namespace EventEmitterAsyncResource {
        class EventEmitter {
            constructor(opts: any);

            addListener(type: any, listener: any): any;

            emit(type: any, args: any): any;

            eventNames(): any;

            getMaxListeners(): any;

            listenerCount(type: any): any;

            listeners(type: any): any;

            off(type: any, listener: any): any;

            on(type: any, listener: any): any;

            once(type: any, listener: any): any;

            prependListener(type: any, listener: any): any;

            prependOnceListener(type: any, listener: any): any;

            rawListeners(type: any): any;

            removeAllListeners(type: any, ...args: any[]): any;

            removeListener(type: any, listener: any): any;

            setMaxListeners(n: any): any;

            static EventEmitter: any;

            static EventEmitterAsyncResource: any;

            static captureRejectionSymbol: any;

            static captureRejections: boolean;

            static defaultMaxListeners: number;

            static errorMonitor: any;

            static getEventListeners(emitterOrTarget: any, type: any): any;

            static init(opts: any): void;

            static kMaxEventTargetListeners: any;

            static kMaxEventTargetListenersWarned: any;

            static listenerCount(emitter: any, type: any): any;

            static on(emitter: any, event: any, options: any): any;

            static once(emitter: any, name: any, options: any): any;

            static setMaxListeners(n: any, eventTargets: any): void;

            static usingDomains: boolean;

        }

    }

    namespace PassThrough {
        class Duplex {
            constructor(options: any);

            cork(): void;

            end(chunk: any, encoding: any, cb: any): any;

            setDefaultEncoding(encoding: any): any;

            uncork(): void;

            write(chunk: any, encoding: any, cb: any): any;

            static Duplex: any;

            static PassThrough: any;

            static addAbortSignal(signal: any, stream: any): any;

            static captureRejectionSymbol: any;

            static captureRejections: boolean;

            static compose(streams: any): any;

            static defaultMaxListeners: number;

            static destroy(stream: any, err: any): any;

            static errorMonitor: any;

            static finished(stream: any, options: any, callback: any, ...args: any[]): any;

            static from(body: any): any;

            static getEventListeners(emitterOrTarget: any, type: any): any;

            static init(opts: any): void;

            static isDisturbed(stream: any): any;

            static isErrored(stream: any): any;

            static isReadable(stream: any): any;

            static kMaxEventTargetListeners: any;

            static kMaxEventTargetListenersWarned: any;

            static listenerCount(emitter: any, type: any): any;

            static on(emitter: any, event: any, options: any): any;

            static once(emitter: any, name: any, options: any): any;

            static pipeline(streams: any): any;

            static setMaxListeners(n: any, eventTargets: any): void;

            static usingDomains: boolean;

            static wrap(src: any, options: any): any;

        }

        class EventEmitter {
            constructor(opts: any);

            addListener(type: any, listener: any): any;

            emit(type: any, args: any): any;

            eventNames(): any;

            getMaxListeners(): any;

            listenerCount(type: any): any;

            listeners(type: any): any;

            off(type: any, listener: any): any;

            on(type: any, listener: any): any;

            once(type: any, listener: any): any;

            prependListener(type: any, listener: any): any;

            prependOnceListener(type: any, listener: any): any;

            rawListeners(type: any): any;

            removeAllListeners(type: any, ...args: any[]): any;

            removeListener(type: any, listener: any): any;

            setMaxListeners(n: any): any;

            static EventEmitter: any;

            static captureRejectionSymbol: any;

            static captureRejections: boolean;

            static defaultMaxListeners: number;

            static errorMonitor: any;

            static getEventListeners(emitterOrTarget: any, type: any): any;

            static init(opts: any): void;

            static kMaxEventTargetListeners: any;

            static kMaxEventTargetListenersWarned: any;

            static listenerCount(emitter: any, type: any): any;

            static on(emitter: any, event: any, options: any): any;

            static once(emitter: any, name: any, options: any): any;

            static setMaxListeners(n: any, eventTargets: any): void;

            static usingDomains: boolean;

        }

        class EventEmitterAsyncResource {
            constructor(...args: any[]);

            emit(...args: any[]): void;

            emitDestroy(...args: any[]): void;

            static EventEmitterAsyncResource: any;

            static captureRejectionSymbol: any;

            static captureRejections: boolean;

            static defaultMaxListeners: number;

            static errorMonitor: any;

            static getEventListeners(emitterOrTarget: any, type: any): any;

            static init(opts: any): void;

            static kMaxEventTargetListeners: any;

            static kMaxEventTargetListenersWarned: any;

            static listenerCount(emitter: any, type: any): any;

            static on(emitter: any, event: any, options: any): any;

            static once(emitter: any, name: any, options: any): any;

            static setMaxListeners(n: any, eventTargets: any): void;

            static usingDomains: boolean;

        }

        class Readable {
            constructor(options: any);

            addListener(ev: any, fn: any): any;

            destroy(err: any, cb: any): any;

            filter(args: any): any;

            isPaused(): any;

            iterator(options: any): any;

            map(args: any): any;

            off(ev: any, fn: any): any;

            on(ev: any, fn: any): any;

            pause(): any;

            pipe(dest: any, pipeOpts: any): any;

            push(chunk: any, encoding: any): any;

            read(n: any): any;

            removeAllListeners(ev: any, ...args: any[]): any;

            removeListener(ev: any, fn: any): any;

            resume(): any;

            setEncoding(enc: any): any;

            unpipe(dest: any): any;

            unshift(chunk: any, encoding: any): any;

            wrap(stream: any): any;

            static PassThrough: any;

            static Readable: any;

            static addAbortSignal(signal: any, stream: any): any;

            static captureRejectionSymbol: any;

            static captureRejections: boolean;

            static compose(streams: any): any;

            static defaultMaxListeners: number;

            static destroy(stream: any, err: any): any;

            static errorMonitor: any;

            static finished(stream: any, options: any, callback: any, ...args: any[]): any;

            static from(iterable: any, opts: any): any;

            static getEventListeners(emitterOrTarget: any, type: any): any;

            static init(opts: any): void;

            static isDisturbed(stream: any): any;

            static isErrored(stream: any): any;

            static isReadable(stream: any): any;

            static kMaxEventTargetListeners: any;

            static kMaxEventTargetListenersWarned: any;

            static listenerCount(emitter: any, type: any): any;

            static on(emitter: any, event: any, options: any): any;

            static once(emitter: any, name: any, options: any): any;

            static pipeline(streams: any): any;

            static setMaxListeners(n: any, eventTargets: any): void;

            static usingDomains: boolean;

            static wrap(src: any, options: any): any;

        }

        class ReadableState {
            constructor(options: any, stream: any, isDuplex: any);

        }

        class Stream {
            constructor(opts: any);

            pipe(dest: any, options: any): any;

            static PassThrough: any;

            static Stream: any;

            static addAbortSignal(signal: any, stream: any): any;

            static captureRejectionSymbol: any;

            static captureRejections: boolean;

            static compose(streams: any): any;

            static defaultMaxListeners: number;

            static destroy(stream: any, err: any): any;

            static errorMonitor: any;

            static finished(stream: any, options: any, callback: any, ...args: any[]): any;

            static getEventListeners(emitterOrTarget: any, type: any): any;

            static init(opts: any): void;

            static isDisturbed(stream: any): any;

            static isErrored(stream: any): any;

            static isReadable(stream: any): any;

            static kMaxEventTargetListeners: any;

            static kMaxEventTargetListenersWarned: any;

            static listenerCount(emitter: any, type: any): any;

            static on(emitter: any, event: any, options: any): any;

            static once(emitter: any, name: any, options: any): any;

            static pipeline(streams: any): any;

            static setMaxListeners(n: any, eventTargets: any): void;

            static usingDomains: boolean;

        }

        class Transform {
            constructor(options: any);

            static PassThrough: any;

            static Transform: any;

            static addAbortSignal(signal: any, stream: any): any;

            static captureRejectionSymbol: any;

            static captureRejections: boolean;

            static compose(streams: any): any;

            static defaultMaxListeners: number;

            static destroy(stream: any, err: any): any;

            static errorMonitor: any;

            static finished(stream: any, options: any, callback: any, ...args: any[]): any;

            static from(body: any): any;

            static getEventListeners(emitterOrTarget: any, type: any): any;

            static init(opts: any): void;

            static isDisturbed(stream: any): any;

            static isErrored(stream: any): any;

            static isReadable(stream: any): any;

            static kMaxEventTargetListeners: any;

            static kMaxEventTargetListenersWarned: any;

            static listenerCount(emitter: any, type: any): any;

            static on(emitter: any, event: any, options: any): any;

            static once(emitter: any, name: any, options: any): any;

            static pipeline(streams: any): any;

            static setMaxListeners(n: any, eventTargets: any): void;

            static usingDomains: boolean;

            static wrap(src: any, options: any): any;

        }

        class Writable {
            constructor(options: any);

            cork(): void;

            destroy(err: any, cb: any): any;

            end(chunk: any, encoding: any, cb: any): any;

            pipe(): void;

            setDefaultEncoding(encoding: any): any;

            uncork(): void;

            write(chunk: any, encoding: any, cb: any): any;

            static PassThrough: any;

            static Writable: any;

            static addAbortSignal(signal: any, stream: any): any;

            static captureRejectionSymbol: any;

            static captureRejections: boolean;

            static compose(streams: any): any;

            static defaultMaxListeners: number;

            static destroy(stream: any, err: any): any;

            static errorMonitor: any;

            static finished(stream: any, options: any, callback: any, ...args: any[]): any;

            static getEventListeners(emitterOrTarget: any, type: any): any;

            static init(opts: any): void;

            static isDisturbed(stream: any): any;

            static isErrored(stream: any): any;

            static isReadable(stream: any): any;

            static kMaxEventTargetListeners: any;

            static kMaxEventTargetListenersWarned: any;

            static listenerCount(emitter: any, type: any): any;

            static on(emitter: any, event: any, options: any): any;

            static once(emitter: any, name: any, options: any): any;

            static pipeline(streams: any): any;

            static setMaxListeners(n: any, eventTargets: any): void;

            static usingDomains: boolean;

        }

        namespace Duplex {
            class EventEmitter {
                constructor(opts: any);

                addListener(type: any, listener: any): any;

                emit(type: any, args: any): any;

                eventNames(): any;

                getMaxListeners(): any;

                listenerCount(type: any): any;

                listeners(type: any): any;

                off(type: any, listener: any): any;

                on(type: any, listener: any): any;

                once(type: any, listener: any): any;

                prependListener(type: any, listener: any): any;

                prependOnceListener(type: any, listener: any): any;

                rawListeners(type: any): any;

                removeAllListeners(type: any, ...args: any[]): any;

                removeListener(type: any, listener: any): any;

                setMaxListeners(n: any): any;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static defaultMaxListeners: any;

                static errorMonitor: any;

                static getEventListeners: any;

                static init: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static setMaxListeners: any;

                static usingDomains: any;

            }

            class EventEmitterAsyncResource {
                constructor(...args: any[]);

                emit(...args: any[]): void;

                emitDestroy(...args: any[]): void;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static defaultMaxListeners: any;

                static errorMonitor: any;

                static getEventListeners: any;

                static init: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static setMaxListeners: any;

                static usingDomains: any;

            }

            class Readable {
                constructor(options: any);

                addListener(ev: any, fn: any): any;

                destroy(err: any, cb: any): any;

                filter(args: any): any;

                isPaused(): any;

                iterator(options: any): any;

                map(args: any): any;

                off(ev: any, fn: any): any;

                on(ev: any, fn: any): any;

                pause(): any;

                pipe(dest: any, pipeOpts: any): any;

                push(chunk: any, encoding: any): any;

                read(n: any): any;

                removeAllListeners(ev: any, ...args: any[]): any;

                removeListener(ev: any, fn: any): any;

                resume(): any;

                setEncoding(enc: any): any;

                unpipe(dest: any): any;

                unshift(chunk: any, encoding: any): any;

                wrap(stream: any): any;

                static Duplex: any;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static PassThrough: any;

                static Readable: any;

                static ReadableState: any;

                static Stream: any;

                static Transform: any;

                static Writable: any;

                static addAbortSignal: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static compose: any;

                static defaultMaxListeners: any;

                static destroy: any;

                static errorMonitor: any;

                static finished: any;

                static from: any;

                static getEventListeners: any;

                static init: any;

                static isDisturbed: any;

                static isErrored: any;

                static isReadable: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static pipeline: any;

                static promises: any;

                static setMaxListeners: any;

                static usingDomains: any;

                static wrap: any;

            }

            class ReadableState {
                constructor(options: any, stream: any, isDuplex: any);

            }

            class Stream {
                constructor(opts: any);

                pipe(dest: any, options: any): any;

                static Duplex: any;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static PassThrough: any;

                static Readable: any;

                static Stream: any;

                static Transform: any;

                static Writable: any;

                static addAbortSignal: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static compose: any;

                static defaultMaxListeners: any;

                static destroy: any;

                static errorMonitor: any;

                static finished: any;

                static getEventListeners: any;

                static init: any;

                static isDisturbed: any;

                static isErrored: any;

                static isReadable: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static pipeline: any;

                static promises: any;

                static setMaxListeners: any;

                static usingDomains: any;

            }

            class Transform {
                constructor(options: any);

                static Duplex: any;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static PassThrough: any;

                static Readable: any;

                static ReadableState: any;

                static Stream: any;

                static Transform: any;

                static Writable: any;

                static addAbortSignal: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static compose: any;

                static defaultMaxListeners: any;

                static destroy: any;

                static errorMonitor: any;

                static finished: any;

                static from: any;

                static getEventListeners: any;

                static init: any;

                static isDisturbed: any;

                static isErrored: any;

                static isReadable: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static pipeline: any;

                static promises: any;

                static setMaxListeners: any;

                static usingDomains: any;

                static wrap: any;

            }

            class Writable {
                constructor(options: any);

                cork(): void;

                destroy(err: any, cb: any): any;

                end(chunk: any, encoding: any, cb: any): any;

                pipe(): void;

                setDefaultEncoding(encoding: any): any;

                uncork(): void;

                write(chunk: any, encoding: any, cb: any): any;

                static Duplex: any;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static PassThrough: any;

                static Readable: any;

                static Stream: any;

                static Transform: any;

                static Writable: any;

                static WritableState: any;

                static addAbortSignal: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static compose: any;

                static defaultMaxListeners: any;

                static destroy: any;

                static errorMonitor: any;

                static finished: any;

                static getEventListeners: any;

                static init: any;

                static isDisturbed: any;

                static isErrored: any;

                static isReadable: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static pipeline: any;

                static promises: any;

                static setMaxListeners: any;

                static usingDomains: any;

            }

            namespace promises {
                // Too-deep object hierarchy from fs.FileWriteStream.PassThrough.Duplex.promises
                const finished: any;

                // Too-deep object hierarchy from fs.FileWriteStream.PassThrough.Duplex.promises
                const pipeline: any;

            }

        }

        namespace EventEmitter {
            class EventEmitterAsyncResource {
                constructor(...args: any[]);

                emit(...args: any[]): void;

                emitDestroy(...args: any[]): void;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static defaultMaxListeners: any;

                static errorMonitor: any;

                static getEventListeners: any;

                static init: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static setMaxListeners: any;

                static usingDomains: any;

            }

        }

        namespace EventEmitterAsyncResource {
            class EventEmitter {
                constructor(opts: any);

                addListener(type: any, listener: any): any;

                emit(type: any, args: any): any;

                eventNames(): any;

                getMaxListeners(): any;

                listenerCount(type: any): any;

                listeners(type: any): any;

                off(type: any, listener: any): any;

                on(type: any, listener: any): any;

                once(type: any, listener: any): any;

                prependListener(type: any, listener: any): any;

                prependOnceListener(type: any, listener: any): any;

                rawListeners(type: any): any;

                removeAllListeners(type: any, ...args: any[]): any;

                removeListener(type: any, listener: any): any;

                setMaxListeners(n: any): any;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static defaultMaxListeners: any;

                static errorMonitor: any;

                static getEventListeners: any;

                static init: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static setMaxListeners: any;

                static usingDomains: any;

            }

        }

        namespace Readable {
            class Duplex {
                constructor(options: any);

                cork(): void;

                end(chunk: any, encoding: any, cb: any): any;

                setDefaultEncoding(encoding: any): any;

                uncork(): void;

                write(chunk: any, encoding: any, cb: any): any;

                static Duplex: any;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static PassThrough: any;

                static Readable: any;

                static ReadableState: any;

                static Stream: any;

                static Transform: any;

                static Writable: any;

                static addAbortSignal: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static compose: any;

                static defaultMaxListeners: any;

                static destroy: any;

                static errorMonitor: any;

                static finished: any;

                static from: any;

                static getEventListeners: any;

                static init: any;

                static isDisturbed: any;

                static isErrored: any;

                static isReadable: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static pipeline: any;

                static promises: any;

                static setMaxListeners: any;

                static usingDomains: any;

                static wrap: any;

            }

            class EventEmitter {
                constructor(opts: any);

                addListener(type: any, listener: any): any;

                emit(type: any, args: any): any;

                eventNames(): any;

                getMaxListeners(): any;

                listenerCount(type: any): any;

                listeners(type: any): any;

                off(type: any, listener: any): any;

                on(type: any, listener: any): any;

                once(type: any, listener: any): any;

                prependListener(type: any, listener: any): any;

                prependOnceListener(type: any, listener: any): any;

                rawListeners(type: any): any;

                removeAllListeners(type: any, ...args: any[]): any;

                removeListener(type: any, listener: any): any;

                setMaxListeners(n: any): any;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static defaultMaxListeners: any;

                static errorMonitor: any;

                static getEventListeners: any;

                static init: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static setMaxListeners: any;

                static usingDomains: any;

            }

            class EventEmitterAsyncResource {
                constructor(...args: any[]);

                emit(...args: any[]): void;

                emitDestroy(...args: any[]): void;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static defaultMaxListeners: any;

                static errorMonitor: any;

                static getEventListeners: any;

                static init: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static setMaxListeners: any;

                static usingDomains: any;

            }

            class ReadableState {
                constructor(options: any, stream: any, isDuplex: any);

            }

            class Stream {
                constructor(opts: any);

                pipe(dest: any, options: any): any;

                static Duplex: any;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static PassThrough: any;

                static Readable: any;

                static Stream: any;

                static Transform: any;

                static Writable: any;

                static addAbortSignal: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static compose: any;

                static defaultMaxListeners: any;

                static destroy: any;

                static errorMonitor: any;

                static finished: any;

                static getEventListeners: any;

                static init: any;

                static isDisturbed: any;

                static isErrored: any;

                static isReadable: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static pipeline: any;

                static promises: any;

                static setMaxListeners: any;

                static usingDomains: any;

            }

            class Transform {
                constructor(options: any);

                static Duplex: any;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static PassThrough: any;

                static Readable: any;

                static ReadableState: any;

                static Stream: any;

                static Transform: any;

                static Writable: any;

                static addAbortSignal: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static compose: any;

                static defaultMaxListeners: any;

                static destroy: any;

                static errorMonitor: any;

                static finished: any;

                static from: any;

                static getEventListeners: any;

                static init: any;

                static isDisturbed: any;

                static isErrored: any;

                static isReadable: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static pipeline: any;

                static promises: any;

                static setMaxListeners: any;

                static usingDomains: any;

                static wrap: any;

            }

            class Writable {
                constructor(options: any);

                cork(): void;

                destroy(err: any, cb: any): any;

                end(chunk: any, encoding: any, cb: any): any;

                pipe(): void;

                setDefaultEncoding(encoding: any): any;

                uncork(): void;

                write(chunk: any, encoding: any, cb: any): any;

                static Duplex: any;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static PassThrough: any;

                static Readable: any;

                static Stream: any;

                static Transform: any;

                static Writable: any;

                static WritableState: any;

                static addAbortSignal: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static compose: any;

                static defaultMaxListeners: any;

                static destroy: any;

                static errorMonitor: any;

                static finished: any;

                static getEventListeners: any;

                static init: any;

                static isDisturbed: any;

                static isErrored: any;

                static isReadable: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static pipeline: any;

                static promises: any;

                static setMaxListeners: any;

                static usingDomains: any;

            }

            namespace promises {
                // Too-deep object hierarchy from fs.FileWriteStream.PassThrough.Readable.promises
                const finished: any;

                // Too-deep object hierarchy from fs.FileWriteStream.PassThrough.Readable.promises
                const pipeline: any;

            }

        }

        namespace Stream {
            class Duplex {
                constructor(options: any);

                cork(): void;

                end(chunk: any, encoding: any, cb: any): any;

                setDefaultEncoding(encoding: any): any;

                uncork(): void;

                write(chunk: any, encoding: any, cb: any): any;

                static Duplex: any;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static PassThrough: any;

                static Readable: any;

                static ReadableState: any;

                static Stream: any;

                static Transform: any;

                static Writable: any;

                static addAbortSignal: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static compose: any;

                static defaultMaxListeners: any;

                static destroy: any;

                static errorMonitor: any;

                static finished: any;

                static from: any;

                static getEventListeners: any;

                static init: any;

                static isDisturbed: any;

                static isErrored: any;

                static isReadable: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static pipeline: any;

                static promises: any;

                static setMaxListeners: any;

                static usingDomains: any;

                static wrap: any;

            }

            class EventEmitter {
                constructor(opts: any);

                addListener(type: any, listener: any): any;

                emit(type: any, args: any): any;

                eventNames(): any;

                getMaxListeners(): any;

                listenerCount(type: any): any;

                listeners(type: any): any;

                off(type: any, listener: any): any;

                on(type: any, listener: any): any;

                once(type: any, listener: any): any;

                prependListener(type: any, listener: any): any;

                prependOnceListener(type: any, listener: any): any;

                rawListeners(type: any): any;

                removeAllListeners(type: any, ...args: any[]): any;

                removeListener(type: any, listener: any): any;

                setMaxListeners(n: any): any;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static defaultMaxListeners: any;

                static errorMonitor: any;

                static getEventListeners: any;

                static init: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static setMaxListeners: any;

                static usingDomains: any;

            }

            class EventEmitterAsyncResource {
                constructor(...args: any[]);

                emit(...args: any[]): void;

                emitDestroy(...args: any[]): void;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static defaultMaxListeners: any;

                static errorMonitor: any;

                static getEventListeners: any;

                static init: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static setMaxListeners: any;

                static usingDomains: any;

            }

            class Readable {
                constructor(options: any);

                addListener(ev: any, fn: any): any;

                destroy(err: any, cb: any): any;

                filter(args: any): any;

                isPaused(): any;

                iterator(options: any): any;

                map(args: any): any;

                off(ev: any, fn: any): any;

                on(ev: any, fn: any): any;

                pause(): any;

                pipe(dest: any, pipeOpts: any): any;

                push(chunk: any, encoding: any): any;

                read(n: any): any;

                removeAllListeners(ev: any, ...args: any[]): any;

                removeListener(ev: any, fn: any): any;

                resume(): any;

                setEncoding(enc: any): any;

                unpipe(dest: any): any;

                unshift(chunk: any, encoding: any): any;

                wrap(stream: any): any;

                static Duplex: any;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static PassThrough: any;

                static Readable: any;

                static ReadableState: any;

                static Stream: any;

                static Transform: any;

                static Writable: any;

                static addAbortSignal: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static compose: any;

                static defaultMaxListeners: any;

                static destroy: any;

                static errorMonitor: any;

                static finished: any;

                static from: any;

                static getEventListeners: any;

                static init: any;

                static isDisturbed: any;

                static isErrored: any;

                static isReadable: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static pipeline: any;

                static promises: any;

                static setMaxListeners: any;

                static usingDomains: any;

                static wrap: any;

            }

            class Transform {
                constructor(options: any);

                static Duplex: any;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static PassThrough: any;

                static Readable: any;

                static ReadableState: any;

                static Stream: any;

                static Transform: any;

                static Writable: any;

                static addAbortSignal: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static compose: any;

                static defaultMaxListeners: any;

                static destroy: any;

                static errorMonitor: any;

                static finished: any;

                static from: any;

                static getEventListeners: any;

                static init: any;

                static isDisturbed: any;

                static isErrored: any;

                static isReadable: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static pipeline: any;

                static promises: any;

                static setMaxListeners: any;

                static usingDomains: any;

                static wrap: any;

            }

            class Writable {
                constructor(options: any);

                cork(): void;

                destroy(err: any, cb: any): any;

                end(chunk: any, encoding: any, cb: any): any;

                pipe(): void;

                setDefaultEncoding(encoding: any): any;

                uncork(): void;

                write(chunk: any, encoding: any, cb: any): any;

                static Duplex: any;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static PassThrough: any;

                static Readable: any;

                static Stream: any;

                static Transform: any;

                static Writable: any;

                static WritableState: any;

                static addAbortSignal: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static compose: any;

                static defaultMaxListeners: any;

                static destroy: any;

                static errorMonitor: any;

                static finished: any;

                static getEventListeners: any;

                static init: any;

                static isDisturbed: any;

                static isErrored: any;

                static isReadable: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static pipeline: any;

                static promises: any;

                static setMaxListeners: any;

                static usingDomains: any;

            }

            namespace promises {
                // Too-deep object hierarchy from fs.FileWriteStream.PassThrough.Stream.promises
                const finished: any;

                // Too-deep object hierarchy from fs.FileWriteStream.PassThrough.Stream.promises
                const pipeline: any;

            }

        }

        namespace Transform {
            class Duplex {
                constructor(options: any);

                cork(): void;

                end(chunk: any, encoding: any, cb: any): any;

                setDefaultEncoding(encoding: any): any;

                uncork(): void;

                write(chunk: any, encoding: any, cb: any): any;

                static Duplex: any;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static PassThrough: any;

                static Readable: any;

                static ReadableState: any;

                static Stream: any;

                static Transform: any;

                static Writable: any;

                static addAbortSignal: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static compose: any;

                static defaultMaxListeners: any;

                static destroy: any;

                static errorMonitor: any;

                static finished: any;

                static from: any;

                static getEventListeners: any;

                static init: any;

                static isDisturbed: any;

                static isErrored: any;

                static isReadable: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static pipeline: any;

                static promises: any;

                static setMaxListeners: any;

                static usingDomains: any;

                static wrap: any;

            }

            class EventEmitter {
                constructor(opts: any);

                addListener(type: any, listener: any): any;

                emit(type: any, args: any): any;

                eventNames(): any;

                getMaxListeners(): any;

                listenerCount(type: any): any;

                listeners(type: any): any;

                off(type: any, listener: any): any;

                on(type: any, listener: any): any;

                once(type: any, listener: any): any;

                prependListener(type: any, listener: any): any;

                prependOnceListener(type: any, listener: any): any;

                rawListeners(type: any): any;

                removeAllListeners(type: any, ...args: any[]): any;

                removeListener(type: any, listener: any): any;

                setMaxListeners(n: any): any;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static defaultMaxListeners: any;

                static errorMonitor: any;

                static getEventListeners: any;

                static init: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static setMaxListeners: any;

                static usingDomains: any;

            }

            class EventEmitterAsyncResource {
                constructor(...args: any[]);

                emit(...args: any[]): void;

                emitDestroy(...args: any[]): void;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static defaultMaxListeners: any;

                static errorMonitor: any;

                static getEventListeners: any;

                static init: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static setMaxListeners: any;

                static usingDomains: any;

            }

            class Readable {
                constructor(options: any);

                addListener(ev: any, fn: any): any;

                destroy(err: any, cb: any): any;

                filter(args: any): any;

                isPaused(): any;

                iterator(options: any): any;

                map(args: any): any;

                off(ev: any, fn: any): any;

                on(ev: any, fn: any): any;

                pause(): any;

                pipe(dest: any, pipeOpts: any): any;

                push(chunk: any, encoding: any): any;

                read(n: any): any;

                removeAllListeners(ev: any, ...args: any[]): any;

                removeListener(ev: any, fn: any): any;

                resume(): any;

                setEncoding(enc: any): any;

                unpipe(dest: any): any;

                unshift(chunk: any, encoding: any): any;

                wrap(stream: any): any;

                static Duplex: any;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static PassThrough: any;

                static Readable: any;

                static ReadableState: any;

                static Stream: any;

                static Transform: any;

                static Writable: any;

                static addAbortSignal: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static compose: any;

                static defaultMaxListeners: any;

                static destroy: any;

                static errorMonitor: any;

                static finished: any;

                static from: any;

                static getEventListeners: any;

                static init: any;

                static isDisturbed: any;

                static isErrored: any;

                static isReadable: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static pipeline: any;

                static promises: any;

                static setMaxListeners: any;

                static usingDomains: any;

                static wrap: any;

            }

            class ReadableState {
                constructor(options: any, stream: any, isDuplex: any);

            }

            class Stream {
                constructor(opts: any);

                pipe(dest: any, options: any): any;

                static Duplex: any;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static PassThrough: any;

                static Readable: any;

                static Stream: any;

                static Transform: any;

                static Writable: any;

                static addAbortSignal: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static compose: any;

                static defaultMaxListeners: any;

                static destroy: any;

                static errorMonitor: any;

                static finished: any;

                static getEventListeners: any;

                static init: any;

                static isDisturbed: any;

                static isErrored: any;

                static isReadable: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static pipeline: any;

                static promises: any;

                static setMaxListeners: any;

                static usingDomains: any;

            }

            class Writable {
                constructor(options: any);

                cork(): void;

                destroy(err: any, cb: any): any;

                end(chunk: any, encoding: any, cb: any): any;

                pipe(): void;

                setDefaultEncoding(encoding: any): any;

                uncork(): void;

                write(chunk: any, encoding: any, cb: any): any;

                static Duplex: any;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static PassThrough: any;

                static Readable: any;

                static Stream: any;

                static Transform: any;

                static Writable: any;

                static WritableState: any;

                static addAbortSignal: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static compose: any;

                static defaultMaxListeners: any;

                static destroy: any;

                static errorMonitor: any;

                static finished: any;

                static getEventListeners: any;

                static init: any;

                static isDisturbed: any;

                static isErrored: any;

                static isReadable: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static pipeline: any;

                static promises: any;

                static setMaxListeners: any;

                static usingDomains: any;

            }

            namespace promises {
                // Too-deep object hierarchy from fs.FileWriteStream.PassThrough.Transform.promises
                const finished: any;

                // Too-deep object hierarchy from fs.FileWriteStream.PassThrough.Transform.promises
                const pipeline: any;

            }

        }

        namespace Writable {
            class Duplex {
                constructor(options: any);

                cork(): void;

                end(chunk: any, encoding: any, cb: any): any;

                setDefaultEncoding(encoding: any): any;

                uncork(): void;

                write(chunk: any, encoding: any, cb: any): any;

                static Duplex: any;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static PassThrough: any;

                static Readable: any;

                static ReadableState: any;

                static Stream: any;

                static Transform: any;

                static Writable: any;

                static addAbortSignal: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static compose: any;

                static defaultMaxListeners: any;

                static destroy: any;

                static errorMonitor: any;

                static finished: any;

                static from: any;

                static getEventListeners: any;

                static init: any;

                static isDisturbed: any;

                static isErrored: any;

                static isReadable: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static pipeline: any;

                static promises: any;

                static setMaxListeners: any;

                static usingDomains: any;

                static wrap: any;

            }

            class EventEmitter {
                constructor(opts: any);

                addListener(type: any, listener: any): any;

                emit(type: any, args: any): any;

                eventNames(): any;

                getMaxListeners(): any;

                listenerCount(type: any): any;

                listeners(type: any): any;

                off(type: any, listener: any): any;

                on(type: any, listener: any): any;

                once(type: any, listener: any): any;

                prependListener(type: any, listener: any): any;

                prependOnceListener(type: any, listener: any): any;

                rawListeners(type: any): any;

                removeAllListeners(type: any, ...args: any[]): any;

                removeListener(type: any, listener: any): any;

                setMaxListeners(n: any): any;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static defaultMaxListeners: any;

                static errorMonitor: any;

                static getEventListeners: any;

                static init: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static setMaxListeners: any;

                static usingDomains: any;

            }

            class EventEmitterAsyncResource {
                constructor(...args: any[]);

                emit(...args: any[]): void;

                emitDestroy(...args: any[]): void;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static defaultMaxListeners: any;

                static errorMonitor: any;

                static getEventListeners: any;

                static init: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static setMaxListeners: any;

                static usingDomains: any;

            }

            class Readable {
                constructor(options: any);

                addListener(ev: any, fn: any): any;

                destroy(err: any, cb: any): any;

                filter(args: any): any;

                isPaused(): any;

                iterator(options: any): any;

                map(args: any): any;

                off(ev: any, fn: any): any;

                on(ev: any, fn: any): any;

                pause(): any;

                pipe(dest: any, pipeOpts: any): any;

                push(chunk: any, encoding: any): any;

                read(n: any): any;

                removeAllListeners(ev: any, ...args: any[]): any;

                removeListener(ev: any, fn: any): any;

                resume(): any;

                setEncoding(enc: any): any;

                unpipe(dest: any): any;

                unshift(chunk: any, encoding: any): any;

                wrap(stream: any): any;

                static Duplex: any;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static PassThrough: any;

                static Readable: any;

                static ReadableState: any;

                static Stream: any;

                static Transform: any;

                static Writable: any;

                static addAbortSignal: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static compose: any;

                static defaultMaxListeners: any;

                static destroy: any;

                static errorMonitor: any;

                static finished: any;

                static from: any;

                static getEventListeners: any;

                static init: any;

                static isDisturbed: any;

                static isErrored: any;

                static isReadable: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static pipeline: any;

                static promises: any;

                static setMaxListeners: any;

                static usingDomains: any;

                static wrap: any;

            }

            class Stream {
                constructor(opts: any);

                pipe(dest: any, options: any): any;

                static Duplex: any;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static PassThrough: any;

                static Readable: any;

                static Stream: any;

                static Transform: any;

                static Writable: any;

                static addAbortSignal: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static compose: any;

                static defaultMaxListeners: any;

                static destroy: any;

                static errorMonitor: any;

                static finished: any;

                static getEventListeners: any;

                static init: any;

                static isDisturbed: any;

                static isErrored: any;

                static isReadable: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static pipeline: any;

                static promises: any;

                static setMaxListeners: any;

                static usingDomains: any;

            }

            class Transform {
                constructor(options: any);

                static Duplex: any;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static PassThrough: any;

                static Readable: any;

                static ReadableState: any;

                static Stream: any;

                static Transform: any;

                static Writable: any;

                static addAbortSignal: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static compose: any;

                static defaultMaxListeners: any;

                static destroy: any;

                static errorMonitor: any;

                static finished: any;

                static from: any;

                static getEventListeners: any;

                static init: any;

                static isDisturbed: any;

                static isErrored: any;

                static isReadable: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static pipeline: any;

                static promises: any;

                static setMaxListeners: any;

                static usingDomains: any;

                static wrap: any;

            }

            class WritableState {
                constructor(options: any, stream: any, isDuplex: any);

                getBuffer(): any;

            }

            namespace promises {
                // Too-deep object hierarchy from fs.FileWriteStream.PassThrough.Writable.promises
                const finished: any;

                // Too-deep object hierarchy from fs.FileWriteStream.PassThrough.Writable.promises
                const pipeline: any;

            }

        }

        namespace promises {
            function finished(stream: any, opts: any): any;

            function pipeline(streams: any): any;

        }

    }

    namespace Readable {
        class Duplex {
            constructor(options: any);

            cork(): void;

            end(chunk: any, encoding: any, cb: any): any;

            setDefaultEncoding(encoding: any): any;

            uncork(): void;

            write(chunk: any, encoding: any, cb: any): any;

            static Duplex: any;

            static Readable: any;

            static addAbortSignal(signal: any, stream: any): any;

            static captureRejectionSymbol: any;

            static captureRejections: boolean;

            static compose(streams: any): any;

            static defaultMaxListeners: number;

            static destroy(stream: any, err: any): any;

            static errorMonitor: any;

            static finished(stream: any, options: any, callback: any, ...args: any[]): any;

            static from(body: any): any;

            static getEventListeners(emitterOrTarget: any, type: any): any;

            static init(opts: any): void;

            static isDisturbed(stream: any): any;

            static isErrored(stream: any): any;

            static isReadable(stream: any): any;

            static kMaxEventTargetListeners: any;

            static kMaxEventTargetListenersWarned: any;

            static listenerCount(emitter: any, type: any): any;

            static on(emitter: any, event: any, options: any): any;

            static once(emitter: any, name: any, options: any): any;

            static pipeline(streams: any): any;

            static setMaxListeners(n: any, eventTargets: any): void;

            static usingDomains: boolean;

            static wrap(src: any, options: any): any;

        }

        class EventEmitter {
            constructor(opts: any);

            addListener(type: any, listener: any): any;

            emit(type: any, args: any): any;

            eventNames(): any;

            getMaxListeners(): any;

            listenerCount(type: any): any;

            listeners(type: any): any;

            off(type: any, listener: any): any;

            on(type: any, listener: any): any;

            once(type: any, listener: any): any;

            prependListener(type: any, listener: any): any;

            prependOnceListener(type: any, listener: any): any;

            rawListeners(type: any): any;

            removeAllListeners(type: any, ...args: any[]): any;

            removeListener(type: any, listener: any): any;

            setMaxListeners(n: any): any;

            static EventEmitter: any;

            static captureRejectionSymbol: any;

            static captureRejections: boolean;

            static defaultMaxListeners: number;

            static errorMonitor: any;

            static getEventListeners(emitterOrTarget: any, type: any): any;

            static init(opts: any): void;

            static kMaxEventTargetListeners: any;

            static kMaxEventTargetListenersWarned: any;

            static listenerCount(emitter: any, type: any): any;

            static on(emitter: any, event: any, options: any): any;

            static once(emitter: any, name: any, options: any): any;

            static setMaxListeners(n: any, eventTargets: any): void;

            static usingDomains: boolean;

        }

        class EventEmitterAsyncResource {
            constructor(...args: any[]);

            emit(...args: any[]): void;

            emitDestroy(...args: any[]): void;

            static EventEmitterAsyncResource: any;

            static captureRejectionSymbol: any;

            static captureRejections: boolean;

            static defaultMaxListeners: number;

            static errorMonitor: any;

            static getEventListeners(emitterOrTarget: any, type: any): any;

            static init(opts: any): void;

            static kMaxEventTargetListeners: any;

            static kMaxEventTargetListenersWarned: any;

            static listenerCount(emitter: any, type: any): any;

            static on(emitter: any, event: any, options: any): any;

            static once(emitter: any, name: any, options: any): any;

            static setMaxListeners(n: any, eventTargets: any): void;

            static usingDomains: boolean;

        }

        class PassThrough {
            constructor(options: any);

            static PassThrough: any;

            static Readable: any;

            static addAbortSignal(signal: any, stream: any): any;

            static captureRejectionSymbol: any;

            static captureRejections: boolean;

            static compose(streams: any): any;

            static defaultMaxListeners: number;

            static destroy(stream: any, err: any): any;

            static errorMonitor: any;

            static finished(stream: any, options: any, callback: any, ...args: any[]): any;

            static from(body: any): any;

            static getEventListeners(emitterOrTarget: any, type: any): any;

            static init(opts: any): void;

            static isDisturbed(stream: any): any;

            static isErrored(stream: any): any;

            static isReadable(stream: any): any;

            static kMaxEventTargetListeners: any;

            static kMaxEventTargetListenersWarned: any;

            static listenerCount(emitter: any, type: any): any;

            static on(emitter: any, event: any, options: any): any;

            static once(emitter: any, name: any, options: any): any;

            static pipeline(streams: any): any;

            static setMaxListeners(n: any, eventTargets: any): void;

            static usingDomains: boolean;

            static wrap(src: any, options: any): any;

        }

        class ReadableState {
            constructor(options: any, stream: any, isDuplex: any);

        }

        class Stream {
            constructor(opts: any);

            pipe(dest: any, options: any): any;

            static Readable: any;

            static Stream: any;

            static addAbortSignal(signal: any, stream: any): any;

            static captureRejectionSymbol: any;

            static captureRejections: boolean;

            static compose(streams: any): any;

            static defaultMaxListeners: number;

            static destroy(stream: any, err: any): any;

            static errorMonitor: any;

            static finished(stream: any, options: any, callback: any, ...args: any[]): any;

            static getEventListeners(emitterOrTarget: any, type: any): any;

            static init(opts: any): void;

            static isDisturbed(stream: any): any;

            static isErrored(stream: any): any;

            static isReadable(stream: any): any;

            static kMaxEventTargetListeners: any;

            static kMaxEventTargetListenersWarned: any;

            static listenerCount(emitter: any, type: any): any;

            static on(emitter: any, event: any, options: any): any;

            static once(emitter: any, name: any, options: any): any;

            static pipeline(streams: any): any;

            static setMaxListeners(n: any, eventTargets: any): void;

            static usingDomains: boolean;

        }

        class Transform {
            constructor(options: any);

            static Readable: any;

            static Transform: any;

            static addAbortSignal(signal: any, stream: any): any;

            static captureRejectionSymbol: any;

            static captureRejections: boolean;

            static compose(streams: any): any;

            static defaultMaxListeners: number;

            static destroy(stream: any, err: any): any;

            static errorMonitor: any;

            static finished(stream: any, options: any, callback: any, ...args: any[]): any;

            static from(body: any): any;

            static getEventListeners(emitterOrTarget: any, type: any): any;

            static init(opts: any): void;

            static isDisturbed(stream: any): any;

            static isErrored(stream: any): any;

            static isReadable(stream: any): any;

            static kMaxEventTargetListeners: any;

            static kMaxEventTargetListenersWarned: any;

            static listenerCount(emitter: any, type: any): any;

            static on(emitter: any, event: any, options: any): any;

            static once(emitter: any, name: any, options: any): any;

            static pipeline(streams: any): any;

            static setMaxListeners(n: any, eventTargets: any): void;

            static usingDomains: boolean;

            static wrap(src: any, options: any): any;

        }

        class Writable {
            constructor(options: any);

            cork(): void;

            destroy(err: any, cb: any): any;

            end(chunk: any, encoding: any, cb: any): any;

            pipe(): void;

            setDefaultEncoding(encoding: any): any;

            uncork(): void;

            write(chunk: any, encoding: any, cb: any): any;

            static Readable: any;

            static Writable: any;

            static addAbortSignal(signal: any, stream: any): any;

            static captureRejectionSymbol: any;

            static captureRejections: boolean;

            static compose(streams: any): any;

            static defaultMaxListeners: number;

            static destroy(stream: any, err: any): any;

            static errorMonitor: any;

            static finished(stream: any, options: any, callback: any, ...args: any[]): any;

            static getEventListeners(emitterOrTarget: any, type: any): any;

            static init(opts: any): void;

            static isDisturbed(stream: any): any;

            static isErrored(stream: any): any;

            static isReadable(stream: any): any;

            static kMaxEventTargetListeners: any;

            static kMaxEventTargetListenersWarned: any;

            static listenerCount(emitter: any, type: any): any;

            static on(emitter: any, event: any, options: any): any;

            static once(emitter: any, name: any, options: any): any;

            static pipeline(streams: any): any;

            static setMaxListeners(n: any, eventTargets: any): void;

            static usingDomains: boolean;

        }

        namespace Duplex {
            class EventEmitter {
                constructor(opts: any);

                addListener(type: any, listener: any): any;

                emit(type: any, args: any): any;

                eventNames(): any;

                getMaxListeners(): any;

                listenerCount(type: any): any;

                listeners(type: any): any;

                off(type: any, listener: any): any;

                on(type: any, listener: any): any;

                once(type: any, listener: any): any;

                prependListener(type: any, listener: any): any;

                prependOnceListener(type: any, listener: any): any;

                rawListeners(type: any): any;

                removeAllListeners(type: any, ...args: any[]): any;

                removeListener(type: any, listener: any): any;

                setMaxListeners(n: any): any;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static defaultMaxListeners: any;

                static errorMonitor: any;

                static getEventListeners: any;

                static init: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static setMaxListeners: any;

                static usingDomains: any;

            }

            class EventEmitterAsyncResource {
                constructor(...args: any[]);

                emit(...args: any[]): void;

                emitDestroy(...args: any[]): void;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static defaultMaxListeners: any;

                static errorMonitor: any;

                static getEventListeners: any;

                static init: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static setMaxListeners: any;

                static usingDomains: any;

            }

            class PassThrough {
                constructor(options: any);

                static Duplex: any;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static PassThrough: any;

                static Readable: any;

                static ReadableState: any;

                static Stream: any;

                static Transform: any;

                static Writable: any;

                static addAbortSignal: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static compose: any;

                static defaultMaxListeners: any;

                static destroy: any;

                static errorMonitor: any;

                static finished: any;

                static from: any;

                static getEventListeners: any;

                static init: any;

                static isDisturbed: any;

                static isErrored: any;

                static isReadable: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static pipeline: any;

                static promises: any;

                static setMaxListeners: any;

                static usingDomains: any;

                static wrap: any;

            }

            class ReadableState {
                constructor(options: any, stream: any, isDuplex: any);

            }

            class Stream {
                constructor(opts: any);

                pipe(dest: any, options: any): any;

                static Duplex: any;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static PassThrough: any;

                static Readable: any;

                static Stream: any;

                static Transform: any;

                static Writable: any;

                static addAbortSignal: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static compose: any;

                static defaultMaxListeners: any;

                static destroy: any;

                static errorMonitor: any;

                static finished: any;

                static getEventListeners: any;

                static init: any;

                static isDisturbed: any;

                static isErrored: any;

                static isReadable: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static pipeline: any;

                static promises: any;

                static setMaxListeners: any;

                static usingDomains: any;

            }

            class Transform {
                constructor(options: any);

                static Duplex: any;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static PassThrough: any;

                static Readable: any;

                static ReadableState: any;

                static Stream: any;

                static Transform: any;

                static Writable: any;

                static addAbortSignal: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static compose: any;

                static defaultMaxListeners: any;

                static destroy: any;

                static errorMonitor: any;

                static finished: any;

                static from: any;

                static getEventListeners: any;

                static init: any;

                static isDisturbed: any;

                static isErrored: any;

                static isReadable: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static pipeline: any;

                static promises: any;

                static setMaxListeners: any;

                static usingDomains: any;

                static wrap: any;

            }

            class Writable {
                constructor(options: any);

                cork(): void;

                destroy(err: any, cb: any): any;

                end(chunk: any, encoding: any, cb: any): any;

                pipe(): void;

                setDefaultEncoding(encoding: any): any;

                uncork(): void;

                write(chunk: any, encoding: any, cb: any): any;

                static Duplex: any;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static PassThrough: any;

                static Readable: any;

                static Stream: any;

                static Transform: any;

                static Writable: any;

                static WritableState: any;

                static addAbortSignal: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static compose: any;

                static defaultMaxListeners: any;

                static destroy: any;

                static errorMonitor: any;

                static finished: any;

                static getEventListeners: any;

                static init: any;

                static isDisturbed: any;

                static isErrored: any;

                static isReadable: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static pipeline: any;

                static promises: any;

                static setMaxListeners: any;

                static usingDomains: any;

            }

            namespace promises {
                // Too-deep object hierarchy from fs.FileWriteStream.Readable.Duplex.promises
                const finished: any;

                // Too-deep object hierarchy from fs.FileWriteStream.Readable.Duplex.promises
                const pipeline: any;

            }

        }

        namespace EventEmitter {
            class EventEmitterAsyncResource {
                constructor(...args: any[]);

                emit(...args: any[]): void;

                emitDestroy(...args: any[]): void;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static defaultMaxListeners: any;

                static errorMonitor: any;

                static getEventListeners: any;

                static init: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static setMaxListeners: any;

                static usingDomains: any;

            }

        }

        namespace EventEmitterAsyncResource {
            class EventEmitter {
                constructor(opts: any);

                addListener(type: any, listener: any): any;

                emit(type: any, args: any): any;

                eventNames(): any;

                getMaxListeners(): any;

                listenerCount(type: any): any;

                listeners(type: any): any;

                off(type: any, listener: any): any;

                on(type: any, listener: any): any;

                once(type: any, listener: any): any;

                prependListener(type: any, listener: any): any;

                prependOnceListener(type: any, listener: any): any;

                rawListeners(type: any): any;

                removeAllListeners(type: any, ...args: any[]): any;

                removeListener(type: any, listener: any): any;

                setMaxListeners(n: any): any;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static defaultMaxListeners: any;

                static errorMonitor: any;

                static getEventListeners: any;

                static init: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static setMaxListeners: any;

                static usingDomains: any;

            }

        }

        namespace PassThrough {
            class Duplex {
                constructor(options: any);

                cork(): void;

                end(chunk: any, encoding: any, cb: any): any;

                setDefaultEncoding(encoding: any): any;

                uncork(): void;

                write(chunk: any, encoding: any, cb: any): any;

                static Duplex: any;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static PassThrough: any;

                static Readable: any;

                static ReadableState: any;

                static Stream: any;

                static Transform: any;

                static Writable: any;

                static addAbortSignal: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static compose: any;

                static defaultMaxListeners: any;

                static destroy: any;

                static errorMonitor: any;

                static finished: any;

                static from: any;

                static getEventListeners: any;

                static init: any;

                static isDisturbed: any;

                static isErrored: any;

                static isReadable: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static pipeline: any;

                static promises: any;

                static setMaxListeners: any;

                static usingDomains: any;

                static wrap: any;

            }

            class EventEmitter {
                constructor(opts: any);

                addListener(type: any, listener: any): any;

                emit(type: any, args: any): any;

                eventNames(): any;

                getMaxListeners(): any;

                listenerCount(type: any): any;

                listeners(type: any): any;

                off(type: any, listener: any): any;

                on(type: any, listener: any): any;

                once(type: any, listener: any): any;

                prependListener(type: any, listener: any): any;

                prependOnceListener(type: any, listener: any): any;

                rawListeners(type: any): any;

                removeAllListeners(type: any, ...args: any[]): any;

                removeListener(type: any, listener: any): any;

                setMaxListeners(n: any): any;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static defaultMaxListeners: any;

                static errorMonitor: any;

                static getEventListeners: any;

                static init: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static setMaxListeners: any;

                static usingDomains: any;

            }

            class EventEmitterAsyncResource {
                constructor(...args: any[]);

                emit(...args: any[]): void;

                emitDestroy(...args: any[]): void;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static defaultMaxListeners: any;

                static errorMonitor: any;

                static getEventListeners: any;

                static init: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static setMaxListeners: any;

                static usingDomains: any;

            }

            class ReadableState {
                constructor(options: any, stream: any, isDuplex: any);

            }

            class Stream {
                constructor(opts: any);

                pipe(dest: any, options: any): any;

                static Duplex: any;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static PassThrough: any;

                static Readable: any;

                static Stream: any;

                static Transform: any;

                static Writable: any;

                static addAbortSignal: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static compose: any;

                static defaultMaxListeners: any;

                static destroy: any;

                static errorMonitor: any;

                static finished: any;

                static getEventListeners: any;

                static init: any;

                static isDisturbed: any;

                static isErrored: any;

                static isReadable: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static pipeline: any;

                static promises: any;

                static setMaxListeners: any;

                static usingDomains: any;

            }

            class Transform {
                constructor(options: any);

                static Duplex: any;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static PassThrough: any;

                static Readable: any;

                static ReadableState: any;

                static Stream: any;

                static Transform: any;

                static Writable: any;

                static addAbortSignal: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static compose: any;

                static defaultMaxListeners: any;

                static destroy: any;

                static errorMonitor: any;

                static finished: any;

                static from: any;

                static getEventListeners: any;

                static init: any;

                static isDisturbed: any;

                static isErrored: any;

                static isReadable: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static pipeline: any;

                static promises: any;

                static setMaxListeners: any;

                static usingDomains: any;

                static wrap: any;

            }

            class Writable {
                constructor(options: any);

                cork(): void;

                destroy(err: any, cb: any): any;

                end(chunk: any, encoding: any, cb: any): any;

                pipe(): void;

                setDefaultEncoding(encoding: any): any;

                uncork(): void;

                write(chunk: any, encoding: any, cb: any): any;

                static Duplex: any;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static PassThrough: any;

                static Readable: any;

                static Stream: any;

                static Transform: any;

                static Writable: any;

                static WritableState: any;

                static addAbortSignal: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static compose: any;

                static defaultMaxListeners: any;

                static destroy: any;

                static errorMonitor: any;

                static finished: any;

                static getEventListeners: any;

                static init: any;

                static isDisturbed: any;

                static isErrored: any;

                static isReadable: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static pipeline: any;

                static promises: any;

                static setMaxListeners: any;

                static usingDomains: any;

            }

            namespace promises {
                // Too-deep object hierarchy from fs.FileWriteStream.Readable.PassThrough.promises
                const finished: any;

                // Too-deep object hierarchy from fs.FileWriteStream.Readable.PassThrough.promises
                const pipeline: any;

            }

        }

        namespace Stream {
            class Duplex {
                constructor(options: any);

                cork(): void;

                end(chunk: any, encoding: any, cb: any): any;

                setDefaultEncoding(encoding: any): any;

                uncork(): void;

                write(chunk: any, encoding: any, cb: any): any;

                static Duplex: any;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static PassThrough: any;

                static Readable: any;

                static ReadableState: any;

                static Stream: any;

                static Transform: any;

                static Writable: any;

                static addAbortSignal: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static compose: any;

                static defaultMaxListeners: any;

                static destroy: any;

                static errorMonitor: any;

                static finished: any;

                static from: any;

                static getEventListeners: any;

                static init: any;

                static isDisturbed: any;

                static isErrored: any;

                static isReadable: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static pipeline: any;

                static promises: any;

                static setMaxListeners: any;

                static usingDomains: any;

                static wrap: any;

            }

            class EventEmitter {
                constructor(opts: any);

                addListener(type: any, listener: any): any;

                emit(type: any, args: any): any;

                eventNames(): any;

                getMaxListeners(): any;

                listenerCount(type: any): any;

                listeners(type: any): any;

                off(type: any, listener: any): any;

                on(type: any, listener: any): any;

                once(type: any, listener: any): any;

                prependListener(type: any, listener: any): any;

                prependOnceListener(type: any, listener: any): any;

                rawListeners(type: any): any;

                removeAllListeners(type: any, ...args: any[]): any;

                removeListener(type: any, listener: any): any;

                setMaxListeners(n: any): any;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static defaultMaxListeners: any;

                static errorMonitor: any;

                static getEventListeners: any;

                static init: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static setMaxListeners: any;

                static usingDomains: any;

            }

            class EventEmitterAsyncResource {
                constructor(...args: any[]);

                emit(...args: any[]): void;

                emitDestroy(...args: any[]): void;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static defaultMaxListeners: any;

                static errorMonitor: any;

                static getEventListeners: any;

                static init: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static setMaxListeners: any;

                static usingDomains: any;

            }

            class PassThrough {
                constructor(options: any);

                static Duplex: any;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static PassThrough: any;

                static Readable: any;

                static ReadableState: any;

                static Stream: any;

                static Transform: any;

                static Writable: any;

                static addAbortSignal: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static compose: any;

                static defaultMaxListeners: any;

                static destroy: any;

                static errorMonitor: any;

                static finished: any;

                static from: any;

                static getEventListeners: any;

                static init: any;

                static isDisturbed: any;

                static isErrored: any;

                static isReadable: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static pipeline: any;

                static promises: any;

                static setMaxListeners: any;

                static usingDomains: any;

                static wrap: any;

            }

            class Transform {
                constructor(options: any);

                static Duplex: any;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static PassThrough: any;

                static Readable: any;

                static ReadableState: any;

                static Stream: any;

                static Transform: any;

                static Writable: any;

                static addAbortSignal: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static compose: any;

                static defaultMaxListeners: any;

                static destroy: any;

                static errorMonitor: any;

                static finished: any;

                static from: any;

                static getEventListeners: any;

                static init: any;

                static isDisturbed: any;

                static isErrored: any;

                static isReadable: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static pipeline: any;

                static promises: any;

                static setMaxListeners: any;

                static usingDomains: any;

                static wrap: any;

            }

            class Writable {
                constructor(options: any);

                cork(): void;

                destroy(err: any, cb: any): any;

                end(chunk: any, encoding: any, cb: any): any;

                pipe(): void;

                setDefaultEncoding(encoding: any): any;

                uncork(): void;

                write(chunk: any, encoding: any, cb: any): any;

                static Duplex: any;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static PassThrough: any;

                static Readable: any;

                static Stream: any;

                static Transform: any;

                static Writable: any;

                static WritableState: any;

                static addAbortSignal: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static compose: any;

                static defaultMaxListeners: any;

                static destroy: any;

                static errorMonitor: any;

                static finished: any;

                static getEventListeners: any;

                static init: any;

                static isDisturbed: any;

                static isErrored: any;

                static isReadable: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static pipeline: any;

                static promises: any;

                static setMaxListeners: any;

                static usingDomains: any;

            }

            namespace promises {
                // Too-deep object hierarchy from fs.FileWriteStream.Readable.Stream.promises
                const finished: any;

                // Too-deep object hierarchy from fs.FileWriteStream.Readable.Stream.promises
                const pipeline: any;

            }

        }

        namespace Transform {
            class Duplex {
                constructor(options: any);

                cork(): void;

                end(chunk: any, encoding: any, cb: any): any;

                setDefaultEncoding(encoding: any): any;

                uncork(): void;

                write(chunk: any, encoding: any, cb: any): any;

                static Duplex: any;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static PassThrough: any;

                static Readable: any;

                static ReadableState: any;

                static Stream: any;

                static Transform: any;

                static Writable: any;

                static addAbortSignal: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static compose: any;

                static defaultMaxListeners: any;

                static destroy: any;

                static errorMonitor: any;

                static finished: any;

                static from: any;

                static getEventListeners: any;

                static init: any;

                static isDisturbed: any;

                static isErrored: any;

                static isReadable: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static pipeline: any;

                static promises: any;

                static setMaxListeners: any;

                static usingDomains: any;

                static wrap: any;

            }

            class EventEmitter {
                constructor(opts: any);

                addListener(type: any, listener: any): any;

                emit(type: any, args: any): any;

                eventNames(): any;

                getMaxListeners(): any;

                listenerCount(type: any): any;

                listeners(type: any): any;

                off(type: any, listener: any): any;

                on(type: any, listener: any): any;

                once(type: any, listener: any): any;

                prependListener(type: any, listener: any): any;

                prependOnceListener(type: any, listener: any): any;

                rawListeners(type: any): any;

                removeAllListeners(type: any, ...args: any[]): any;

                removeListener(type: any, listener: any): any;

                setMaxListeners(n: any): any;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static defaultMaxListeners: any;

                static errorMonitor: any;

                static getEventListeners: any;

                static init: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static setMaxListeners: any;

                static usingDomains: any;

            }

            class EventEmitterAsyncResource {
                constructor(...args: any[]);

                emit(...args: any[]): void;

                emitDestroy(...args: any[]): void;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static defaultMaxListeners: any;

                static errorMonitor: any;

                static getEventListeners: any;

                static init: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static setMaxListeners: any;

                static usingDomains: any;

            }

            class PassThrough {
                constructor(options: any);

                static Duplex: any;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static PassThrough: any;

                static Readable: any;

                static ReadableState: any;

                static Stream: any;

                static Transform: any;

                static Writable: any;

                static addAbortSignal: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static compose: any;

                static defaultMaxListeners: any;

                static destroy: any;

                static errorMonitor: any;

                static finished: any;

                static from: any;

                static getEventListeners: any;

                static init: any;

                static isDisturbed: any;

                static isErrored: any;

                static isReadable: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static pipeline: any;

                static promises: any;

                static setMaxListeners: any;

                static usingDomains: any;

                static wrap: any;

            }

            class ReadableState {
                constructor(options: any, stream: any, isDuplex: any);

            }

            class Stream {
                constructor(opts: any);

                pipe(dest: any, options: any): any;

                static Duplex: any;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static PassThrough: any;

                static Readable: any;

                static Stream: any;

                static Transform: any;

                static Writable: any;

                static addAbortSignal: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static compose: any;

                static defaultMaxListeners: any;

                static destroy: any;

                static errorMonitor: any;

                static finished: any;

                static getEventListeners: any;

                static init: any;

                static isDisturbed: any;

                static isErrored: any;

                static isReadable: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static pipeline: any;

                static promises: any;

                static setMaxListeners: any;

                static usingDomains: any;

            }

            class Writable {
                constructor(options: any);

                cork(): void;

                destroy(err: any, cb: any): any;

                end(chunk: any, encoding: any, cb: any): any;

                pipe(): void;

                setDefaultEncoding(encoding: any): any;

                uncork(): void;

                write(chunk: any, encoding: any, cb: any): any;

                static Duplex: any;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static PassThrough: any;

                static Readable: any;

                static Stream: any;

                static Transform: any;

                static Writable: any;

                static WritableState: any;

                static addAbortSignal: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static compose: any;

                static defaultMaxListeners: any;

                static destroy: any;

                static errorMonitor: any;

                static finished: any;

                static getEventListeners: any;

                static init: any;

                static isDisturbed: any;

                static isErrored: any;

                static isReadable: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static pipeline: any;

                static promises: any;

                static setMaxListeners: any;

                static usingDomains: any;

            }

            namespace promises {
                // Too-deep object hierarchy from fs.FileWriteStream.Readable.Transform.promises
                const finished: any;

                // Too-deep object hierarchy from fs.FileWriteStream.Readable.Transform.promises
                const pipeline: any;

            }

        }

        namespace Writable {
            class Duplex {
                constructor(options: any);

                cork(): void;

                end(chunk: any, encoding: any, cb: any): any;

                setDefaultEncoding(encoding: any): any;

                uncork(): void;

                write(chunk: any, encoding: any, cb: any): any;

                static Duplex: any;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static PassThrough: any;

                static Readable: any;

                static ReadableState: any;

                static Stream: any;

                static Transform: any;

                static Writable: any;

                static addAbortSignal: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static compose: any;

                static defaultMaxListeners: any;

                static destroy: any;

                static errorMonitor: any;

                static finished: any;

                static from: any;

                static getEventListeners: any;

                static init: any;

                static isDisturbed: any;

                static isErrored: any;

                static isReadable: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static pipeline: any;

                static promises: any;

                static setMaxListeners: any;

                static usingDomains: any;

                static wrap: any;

            }

            class EventEmitter {
                constructor(opts: any);

                addListener(type: any, listener: any): any;

                emit(type: any, args: any): any;

                eventNames(): any;

                getMaxListeners(): any;

                listenerCount(type: any): any;

                listeners(type: any): any;

                off(type: any, listener: any): any;

                on(type: any, listener: any): any;

                once(type: any, listener: any): any;

                prependListener(type: any, listener: any): any;

                prependOnceListener(type: any, listener: any): any;

                rawListeners(type: any): any;

                removeAllListeners(type: any, ...args: any[]): any;

                removeListener(type: any, listener: any): any;

                setMaxListeners(n: any): any;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static defaultMaxListeners: any;

                static errorMonitor: any;

                static getEventListeners: any;

                static init: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static setMaxListeners: any;

                static usingDomains: any;

            }

            class EventEmitterAsyncResource {
                constructor(...args: any[]);

                emit(...args: any[]): void;

                emitDestroy(...args: any[]): void;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static defaultMaxListeners: any;

                static errorMonitor: any;

                static getEventListeners: any;

                static init: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static setMaxListeners: any;

                static usingDomains: any;

            }

            class PassThrough {
                constructor(options: any);

                static Duplex: any;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static PassThrough: any;

                static Readable: any;

                static ReadableState: any;

                static Stream: any;

                static Transform: any;

                static Writable: any;

                static addAbortSignal: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static compose: any;

                static defaultMaxListeners: any;

                static destroy: any;

                static errorMonitor: any;

                static finished: any;

                static from: any;

                static getEventListeners: any;

                static init: any;

                static isDisturbed: any;

                static isErrored: any;

                static isReadable: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static pipeline: any;

                static promises: any;

                static setMaxListeners: any;

                static usingDomains: any;

                static wrap: any;

            }

            class Stream {
                constructor(opts: any);

                pipe(dest: any, options: any): any;

                static Duplex: any;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static PassThrough: any;

                static Readable: any;

                static Stream: any;

                static Transform: any;

                static Writable: any;

                static addAbortSignal: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static compose: any;

                static defaultMaxListeners: any;

                static destroy: any;

                static errorMonitor: any;

                static finished: any;

                static getEventListeners: any;

                static init: any;

                static isDisturbed: any;

                static isErrored: any;

                static isReadable: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static pipeline: any;

                static promises: any;

                static setMaxListeners: any;

                static usingDomains: any;

            }

            class Transform {
                constructor(options: any);

                static Duplex: any;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static PassThrough: any;

                static Readable: any;

                static ReadableState: any;

                static Stream: any;

                static Transform: any;

                static Writable: any;

                static addAbortSignal: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static compose: any;

                static defaultMaxListeners: any;

                static destroy: any;

                static errorMonitor: any;

                static finished: any;

                static from: any;

                static getEventListeners: any;

                static init: any;

                static isDisturbed: any;

                static isErrored: any;

                static isReadable: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static pipeline: any;

                static promises: any;

                static setMaxListeners: any;

                static usingDomains: any;

                static wrap: any;

            }

            class WritableState {
                constructor(options: any, stream: any, isDuplex: any);

                getBuffer(): any;

            }

            namespace promises {
                // Too-deep object hierarchy from fs.FileWriteStream.Readable.Writable.promises
                const finished: any;

                // Too-deep object hierarchy from fs.FileWriteStream.Readable.Writable.promises
                const pipeline: any;

            }

        }

        namespace promises {
            function finished(stream: any, opts: any): any;

            function pipeline(streams: any): any;

        }

    }

    namespace Stream {
        class Duplex {
            constructor(options: any);

            cork(): void;

            end(chunk: any, encoding: any, cb: any): any;

            setDefaultEncoding(encoding: any): any;

            uncork(): void;

            write(chunk: any, encoding: any, cb: any): any;

            static Duplex: any;

            static Stream: any;

            static addAbortSignal(signal: any, stream: any): any;

            static captureRejectionSymbol: any;

            static captureRejections: boolean;

            static compose(streams: any): any;

            static defaultMaxListeners: number;

            static destroy(stream: any, err: any): any;

            static errorMonitor: any;

            static finished(stream: any, options: any, callback: any, ...args: any[]): any;

            static from(body: any): any;

            static getEventListeners(emitterOrTarget: any, type: any): any;

            static init(opts: any): void;

            static isDisturbed(stream: any): any;

            static isErrored(stream: any): any;

            static isReadable(stream: any): any;

            static kMaxEventTargetListeners: any;

            static kMaxEventTargetListenersWarned: any;

            static listenerCount(emitter: any, type: any): any;

            static on(emitter: any, event: any, options: any): any;

            static once(emitter: any, name: any, options: any): any;

            static pipeline(streams: any): any;

            static setMaxListeners(n: any, eventTargets: any): void;

            static usingDomains: boolean;

            static wrap(src: any, options: any): any;

        }

        class EventEmitter {
            constructor(opts: any);

            addListener(type: any, listener: any): any;

            emit(type: any, args: any): any;

            eventNames(): any;

            getMaxListeners(): any;

            listenerCount(type: any): any;

            listeners(type: any): any;

            off(type: any, listener: any): any;

            on(type: any, listener: any): any;

            once(type: any, listener: any): any;

            prependListener(type: any, listener: any): any;

            prependOnceListener(type: any, listener: any): any;

            rawListeners(type: any): any;

            removeAllListeners(type: any, ...args: any[]): any;

            removeListener(type: any, listener: any): any;

            setMaxListeners(n: any): any;

            static EventEmitter: any;

            static captureRejectionSymbol: any;

            static captureRejections: boolean;

            static defaultMaxListeners: number;

            static errorMonitor: any;

            static getEventListeners(emitterOrTarget: any, type: any): any;

            static init(opts: any): void;

            static kMaxEventTargetListeners: any;

            static kMaxEventTargetListenersWarned: any;

            static listenerCount(emitter: any, type: any): any;

            static on(emitter: any, event: any, options: any): any;

            static once(emitter: any, name: any, options: any): any;

            static setMaxListeners(n: any, eventTargets: any): void;

            static usingDomains: boolean;

        }

        class EventEmitterAsyncResource {
            constructor(...args: any[]);

            emit(...args: any[]): void;

            emitDestroy(...args: any[]): void;

            static EventEmitterAsyncResource: any;

            static captureRejectionSymbol: any;

            static captureRejections: boolean;

            static defaultMaxListeners: number;

            static errorMonitor: any;

            static getEventListeners(emitterOrTarget: any, type: any): any;

            static init(opts: any): void;

            static kMaxEventTargetListeners: any;

            static kMaxEventTargetListenersWarned: any;

            static listenerCount(emitter: any, type: any): any;

            static on(emitter: any, event: any, options: any): any;

            static once(emitter: any, name: any, options: any): any;

            static setMaxListeners(n: any, eventTargets: any): void;

            static usingDomains: boolean;

        }

        class PassThrough {
            constructor(options: any);

            static PassThrough: any;

            static Stream: any;

            static addAbortSignal(signal: any, stream: any): any;

            static captureRejectionSymbol: any;

            static captureRejections: boolean;

            static compose(streams: any): any;

            static defaultMaxListeners: number;

            static destroy(stream: any, err: any): any;

            static errorMonitor: any;

            static finished(stream: any, options: any, callback: any, ...args: any[]): any;

            static from(body: any): any;

            static getEventListeners(emitterOrTarget: any, type: any): any;

            static init(opts: any): void;

            static isDisturbed(stream: any): any;

            static isErrored(stream: any): any;

            static isReadable(stream: any): any;

            static kMaxEventTargetListeners: any;

            static kMaxEventTargetListenersWarned: any;

            static listenerCount(emitter: any, type: any): any;

            static on(emitter: any, event: any, options: any): any;

            static once(emitter: any, name: any, options: any): any;

            static pipeline(streams: any): any;

            static setMaxListeners(n: any, eventTargets: any): void;

            static usingDomains: boolean;

            static wrap(src: any, options: any): any;

        }

        class Readable {
            constructor(options: any);

            addListener(ev: any, fn: any): any;

            destroy(err: any, cb: any): any;

            filter(args: any): any;

            isPaused(): any;

            iterator(options: any): any;

            map(args: any): any;

            off(ev: any, fn: any): any;

            on(ev: any, fn: any): any;

            pause(): any;

            pipe(dest: any, pipeOpts: any): any;

            push(chunk: any, encoding: any): any;

            read(n: any): any;

            removeAllListeners(ev: any, ...args: any[]): any;

            removeListener(ev: any, fn: any): any;

            resume(): any;

            setEncoding(enc: any): any;

            unpipe(dest: any): any;

            unshift(chunk: any, encoding: any): any;

            wrap(stream: any): any;

            static Readable: any;

            static Stream: any;

            static addAbortSignal(signal: any, stream: any): any;

            static captureRejectionSymbol: any;

            static captureRejections: boolean;

            static compose(streams: any): any;

            static defaultMaxListeners: number;

            static destroy(stream: any, err: any): any;

            static errorMonitor: any;

            static finished(stream: any, options: any, callback: any, ...args: any[]): any;

            static from(iterable: any, opts: any): any;

            static getEventListeners(emitterOrTarget: any, type: any): any;

            static init(opts: any): void;

            static isDisturbed(stream: any): any;

            static isErrored(stream: any): any;

            static isReadable(stream: any): any;

            static kMaxEventTargetListeners: any;

            static kMaxEventTargetListenersWarned: any;

            static listenerCount(emitter: any, type: any): any;

            static on(emitter: any, event: any, options: any): any;

            static once(emitter: any, name: any, options: any): any;

            static pipeline(streams: any): any;

            static setMaxListeners(n: any, eventTargets: any): void;

            static usingDomains: boolean;

            static wrap(src: any, options: any): any;

        }

        class Transform {
            constructor(options: any);

            static Stream: any;

            static Transform: any;

            static addAbortSignal(signal: any, stream: any): any;

            static captureRejectionSymbol: any;

            static captureRejections: boolean;

            static compose(streams: any): any;

            static defaultMaxListeners: number;

            static destroy(stream: any, err: any): any;

            static errorMonitor: any;

            static finished(stream: any, options: any, callback: any, ...args: any[]): any;

            static from(body: any): any;

            static getEventListeners(emitterOrTarget: any, type: any): any;

            static init(opts: any): void;

            static isDisturbed(stream: any): any;

            static isErrored(stream: any): any;

            static isReadable(stream: any): any;

            static kMaxEventTargetListeners: any;

            static kMaxEventTargetListenersWarned: any;

            static listenerCount(emitter: any, type: any): any;

            static on(emitter: any, event: any, options: any): any;

            static once(emitter: any, name: any, options: any): any;

            static pipeline(streams: any): any;

            static setMaxListeners(n: any, eventTargets: any): void;

            static usingDomains: boolean;

            static wrap(src: any, options: any): any;

        }

        class Writable {
            constructor(options: any);

            cork(): void;

            destroy(err: any, cb: any): any;

            end(chunk: any, encoding: any, cb: any): any;

            pipe(): void;

            setDefaultEncoding(encoding: any): any;

            uncork(): void;

            write(chunk: any, encoding: any, cb: any): any;

            static Stream: any;

            static Writable: any;

            static addAbortSignal(signal: any, stream: any): any;

            static captureRejectionSymbol: any;

            static captureRejections: boolean;

            static compose(streams: any): any;

            static defaultMaxListeners: number;

            static destroy(stream: any, err: any): any;

            static errorMonitor: any;

            static finished(stream: any, options: any, callback: any, ...args: any[]): any;

            static getEventListeners(emitterOrTarget: any, type: any): any;

            static init(opts: any): void;

            static isDisturbed(stream: any): any;

            static isErrored(stream: any): any;

            static isReadable(stream: any): any;

            static kMaxEventTargetListeners: any;

            static kMaxEventTargetListenersWarned: any;

            static listenerCount(emitter: any, type: any): any;

            static on(emitter: any, event: any, options: any): any;

            static once(emitter: any, name: any, options: any): any;

            static pipeline(streams: any): any;

            static setMaxListeners(n: any, eventTargets: any): void;

            static usingDomains: boolean;

        }

        namespace Duplex {
            class EventEmitter {
                constructor(opts: any);

                addListener(type: any, listener: any): any;

                emit(type: any, args: any): any;

                eventNames(): any;

                getMaxListeners(): any;

                listenerCount(type: any): any;

                listeners(type: any): any;

                off(type: any, listener: any): any;

                on(type: any, listener: any): any;

                once(type: any, listener: any): any;

                prependListener(type: any, listener: any): any;

                prependOnceListener(type: any, listener: any): any;

                rawListeners(type: any): any;

                removeAllListeners(type: any, ...args: any[]): any;

                removeListener(type: any, listener: any): any;

                setMaxListeners(n: any): any;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static defaultMaxListeners: any;

                static errorMonitor: any;

                static getEventListeners: any;

                static init: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static setMaxListeners: any;

                static usingDomains: any;

            }

            class EventEmitterAsyncResource {
                constructor(...args: any[]);

                emit(...args: any[]): void;

                emitDestroy(...args: any[]): void;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static defaultMaxListeners: any;

                static errorMonitor: any;

                static getEventListeners: any;

                static init: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static setMaxListeners: any;

                static usingDomains: any;

            }

            class PassThrough {
                constructor(options: any);

                static Duplex: any;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static PassThrough: any;

                static Readable: any;

                static ReadableState: any;

                static Stream: any;

                static Transform: any;

                static Writable: any;

                static addAbortSignal: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static compose: any;

                static defaultMaxListeners: any;

                static destroy: any;

                static errorMonitor: any;

                static finished: any;

                static from: any;

                static getEventListeners: any;

                static init: any;

                static isDisturbed: any;

                static isErrored: any;

                static isReadable: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static pipeline: any;

                static promises: any;

                static setMaxListeners: any;

                static usingDomains: any;

                static wrap: any;

            }

            class Readable {
                constructor(options: any);

                addListener(ev: any, fn: any): any;

                destroy(err: any, cb: any): any;

                filter(args: any): any;

                isPaused(): any;

                iterator(options: any): any;

                map(args: any): any;

                off(ev: any, fn: any): any;

                on(ev: any, fn: any): any;

                pause(): any;

                pipe(dest: any, pipeOpts: any): any;

                push(chunk: any, encoding: any): any;

                read(n: any): any;

                removeAllListeners(ev: any, ...args: any[]): any;

                removeListener(ev: any, fn: any): any;

                resume(): any;

                setEncoding(enc: any): any;

                unpipe(dest: any): any;

                unshift(chunk: any, encoding: any): any;

                wrap(stream: any): any;

                static Duplex: any;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static PassThrough: any;

                static Readable: any;

                static ReadableState: any;

                static Stream: any;

                static Transform: any;

                static Writable: any;

                static addAbortSignal: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static compose: any;

                static defaultMaxListeners: any;

                static destroy: any;

                static errorMonitor: any;

                static finished: any;

                static from: any;

                static getEventListeners: any;

                static init: any;

                static isDisturbed: any;

                static isErrored: any;

                static isReadable: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static pipeline: any;

                static promises: any;

                static setMaxListeners: any;

                static usingDomains: any;

                static wrap: any;

            }

            class ReadableState {
                constructor(options: any, stream: any, isDuplex: any);

            }

            class Transform {
                constructor(options: any);

                static Duplex: any;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static PassThrough: any;

                static Readable: any;

                static ReadableState: any;

                static Stream: any;

                static Transform: any;

                static Writable: any;

                static addAbortSignal: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static compose: any;

                static defaultMaxListeners: any;

                static destroy: any;

                static errorMonitor: any;

                static finished: any;

                static from: any;

                static getEventListeners: any;

                static init: any;

                static isDisturbed: any;

                static isErrored: any;

                static isReadable: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static pipeline: any;

                static promises: any;

                static setMaxListeners: any;

                static usingDomains: any;

                static wrap: any;

            }

            class Writable {
                constructor(options: any);

                cork(): void;

                destroy(err: any, cb: any): any;

                end(chunk: any, encoding: any, cb: any): any;

                pipe(): void;

                setDefaultEncoding(encoding: any): any;

                uncork(): void;

                write(chunk: any, encoding: any, cb: any): any;

                static Duplex: any;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static PassThrough: any;

                static Readable: any;

                static Stream: any;

                static Transform: any;

                static Writable: any;

                static WritableState: any;

                static addAbortSignal: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static compose: any;

                static defaultMaxListeners: any;

                static destroy: any;

                static errorMonitor: any;

                static finished: any;

                static getEventListeners: any;

                static init: any;

                static isDisturbed: any;

                static isErrored: any;

                static isReadable: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static pipeline: any;

                static promises: any;

                static setMaxListeners: any;

                static usingDomains: any;

            }

            namespace promises {
                // Too-deep object hierarchy from fs.FileWriteStream.Stream.Duplex.promises
                const finished: any;

                // Too-deep object hierarchy from fs.FileWriteStream.Stream.Duplex.promises
                const pipeline: any;

            }

        }

        namespace EventEmitter {
            class EventEmitterAsyncResource {
                constructor(...args: any[]);

                emit(...args: any[]): void;

                emitDestroy(...args: any[]): void;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static defaultMaxListeners: any;

                static errorMonitor: any;

                static getEventListeners: any;

                static init: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static setMaxListeners: any;

                static usingDomains: any;

            }

        }

        namespace EventEmitterAsyncResource {
            class EventEmitter {
                constructor(opts: any);

                addListener(type: any, listener: any): any;

                emit(type: any, args: any): any;

                eventNames(): any;

                getMaxListeners(): any;

                listenerCount(type: any): any;

                listeners(type: any): any;

                off(type: any, listener: any): any;

                on(type: any, listener: any): any;

                once(type: any, listener: any): any;

                prependListener(type: any, listener: any): any;

                prependOnceListener(type: any, listener: any): any;

                rawListeners(type: any): any;

                removeAllListeners(type: any, ...args: any[]): any;

                removeListener(type: any, listener: any): any;

                setMaxListeners(n: any): any;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static defaultMaxListeners: any;

                static errorMonitor: any;

                static getEventListeners: any;

                static init: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static setMaxListeners: any;

                static usingDomains: any;

            }

        }

        namespace PassThrough {
            class Duplex {
                constructor(options: any);

                cork(): void;

                end(chunk: any, encoding: any, cb: any): any;

                setDefaultEncoding(encoding: any): any;

                uncork(): void;

                write(chunk: any, encoding: any, cb: any): any;

                static Duplex: any;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static PassThrough: any;

                static Readable: any;

                static ReadableState: any;

                static Stream: any;

                static Transform: any;

                static Writable: any;

                static addAbortSignal: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static compose: any;

                static defaultMaxListeners: any;

                static destroy: any;

                static errorMonitor: any;

                static finished: any;

                static from: any;

                static getEventListeners: any;

                static init: any;

                static isDisturbed: any;

                static isErrored: any;

                static isReadable: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static pipeline: any;

                static promises: any;

                static setMaxListeners: any;

                static usingDomains: any;

                static wrap: any;

            }

            class EventEmitter {
                constructor(opts: any);

                addListener(type: any, listener: any): any;

                emit(type: any, args: any): any;

                eventNames(): any;

                getMaxListeners(): any;

                listenerCount(type: any): any;

                listeners(type: any): any;

                off(type: any, listener: any): any;

                on(type: any, listener: any): any;

                once(type: any, listener: any): any;

                prependListener(type: any, listener: any): any;

                prependOnceListener(type: any, listener: any): any;

                rawListeners(type: any): any;

                removeAllListeners(type: any, ...args: any[]): any;

                removeListener(type: any, listener: any): any;

                setMaxListeners(n: any): any;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static defaultMaxListeners: any;

                static errorMonitor: any;

                static getEventListeners: any;

                static init: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static setMaxListeners: any;

                static usingDomains: any;

            }

            class EventEmitterAsyncResource {
                constructor(...args: any[]);

                emit(...args: any[]): void;

                emitDestroy(...args: any[]): void;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static defaultMaxListeners: any;

                static errorMonitor: any;

                static getEventListeners: any;

                static init: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static setMaxListeners: any;

                static usingDomains: any;

            }

            class Readable {
                constructor(options: any);

                addListener(ev: any, fn: any): any;

                destroy(err: any, cb: any): any;

                filter(args: any): any;

                isPaused(): any;

                iterator(options: any): any;

                map(args: any): any;

                off(ev: any, fn: any): any;

                on(ev: any, fn: any): any;

                pause(): any;

                pipe(dest: any, pipeOpts: any): any;

                push(chunk: any, encoding: any): any;

                read(n: any): any;

                removeAllListeners(ev: any, ...args: any[]): any;

                removeListener(ev: any, fn: any): any;

                resume(): any;

                setEncoding(enc: any): any;

                unpipe(dest: any): any;

                unshift(chunk: any, encoding: any): any;

                wrap(stream: any): any;

                static Duplex: any;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static PassThrough: any;

                static Readable: any;

                static ReadableState: any;

                static Stream: any;

                static Transform: any;

                static Writable: any;

                static addAbortSignal: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static compose: any;

                static defaultMaxListeners: any;

                static destroy: any;

                static errorMonitor: any;

                static finished: any;

                static from: any;

                static getEventListeners: any;

                static init: any;

                static isDisturbed: any;

                static isErrored: any;

                static isReadable: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static pipeline: any;

                static promises: any;

                static setMaxListeners: any;

                static usingDomains: any;

                static wrap: any;

            }

            class ReadableState {
                constructor(options: any, stream: any, isDuplex: any);

            }

            class Transform {
                constructor(options: any);

                static Duplex: any;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static PassThrough: any;

                static Readable: any;

                static ReadableState: any;

                static Stream: any;

                static Transform: any;

                static Writable: any;

                static addAbortSignal: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static compose: any;

                static defaultMaxListeners: any;

                static destroy: any;

                static errorMonitor: any;

                static finished: any;

                static from: any;

                static getEventListeners: any;

                static init: any;

                static isDisturbed: any;

                static isErrored: any;

                static isReadable: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static pipeline: any;

                static promises: any;

                static setMaxListeners: any;

                static usingDomains: any;

                static wrap: any;

            }

            class Writable {
                constructor(options: any);

                cork(): void;

                destroy(err: any, cb: any): any;

                end(chunk: any, encoding: any, cb: any): any;

                pipe(): void;

                setDefaultEncoding(encoding: any): any;

                uncork(): void;

                write(chunk: any, encoding: any, cb: any): any;

                static Duplex: any;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static PassThrough: any;

                static Readable: any;

                static Stream: any;

                static Transform: any;

                static Writable: any;

                static WritableState: any;

                static addAbortSignal: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static compose: any;

                static defaultMaxListeners: any;

                static destroy: any;

                static errorMonitor: any;

                static finished: any;

                static getEventListeners: any;

                static init: any;

                static isDisturbed: any;

                static isErrored: any;

                static isReadable: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static pipeline: any;

                static promises: any;

                static setMaxListeners: any;

                static usingDomains: any;

            }

            namespace promises {
                // Too-deep object hierarchy from fs.FileWriteStream.Stream.PassThrough.promises
                const finished: any;

                // Too-deep object hierarchy from fs.FileWriteStream.Stream.PassThrough.promises
                const pipeline: any;

            }

        }

        namespace Readable {
            class Duplex {
                constructor(options: any);

                cork(): void;

                end(chunk: any, encoding: any, cb: any): any;

                setDefaultEncoding(encoding: any): any;

                uncork(): void;

                write(chunk: any, encoding: any, cb: any): any;

                static Duplex: any;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static PassThrough: any;

                static Readable: any;

                static ReadableState: any;

                static Stream: any;

                static Transform: any;

                static Writable: any;

                static addAbortSignal: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static compose: any;

                static defaultMaxListeners: any;

                static destroy: any;

                static errorMonitor: any;

                static finished: any;

                static from: any;

                static getEventListeners: any;

                static init: any;

                static isDisturbed: any;

                static isErrored: any;

                static isReadable: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static pipeline: any;

                static promises: any;

                static setMaxListeners: any;

                static usingDomains: any;

                static wrap: any;

            }

            class EventEmitter {
                constructor(opts: any);

                addListener(type: any, listener: any): any;

                emit(type: any, args: any): any;

                eventNames(): any;

                getMaxListeners(): any;

                listenerCount(type: any): any;

                listeners(type: any): any;

                off(type: any, listener: any): any;

                on(type: any, listener: any): any;

                once(type: any, listener: any): any;

                prependListener(type: any, listener: any): any;

                prependOnceListener(type: any, listener: any): any;

                rawListeners(type: any): any;

                removeAllListeners(type: any, ...args: any[]): any;

                removeListener(type: any, listener: any): any;

                setMaxListeners(n: any): any;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static defaultMaxListeners: any;

                static errorMonitor: any;

                static getEventListeners: any;

                static init: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static setMaxListeners: any;

                static usingDomains: any;

            }

            class EventEmitterAsyncResource {
                constructor(...args: any[]);

                emit(...args: any[]): void;

                emitDestroy(...args: any[]): void;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static defaultMaxListeners: any;

                static errorMonitor: any;

                static getEventListeners: any;

                static init: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static setMaxListeners: any;

                static usingDomains: any;

            }

            class PassThrough {
                constructor(options: any);

                static Duplex: any;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static PassThrough: any;

                static Readable: any;

                static ReadableState: any;

                static Stream: any;

                static Transform: any;

                static Writable: any;

                static addAbortSignal: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static compose: any;

                static defaultMaxListeners: any;

                static destroy: any;

                static errorMonitor: any;

                static finished: any;

                static from: any;

                static getEventListeners: any;

                static init: any;

                static isDisturbed: any;

                static isErrored: any;

                static isReadable: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static pipeline: any;

                static promises: any;

                static setMaxListeners: any;

                static usingDomains: any;

                static wrap: any;

            }

            class ReadableState {
                constructor(options: any, stream: any, isDuplex: any);

            }

            class Transform {
                constructor(options: any);

                static Duplex: any;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static PassThrough: any;

                static Readable: any;

                static ReadableState: any;

                static Stream: any;

                static Transform: any;

                static Writable: any;

                static addAbortSignal: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static compose: any;

                static defaultMaxListeners: any;

                static destroy: any;

                static errorMonitor: any;

                static finished: any;

                static from: any;

                static getEventListeners: any;

                static init: any;

                static isDisturbed: any;

                static isErrored: any;

                static isReadable: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static pipeline: any;

                static promises: any;

                static setMaxListeners: any;

                static usingDomains: any;

                static wrap: any;

            }

            class Writable {
                constructor(options: any);

                cork(): void;

                destroy(err: any, cb: any): any;

                end(chunk: any, encoding: any, cb: any): any;

                pipe(): void;

                setDefaultEncoding(encoding: any): any;

                uncork(): void;

                write(chunk: any, encoding: any, cb: any): any;

                static Duplex: any;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static PassThrough: any;

                static Readable: any;

                static Stream: any;

                static Transform: any;

                static Writable: any;

                static WritableState: any;

                static addAbortSignal: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static compose: any;

                static defaultMaxListeners: any;

                static destroy: any;

                static errorMonitor: any;

                static finished: any;

                static getEventListeners: any;

                static init: any;

                static isDisturbed: any;

                static isErrored: any;

                static isReadable: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static pipeline: any;

                static promises: any;

                static setMaxListeners: any;

                static usingDomains: any;

            }

            namespace promises {
                // Too-deep object hierarchy from fs.FileWriteStream.Stream.Readable.promises
                const finished: any;

                // Too-deep object hierarchy from fs.FileWriteStream.Stream.Readable.promises
                const pipeline: any;

            }

        }

        namespace Transform {
            class Duplex {
                constructor(options: any);

                cork(): void;

                end(chunk: any, encoding: any, cb: any): any;

                setDefaultEncoding(encoding: any): any;

                uncork(): void;

                write(chunk: any, encoding: any, cb: any): any;

                static Duplex: any;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static PassThrough: any;

                static Readable: any;

                static ReadableState: any;

                static Stream: any;

                static Transform: any;

                static Writable: any;

                static addAbortSignal: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static compose: any;

                static defaultMaxListeners: any;

                static destroy: any;

                static errorMonitor: any;

                static finished: any;

                static from: any;

                static getEventListeners: any;

                static init: any;

                static isDisturbed: any;

                static isErrored: any;

                static isReadable: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static pipeline: any;

                static promises: any;

                static setMaxListeners: any;

                static usingDomains: any;

                static wrap: any;

            }

            class EventEmitter {
                constructor(opts: any);

                addListener(type: any, listener: any): any;

                emit(type: any, args: any): any;

                eventNames(): any;

                getMaxListeners(): any;

                listenerCount(type: any): any;

                listeners(type: any): any;

                off(type: any, listener: any): any;

                on(type: any, listener: any): any;

                once(type: any, listener: any): any;

                prependListener(type: any, listener: any): any;

                prependOnceListener(type: any, listener: any): any;

                rawListeners(type: any): any;

                removeAllListeners(type: any, ...args: any[]): any;

                removeListener(type: any, listener: any): any;

                setMaxListeners(n: any): any;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static defaultMaxListeners: any;

                static errorMonitor: any;

                static getEventListeners: any;

                static init: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static setMaxListeners: any;

                static usingDomains: any;

            }

            class EventEmitterAsyncResource {
                constructor(...args: any[]);

                emit(...args: any[]): void;

                emitDestroy(...args: any[]): void;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static defaultMaxListeners: any;

                static errorMonitor: any;

                static getEventListeners: any;

                static init: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static setMaxListeners: any;

                static usingDomains: any;

            }

            class PassThrough {
                constructor(options: any);

                static Duplex: any;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static PassThrough: any;

                static Readable: any;

                static ReadableState: any;

                static Stream: any;

                static Transform: any;

                static Writable: any;

                static addAbortSignal: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static compose: any;

                static defaultMaxListeners: any;

                static destroy: any;

                static errorMonitor: any;

                static finished: any;

                static from: any;

                static getEventListeners: any;

                static init: any;

                static isDisturbed: any;

                static isErrored: any;

                static isReadable: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static pipeline: any;

                static promises: any;

                static setMaxListeners: any;

                static usingDomains: any;

                static wrap: any;

            }

            class Readable {
                constructor(options: any);

                addListener(ev: any, fn: any): any;

                destroy(err: any, cb: any): any;

                filter(args: any): any;

                isPaused(): any;

                iterator(options: any): any;

                map(args: any): any;

                off(ev: any, fn: any): any;

                on(ev: any, fn: any): any;

                pause(): any;

                pipe(dest: any, pipeOpts: any): any;

                push(chunk: any, encoding: any): any;

                read(n: any): any;

                removeAllListeners(ev: any, ...args: any[]): any;

                removeListener(ev: any, fn: any): any;

                resume(): any;

                setEncoding(enc: any): any;

                unpipe(dest: any): any;

                unshift(chunk: any, encoding: any): any;

                wrap(stream: any): any;

                static Duplex: any;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static PassThrough: any;

                static Readable: any;

                static ReadableState: any;

                static Stream: any;

                static Transform: any;

                static Writable: any;

                static addAbortSignal: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static compose: any;

                static defaultMaxListeners: any;

                static destroy: any;

                static errorMonitor: any;

                static finished: any;

                static from: any;

                static getEventListeners: any;

                static init: any;

                static isDisturbed: any;

                static isErrored: any;

                static isReadable: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static pipeline: any;

                static promises: any;

                static setMaxListeners: any;

                static usingDomains: any;

                static wrap: any;

            }

            class ReadableState {
                constructor(options: any, stream: any, isDuplex: any);

            }

            class Writable {
                constructor(options: any);

                cork(): void;

                destroy(err: any, cb: any): any;

                end(chunk: any, encoding: any, cb: any): any;

                pipe(): void;

                setDefaultEncoding(encoding: any): any;

                uncork(): void;

                write(chunk: any, encoding: any, cb: any): any;

                static Duplex: any;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static PassThrough: any;

                static Readable: any;

                static Stream: any;

                static Transform: any;

                static Writable: any;

                static WritableState: any;

                static addAbortSignal: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static compose: any;

                static defaultMaxListeners: any;

                static destroy: any;

                static errorMonitor: any;

                static finished: any;

                static getEventListeners: any;

                static init: any;

                static isDisturbed: any;

                static isErrored: any;

                static isReadable: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static pipeline: any;

                static promises: any;

                static setMaxListeners: any;

                static usingDomains: any;

            }

            namespace promises {
                // Too-deep object hierarchy from fs.FileWriteStream.Stream.Transform.promises
                const finished: any;

                // Too-deep object hierarchy from fs.FileWriteStream.Stream.Transform.promises
                const pipeline: any;

            }

        }

        namespace Writable {
            class Duplex {
                constructor(options: any);

                cork(): void;

                end(chunk: any, encoding: any, cb: any): any;

                setDefaultEncoding(encoding: any): any;

                uncork(): void;

                write(chunk: any, encoding: any, cb: any): any;

                static Duplex: any;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static PassThrough: any;

                static Readable: any;

                static ReadableState: any;

                static Stream: any;

                static Transform: any;

                static Writable: any;

                static addAbortSignal: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static compose: any;

                static defaultMaxListeners: any;

                static destroy: any;

                static errorMonitor: any;

                static finished: any;

                static from: any;

                static getEventListeners: any;

                static init: any;

                static isDisturbed: any;

                static isErrored: any;

                static isReadable: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static pipeline: any;

                static promises: any;

                static setMaxListeners: any;

                static usingDomains: any;

                static wrap: any;

            }

            class EventEmitter {
                constructor(opts: any);

                addListener(type: any, listener: any): any;

                emit(type: any, args: any): any;

                eventNames(): any;

                getMaxListeners(): any;

                listenerCount(type: any): any;

                listeners(type: any): any;

                off(type: any, listener: any): any;

                on(type: any, listener: any): any;

                once(type: any, listener: any): any;

                prependListener(type: any, listener: any): any;

                prependOnceListener(type: any, listener: any): any;

                rawListeners(type: any): any;

                removeAllListeners(type: any, ...args: any[]): any;

                removeListener(type: any, listener: any): any;

                setMaxListeners(n: any): any;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static defaultMaxListeners: any;

                static errorMonitor: any;

                static getEventListeners: any;

                static init: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static setMaxListeners: any;

                static usingDomains: any;

            }

            class EventEmitterAsyncResource {
                constructor(...args: any[]);

                emit(...args: any[]): void;

                emitDestroy(...args: any[]): void;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static defaultMaxListeners: any;

                static errorMonitor: any;

                static getEventListeners: any;

                static init: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static setMaxListeners: any;

                static usingDomains: any;

            }

            class PassThrough {
                constructor(options: any);

                static Duplex: any;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static PassThrough: any;

                static Readable: any;

                static ReadableState: any;

                static Stream: any;

                static Transform: any;

                static Writable: any;

                static addAbortSignal: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static compose: any;

                static defaultMaxListeners: any;

                static destroy: any;

                static errorMonitor: any;

                static finished: any;

                static from: any;

                static getEventListeners: any;

                static init: any;

                static isDisturbed: any;

                static isErrored: any;

                static isReadable: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static pipeline: any;

                static promises: any;

                static setMaxListeners: any;

                static usingDomains: any;

                static wrap: any;

            }

            class Readable {
                constructor(options: any);

                addListener(ev: any, fn: any): any;

                destroy(err: any, cb: any): any;

                filter(args: any): any;

                isPaused(): any;

                iterator(options: any): any;

                map(args: any): any;

                off(ev: any, fn: any): any;

                on(ev: any, fn: any): any;

                pause(): any;

                pipe(dest: any, pipeOpts: any): any;

                push(chunk: any, encoding: any): any;

                read(n: any): any;

                removeAllListeners(ev: any, ...args: any[]): any;

                removeListener(ev: any, fn: any): any;

                resume(): any;

                setEncoding(enc: any): any;

                unpipe(dest: any): any;

                unshift(chunk: any, encoding: any): any;

                wrap(stream: any): any;

                static Duplex: any;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static PassThrough: any;

                static Readable: any;

                static ReadableState: any;

                static Stream: any;

                static Transform: any;

                static Writable: any;

                static addAbortSignal: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static compose: any;

                static defaultMaxListeners: any;

                static destroy: any;

                static errorMonitor: any;

                static finished: any;

                static from: any;

                static getEventListeners: any;

                static init: any;

                static isDisturbed: any;

                static isErrored: any;

                static isReadable: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static pipeline: any;

                static promises: any;

                static setMaxListeners: any;

                static usingDomains: any;

                static wrap: any;

            }

            class Transform {
                constructor(options: any);

                static Duplex: any;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static PassThrough: any;

                static Readable: any;

                static ReadableState: any;

                static Stream: any;

                static Transform: any;

                static Writable: any;

                static addAbortSignal: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static compose: any;

                static defaultMaxListeners: any;

                static destroy: any;

                static errorMonitor: any;

                static finished: any;

                static from: any;

                static getEventListeners: any;

                static init: any;

                static isDisturbed: any;

                static isErrored: any;

                static isReadable: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static pipeline: any;

                static promises: any;

                static setMaxListeners: any;

                static usingDomains: any;

                static wrap: any;

            }

            class WritableState {
                constructor(options: any, stream: any, isDuplex: any);

                getBuffer(): any;

            }

            namespace promises {
                // Too-deep object hierarchy from fs.FileWriteStream.Stream.Writable.promises
                const finished: any;

                // Too-deep object hierarchy from fs.FileWriteStream.Stream.Writable.promises
                const pipeline: any;

            }

        }

        namespace promises {
            function finished(stream: any, opts: any): any;

            function pipeline(streams: any): any;

        }

    }

    namespace Transform {
        class Duplex {
            constructor(options: any);

            cork(): void;

            end(chunk: any, encoding: any, cb: any): any;

            setDefaultEncoding(encoding: any): any;

            uncork(): void;

            write(chunk: any, encoding: any, cb: any): any;

            static Duplex: any;

            static Transform: any;

            static addAbortSignal(signal: any, stream: any): any;

            static captureRejectionSymbol: any;

            static captureRejections: boolean;

            static compose(streams: any): any;

            static defaultMaxListeners: number;

            static destroy(stream: any, err: any): any;

            static errorMonitor: any;

            static finished(stream: any, options: any, callback: any, ...args: any[]): any;

            static from(body: any): any;

            static getEventListeners(emitterOrTarget: any, type: any): any;

            static init(opts: any): void;

            static isDisturbed(stream: any): any;

            static isErrored(stream: any): any;

            static isReadable(stream: any): any;

            static kMaxEventTargetListeners: any;

            static kMaxEventTargetListenersWarned: any;

            static listenerCount(emitter: any, type: any): any;

            static on(emitter: any, event: any, options: any): any;

            static once(emitter: any, name: any, options: any): any;

            static pipeline(streams: any): any;

            static setMaxListeners(n: any, eventTargets: any): void;

            static usingDomains: boolean;

            static wrap(src: any, options: any): any;

        }

        class EventEmitter {
            constructor(opts: any);

            addListener(type: any, listener: any): any;

            emit(type: any, args: any): any;

            eventNames(): any;

            getMaxListeners(): any;

            listenerCount(type: any): any;

            listeners(type: any): any;

            off(type: any, listener: any): any;

            on(type: any, listener: any): any;

            once(type: any, listener: any): any;

            prependListener(type: any, listener: any): any;

            prependOnceListener(type: any, listener: any): any;

            rawListeners(type: any): any;

            removeAllListeners(type: any, ...args: any[]): any;

            removeListener(type: any, listener: any): any;

            setMaxListeners(n: any): any;

            static EventEmitter: any;

            static captureRejectionSymbol: any;

            static captureRejections: boolean;

            static defaultMaxListeners: number;

            static errorMonitor: any;

            static getEventListeners(emitterOrTarget: any, type: any): any;

            static init(opts: any): void;

            static kMaxEventTargetListeners: any;

            static kMaxEventTargetListenersWarned: any;

            static listenerCount(emitter: any, type: any): any;

            static on(emitter: any, event: any, options: any): any;

            static once(emitter: any, name: any, options: any): any;

            static setMaxListeners(n: any, eventTargets: any): void;

            static usingDomains: boolean;

        }

        class EventEmitterAsyncResource {
            constructor(...args: any[]);

            emit(...args: any[]): void;

            emitDestroy(...args: any[]): void;

            static EventEmitterAsyncResource: any;

            static captureRejectionSymbol: any;

            static captureRejections: boolean;

            static defaultMaxListeners: number;

            static errorMonitor: any;

            static getEventListeners(emitterOrTarget: any, type: any): any;

            static init(opts: any): void;

            static kMaxEventTargetListeners: any;

            static kMaxEventTargetListenersWarned: any;

            static listenerCount(emitter: any, type: any): any;

            static on(emitter: any, event: any, options: any): any;

            static once(emitter: any, name: any, options: any): any;

            static setMaxListeners(n: any, eventTargets: any): void;

            static usingDomains: boolean;

        }

        class PassThrough {
            constructor(options: any);

            static PassThrough: any;

            static Transform: any;

            static addAbortSignal(signal: any, stream: any): any;

            static captureRejectionSymbol: any;

            static captureRejections: boolean;

            static compose(streams: any): any;

            static defaultMaxListeners: number;

            static destroy(stream: any, err: any): any;

            static errorMonitor: any;

            static finished(stream: any, options: any, callback: any, ...args: any[]): any;

            static from(body: any): any;

            static getEventListeners(emitterOrTarget: any, type: any): any;

            static init(opts: any): void;

            static isDisturbed(stream: any): any;

            static isErrored(stream: any): any;

            static isReadable(stream: any): any;

            static kMaxEventTargetListeners: any;

            static kMaxEventTargetListenersWarned: any;

            static listenerCount(emitter: any, type: any): any;

            static on(emitter: any, event: any, options: any): any;

            static once(emitter: any, name: any, options: any): any;

            static pipeline(streams: any): any;

            static setMaxListeners(n: any, eventTargets: any): void;

            static usingDomains: boolean;

            static wrap(src: any, options: any): any;

        }

        class Readable {
            constructor(options: any);

            addListener(ev: any, fn: any): any;

            destroy(err: any, cb: any): any;

            filter(args: any): any;

            isPaused(): any;

            iterator(options: any): any;

            map(args: any): any;

            off(ev: any, fn: any): any;

            on(ev: any, fn: any): any;

            pause(): any;

            pipe(dest: any, pipeOpts: any): any;

            push(chunk: any, encoding: any): any;

            read(n: any): any;

            removeAllListeners(ev: any, ...args: any[]): any;

            removeListener(ev: any, fn: any): any;

            resume(): any;

            setEncoding(enc: any): any;

            unpipe(dest: any): any;

            unshift(chunk: any, encoding: any): any;

            wrap(stream: any): any;

            static Readable: any;

            static Transform: any;

            static addAbortSignal(signal: any, stream: any): any;

            static captureRejectionSymbol: any;

            static captureRejections: boolean;

            static compose(streams: any): any;

            static defaultMaxListeners: number;

            static destroy(stream: any, err: any): any;

            static errorMonitor: any;

            static finished(stream: any, options: any, callback: any, ...args: any[]): any;

            static from(iterable: any, opts: any): any;

            static getEventListeners(emitterOrTarget: any, type: any): any;

            static init(opts: any): void;

            static isDisturbed(stream: any): any;

            static isErrored(stream: any): any;

            static isReadable(stream: any): any;

            static kMaxEventTargetListeners: any;

            static kMaxEventTargetListenersWarned: any;

            static listenerCount(emitter: any, type: any): any;

            static on(emitter: any, event: any, options: any): any;

            static once(emitter: any, name: any, options: any): any;

            static pipeline(streams: any): any;

            static setMaxListeners(n: any, eventTargets: any): void;

            static usingDomains: boolean;

            static wrap(src: any, options: any): any;

        }

        class ReadableState {
            constructor(options: any, stream: any, isDuplex: any);

        }

        class Stream {
            constructor(opts: any);

            pipe(dest: any, options: any): any;

            static Stream: any;

            static Transform: any;

            static addAbortSignal(signal: any, stream: any): any;

            static captureRejectionSymbol: any;

            static captureRejections: boolean;

            static compose(streams: any): any;

            static defaultMaxListeners: number;

            static destroy(stream: any, err: any): any;

            static errorMonitor: any;

            static finished(stream: any, options: any, callback: any, ...args: any[]): any;

            static getEventListeners(emitterOrTarget: any, type: any): any;

            static init(opts: any): void;

            static isDisturbed(stream: any): any;

            static isErrored(stream: any): any;

            static isReadable(stream: any): any;

            static kMaxEventTargetListeners: any;

            static kMaxEventTargetListenersWarned: any;

            static listenerCount(emitter: any, type: any): any;

            static on(emitter: any, event: any, options: any): any;

            static once(emitter: any, name: any, options: any): any;

            static pipeline(streams: any): any;

            static setMaxListeners(n: any, eventTargets: any): void;

            static usingDomains: boolean;

        }

        class Writable {
            constructor(options: any);

            cork(): void;

            destroy(err: any, cb: any): any;

            end(chunk: any, encoding: any, cb: any): any;

            pipe(): void;

            setDefaultEncoding(encoding: any): any;

            uncork(): void;

            write(chunk: any, encoding: any, cb: any): any;

            static Transform: any;

            static Writable: any;

            static addAbortSignal(signal: any, stream: any): any;

            static captureRejectionSymbol: any;

            static captureRejections: boolean;

            static compose(streams: any): any;

            static defaultMaxListeners: number;

            static destroy(stream: any, err: any): any;

            static errorMonitor: any;

            static finished(stream: any, options: any, callback: any, ...args: any[]): any;

            static getEventListeners(emitterOrTarget: any, type: any): any;

            static init(opts: any): void;

            static isDisturbed(stream: any): any;

            static isErrored(stream: any): any;

            static isReadable(stream: any): any;

            static kMaxEventTargetListeners: any;

            static kMaxEventTargetListenersWarned: any;

            static listenerCount(emitter: any, type: any): any;

            static on(emitter: any, event: any, options: any): any;

            static once(emitter: any, name: any, options: any): any;

            static pipeline(streams: any): any;

            static setMaxListeners(n: any, eventTargets: any): void;

            static usingDomains: boolean;

        }

        namespace Duplex {
            class EventEmitter {
                constructor(opts: any);

                addListener(type: any, listener: any): any;

                emit(type: any, args: any): any;

                eventNames(): any;

                getMaxListeners(): any;

                listenerCount(type: any): any;

                listeners(type: any): any;

                off(type: any, listener: any): any;

                on(type: any, listener: any): any;

                once(type: any, listener: any): any;

                prependListener(type: any, listener: any): any;

                prependOnceListener(type: any, listener: any): any;

                rawListeners(type: any): any;

                removeAllListeners(type: any, ...args: any[]): any;

                removeListener(type: any, listener: any): any;

                setMaxListeners(n: any): any;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static defaultMaxListeners: any;

                static errorMonitor: any;

                static getEventListeners: any;

                static init: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static setMaxListeners: any;

                static usingDomains: any;

            }

            class EventEmitterAsyncResource {
                constructor(...args: any[]);

                emit(...args: any[]): void;

                emitDestroy(...args: any[]): void;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static defaultMaxListeners: any;

                static errorMonitor: any;

                static getEventListeners: any;

                static init: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static setMaxListeners: any;

                static usingDomains: any;

            }

            class PassThrough {
                constructor(options: any);

                static Duplex: any;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static PassThrough: any;

                static Readable: any;

                static ReadableState: any;

                static Stream: any;

                static Transform: any;

                static Writable: any;

                static addAbortSignal: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static compose: any;

                static defaultMaxListeners: any;

                static destroy: any;

                static errorMonitor: any;

                static finished: any;

                static from: any;

                static getEventListeners: any;

                static init: any;

                static isDisturbed: any;

                static isErrored: any;

                static isReadable: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static pipeline: any;

                static promises: any;

                static setMaxListeners: any;

                static usingDomains: any;

                static wrap: any;

            }

            class Readable {
                constructor(options: any);

                addListener(ev: any, fn: any): any;

                destroy(err: any, cb: any): any;

                filter(args: any): any;

                isPaused(): any;

                iterator(options: any): any;

                map(args: any): any;

                off(ev: any, fn: any): any;

                on(ev: any, fn: any): any;

                pause(): any;

                pipe(dest: any, pipeOpts: any): any;

                push(chunk: any, encoding: any): any;

                read(n: any): any;

                removeAllListeners(ev: any, ...args: any[]): any;

                removeListener(ev: any, fn: any): any;

                resume(): any;

                setEncoding(enc: any): any;

                unpipe(dest: any): any;

                unshift(chunk: any, encoding: any): any;

                wrap(stream: any): any;

                static Duplex: any;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static PassThrough: any;

                static Readable: any;

                static ReadableState: any;

                static Stream: any;

                static Transform: any;

                static Writable: any;

                static addAbortSignal: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static compose: any;

                static defaultMaxListeners: any;

                static destroy: any;

                static errorMonitor: any;

                static finished: any;

                static from: any;

                static getEventListeners: any;

                static init: any;

                static isDisturbed: any;

                static isErrored: any;

                static isReadable: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static pipeline: any;

                static promises: any;

                static setMaxListeners: any;

                static usingDomains: any;

                static wrap: any;

            }

            class ReadableState {
                constructor(options: any, stream: any, isDuplex: any);

            }

            class Stream {
                constructor(opts: any);

                pipe(dest: any, options: any): any;

                static Duplex: any;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static PassThrough: any;

                static Readable: any;

                static Stream: any;

                static Transform: any;

                static Writable: any;

                static addAbortSignal: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static compose: any;

                static defaultMaxListeners: any;

                static destroy: any;

                static errorMonitor: any;

                static finished: any;

                static getEventListeners: any;

                static init: any;

                static isDisturbed: any;

                static isErrored: any;

                static isReadable: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static pipeline: any;

                static promises: any;

                static setMaxListeners: any;

                static usingDomains: any;

            }

            class Writable {
                constructor(options: any);

                cork(): void;

                destroy(err: any, cb: any): any;

                end(chunk: any, encoding: any, cb: any): any;

                pipe(): void;

                setDefaultEncoding(encoding: any): any;

                uncork(): void;

                write(chunk: any, encoding: any, cb: any): any;

                static Duplex: any;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static PassThrough: any;

                static Readable: any;

                static Stream: any;

                static Transform: any;

                static Writable: any;

                static WritableState: any;

                static addAbortSignal: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static compose: any;

                static defaultMaxListeners: any;

                static destroy: any;

                static errorMonitor: any;

                static finished: any;

                static getEventListeners: any;

                static init: any;

                static isDisturbed: any;

                static isErrored: any;

                static isReadable: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static pipeline: any;

                static promises: any;

                static setMaxListeners: any;

                static usingDomains: any;

            }

            namespace promises {
                // Too-deep object hierarchy from fs.FileWriteStream.Transform.Duplex.promises
                const finished: any;

                // Too-deep object hierarchy from fs.FileWriteStream.Transform.Duplex.promises
                const pipeline: any;

            }

        }

        namespace EventEmitter {
            class EventEmitterAsyncResource {
                constructor(...args: any[]);

                emit(...args: any[]): void;

                emitDestroy(...args: any[]): void;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static defaultMaxListeners: any;

                static errorMonitor: any;

                static getEventListeners: any;

                static init: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static setMaxListeners: any;

                static usingDomains: any;

            }

        }

        namespace EventEmitterAsyncResource {
            class EventEmitter {
                constructor(opts: any);

                addListener(type: any, listener: any): any;

                emit(type: any, args: any): any;

                eventNames(): any;

                getMaxListeners(): any;

                listenerCount(type: any): any;

                listeners(type: any): any;

                off(type: any, listener: any): any;

                on(type: any, listener: any): any;

                once(type: any, listener: any): any;

                prependListener(type: any, listener: any): any;

                prependOnceListener(type: any, listener: any): any;

                rawListeners(type: any): any;

                removeAllListeners(type: any, ...args: any[]): any;

                removeListener(type: any, listener: any): any;

                setMaxListeners(n: any): any;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static defaultMaxListeners: any;

                static errorMonitor: any;

                static getEventListeners: any;

                static init: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static setMaxListeners: any;

                static usingDomains: any;

            }

        }

        namespace PassThrough {
            class Duplex {
                constructor(options: any);

                cork(): void;

                end(chunk: any, encoding: any, cb: any): any;

                setDefaultEncoding(encoding: any): any;

                uncork(): void;

                write(chunk: any, encoding: any, cb: any): any;

                static Duplex: any;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static PassThrough: any;

                static Readable: any;

                static ReadableState: any;

                static Stream: any;

                static Transform: any;

                static Writable: any;

                static addAbortSignal: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static compose: any;

                static defaultMaxListeners: any;

                static destroy: any;

                static errorMonitor: any;

                static finished: any;

                static from: any;

                static getEventListeners: any;

                static init: any;

                static isDisturbed: any;

                static isErrored: any;

                static isReadable: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static pipeline: any;

                static promises: any;

                static setMaxListeners: any;

                static usingDomains: any;

                static wrap: any;

            }

            class EventEmitter {
                constructor(opts: any);

                addListener(type: any, listener: any): any;

                emit(type: any, args: any): any;

                eventNames(): any;

                getMaxListeners(): any;

                listenerCount(type: any): any;

                listeners(type: any): any;

                off(type: any, listener: any): any;

                on(type: any, listener: any): any;

                once(type: any, listener: any): any;

                prependListener(type: any, listener: any): any;

                prependOnceListener(type: any, listener: any): any;

                rawListeners(type: any): any;

                removeAllListeners(type: any, ...args: any[]): any;

                removeListener(type: any, listener: any): any;

                setMaxListeners(n: any): any;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static defaultMaxListeners: any;

                static errorMonitor: any;

                static getEventListeners: any;

                static init: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static setMaxListeners: any;

                static usingDomains: any;

            }

            class EventEmitterAsyncResource {
                constructor(...args: any[]);

                emit(...args: any[]): void;

                emitDestroy(...args: any[]): void;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static defaultMaxListeners: any;

                static errorMonitor: any;

                static getEventListeners: any;

                static init: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static setMaxListeners: any;

                static usingDomains: any;

            }

            class Readable {
                constructor(options: any);

                addListener(ev: any, fn: any): any;

                destroy(err: any, cb: any): any;

                filter(args: any): any;

                isPaused(): any;

                iterator(options: any): any;

                map(args: any): any;

                off(ev: any, fn: any): any;

                on(ev: any, fn: any): any;

                pause(): any;

                pipe(dest: any, pipeOpts: any): any;

                push(chunk: any, encoding: any): any;

                read(n: any): any;

                removeAllListeners(ev: any, ...args: any[]): any;

                removeListener(ev: any, fn: any): any;

                resume(): any;

                setEncoding(enc: any): any;

                unpipe(dest: any): any;

                unshift(chunk: any, encoding: any): any;

                wrap(stream: any): any;

                static Duplex: any;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static PassThrough: any;

                static Readable: any;

                static ReadableState: any;

                static Stream: any;

                static Transform: any;

                static Writable: any;

                static addAbortSignal: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static compose: any;

                static defaultMaxListeners: any;

                static destroy: any;

                static errorMonitor: any;

                static finished: any;

                static from: any;

                static getEventListeners: any;

                static init: any;

                static isDisturbed: any;

                static isErrored: any;

                static isReadable: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static pipeline: any;

                static promises: any;

                static setMaxListeners: any;

                static usingDomains: any;

                static wrap: any;

            }

            class ReadableState {
                constructor(options: any, stream: any, isDuplex: any);

            }

            class Stream {
                constructor(opts: any);

                pipe(dest: any, options: any): any;

                static Duplex: any;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static PassThrough: any;

                static Readable: any;

                static Stream: any;

                static Transform: any;

                static Writable: any;

                static addAbortSignal: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static compose: any;

                static defaultMaxListeners: any;

                static destroy: any;

                static errorMonitor: any;

                static finished: any;

                static getEventListeners: any;

                static init: any;

                static isDisturbed: any;

                static isErrored: any;

                static isReadable: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static pipeline: any;

                static promises: any;

                static setMaxListeners: any;

                static usingDomains: any;

            }

            class Writable {
                constructor(options: any);

                cork(): void;

                destroy(err: any, cb: any): any;

                end(chunk: any, encoding: any, cb: any): any;

                pipe(): void;

                setDefaultEncoding(encoding: any): any;

                uncork(): void;

                write(chunk: any, encoding: any, cb: any): any;

                static Duplex: any;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static PassThrough: any;

                static Readable: any;

                static Stream: any;

                static Transform: any;

                static Writable: any;

                static WritableState: any;

                static addAbortSignal: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static compose: any;

                static defaultMaxListeners: any;

                static destroy: any;

                static errorMonitor: any;

                static finished: any;

                static getEventListeners: any;

                static init: any;

                static isDisturbed: any;

                static isErrored: any;

                static isReadable: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static pipeline: any;

                static promises: any;

                static setMaxListeners: any;

                static usingDomains: any;

            }

            namespace promises {
                // Too-deep object hierarchy from fs.FileWriteStream.Transform.PassThrough.promises
                const finished: any;

                // Too-deep object hierarchy from fs.FileWriteStream.Transform.PassThrough.promises
                const pipeline: any;

            }

        }

        namespace Readable {
            class Duplex {
                constructor(options: any);

                cork(): void;

                end(chunk: any, encoding: any, cb: any): any;

                setDefaultEncoding(encoding: any): any;

                uncork(): void;

                write(chunk: any, encoding: any, cb: any): any;

                static Duplex: any;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static PassThrough: any;

                static Readable: any;

                static ReadableState: any;

                static Stream: any;

                static Transform: any;

                static Writable: any;

                static addAbortSignal: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static compose: any;

                static defaultMaxListeners: any;

                static destroy: any;

                static errorMonitor: any;

                static finished: any;

                static from: any;

                static getEventListeners: any;

                static init: any;

                static isDisturbed: any;

                static isErrored: any;

                static isReadable: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static pipeline: any;

                static promises: any;

                static setMaxListeners: any;

                static usingDomains: any;

                static wrap: any;

            }

            class EventEmitter {
                constructor(opts: any);

                addListener(type: any, listener: any): any;

                emit(type: any, args: any): any;

                eventNames(): any;

                getMaxListeners(): any;

                listenerCount(type: any): any;

                listeners(type: any): any;

                off(type: any, listener: any): any;

                on(type: any, listener: any): any;

                once(type: any, listener: any): any;

                prependListener(type: any, listener: any): any;

                prependOnceListener(type: any, listener: any): any;

                rawListeners(type: any): any;

                removeAllListeners(type: any, ...args: any[]): any;

                removeListener(type: any, listener: any): any;

                setMaxListeners(n: any): any;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static defaultMaxListeners: any;

                static errorMonitor: any;

                static getEventListeners: any;

                static init: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static setMaxListeners: any;

                static usingDomains: any;

            }

            class EventEmitterAsyncResource {
                constructor(...args: any[]);

                emit(...args: any[]): void;

                emitDestroy(...args: any[]): void;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static defaultMaxListeners: any;

                static errorMonitor: any;

                static getEventListeners: any;

                static init: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static setMaxListeners: any;

                static usingDomains: any;

            }

            class PassThrough {
                constructor(options: any);

                static Duplex: any;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static PassThrough: any;

                static Readable: any;

                static ReadableState: any;

                static Stream: any;

                static Transform: any;

                static Writable: any;

                static addAbortSignal: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static compose: any;

                static defaultMaxListeners: any;

                static destroy: any;

                static errorMonitor: any;

                static finished: any;

                static from: any;

                static getEventListeners: any;

                static init: any;

                static isDisturbed: any;

                static isErrored: any;

                static isReadable: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static pipeline: any;

                static promises: any;

                static setMaxListeners: any;

                static usingDomains: any;

                static wrap: any;

            }

            class ReadableState {
                constructor(options: any, stream: any, isDuplex: any);

            }

            class Stream {
                constructor(opts: any);

                pipe(dest: any, options: any): any;

                static Duplex: any;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static PassThrough: any;

                static Readable: any;

                static Stream: any;

                static Transform: any;

                static Writable: any;

                static addAbortSignal: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static compose: any;

                static defaultMaxListeners: any;

                static destroy: any;

                static errorMonitor: any;

                static finished: any;

                static getEventListeners: any;

                static init: any;

                static isDisturbed: any;

                static isErrored: any;

                static isReadable: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static pipeline: any;

                static promises: any;

                static setMaxListeners: any;

                static usingDomains: any;

            }

            class Writable {
                constructor(options: any);

                cork(): void;

                destroy(err: any, cb: any): any;

                end(chunk: any, encoding: any, cb: any): any;

                pipe(): void;

                setDefaultEncoding(encoding: any): any;

                uncork(): void;

                write(chunk: any, encoding: any, cb: any): any;

                static Duplex: any;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static PassThrough: any;

                static Readable: any;

                static Stream: any;

                static Transform: any;

                static Writable: any;

                static WritableState: any;

                static addAbortSignal: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static compose: any;

                static defaultMaxListeners: any;

                static destroy: any;

                static errorMonitor: any;

                static finished: any;

                static getEventListeners: any;

                static init: any;

                static isDisturbed: any;

                static isErrored: any;

                static isReadable: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static pipeline: any;

                static promises: any;

                static setMaxListeners: any;

                static usingDomains: any;

            }

            namespace promises {
                // Too-deep object hierarchy from fs.FileWriteStream.Transform.Readable.promises
                const finished: any;

                // Too-deep object hierarchy from fs.FileWriteStream.Transform.Readable.promises
                const pipeline: any;

            }

        }

        namespace Stream {
            class Duplex {
                constructor(options: any);

                cork(): void;

                end(chunk: any, encoding: any, cb: any): any;

                setDefaultEncoding(encoding: any): any;

                uncork(): void;

                write(chunk: any, encoding: any, cb: any): any;

                static Duplex: any;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static PassThrough: any;

                static Readable: any;

                static ReadableState: any;

                static Stream: any;

                static Transform: any;

                static Writable: any;

                static addAbortSignal: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static compose: any;

                static defaultMaxListeners: any;

                static destroy: any;

                static errorMonitor: any;

                static finished: any;

                static from: any;

                static getEventListeners: any;

                static init: any;

                static isDisturbed: any;

                static isErrored: any;

                static isReadable: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static pipeline: any;

                static promises: any;

                static setMaxListeners: any;

                static usingDomains: any;

                static wrap: any;

            }

            class EventEmitter {
                constructor(opts: any);

                addListener(type: any, listener: any): any;

                emit(type: any, args: any): any;

                eventNames(): any;

                getMaxListeners(): any;

                listenerCount(type: any): any;

                listeners(type: any): any;

                off(type: any, listener: any): any;

                on(type: any, listener: any): any;

                once(type: any, listener: any): any;

                prependListener(type: any, listener: any): any;

                prependOnceListener(type: any, listener: any): any;

                rawListeners(type: any): any;

                removeAllListeners(type: any, ...args: any[]): any;

                removeListener(type: any, listener: any): any;

                setMaxListeners(n: any): any;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static defaultMaxListeners: any;

                static errorMonitor: any;

                static getEventListeners: any;

                static init: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static setMaxListeners: any;

                static usingDomains: any;

            }

            class EventEmitterAsyncResource {
                constructor(...args: any[]);

                emit(...args: any[]): void;

                emitDestroy(...args: any[]): void;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static defaultMaxListeners: any;

                static errorMonitor: any;

                static getEventListeners: any;

                static init: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static setMaxListeners: any;

                static usingDomains: any;

            }

            class PassThrough {
                constructor(options: any);

                static Duplex: any;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static PassThrough: any;

                static Readable: any;

                static ReadableState: any;

                static Stream: any;

                static Transform: any;

                static Writable: any;

                static addAbortSignal: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static compose: any;

                static defaultMaxListeners: any;

                static destroy: any;

                static errorMonitor: any;

                static finished: any;

                static from: any;

                static getEventListeners: any;

                static init: any;

                static isDisturbed: any;

                static isErrored: any;

                static isReadable: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static pipeline: any;

                static promises: any;

                static setMaxListeners: any;

                static usingDomains: any;

                static wrap: any;

            }

            class Readable {
                constructor(options: any);

                addListener(ev: any, fn: any): any;

                destroy(err: any, cb: any): any;

                filter(args: any): any;

                isPaused(): any;

                iterator(options: any): any;

                map(args: any): any;

                off(ev: any, fn: any): any;

                on(ev: any, fn: any): any;

                pause(): any;

                pipe(dest: any, pipeOpts: any): any;

                push(chunk: any, encoding: any): any;

                read(n: any): any;

                removeAllListeners(ev: any, ...args: any[]): any;

                removeListener(ev: any, fn: any): any;

                resume(): any;

                setEncoding(enc: any): any;

                unpipe(dest: any): any;

                unshift(chunk: any, encoding: any): any;

                wrap(stream: any): any;

                static Duplex: any;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static PassThrough: any;

                static Readable: any;

                static ReadableState: any;

                static Stream: any;

                static Transform: any;

                static Writable: any;

                static addAbortSignal: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static compose: any;

                static defaultMaxListeners: any;

                static destroy: any;

                static errorMonitor: any;

                static finished: any;

                static from: any;

                static getEventListeners: any;

                static init: any;

                static isDisturbed: any;

                static isErrored: any;

                static isReadable: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static pipeline: any;

                static promises: any;

                static setMaxListeners: any;

                static usingDomains: any;

                static wrap: any;

            }

            class Writable {
                constructor(options: any);

                cork(): void;

                destroy(err: any, cb: any): any;

                end(chunk: any, encoding: any, cb: any): any;

                pipe(): void;

                setDefaultEncoding(encoding: any): any;

                uncork(): void;

                write(chunk: any, encoding: any, cb: any): any;

                static Duplex: any;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static PassThrough: any;

                static Readable: any;

                static Stream: any;

                static Transform: any;

                static Writable: any;

                static WritableState: any;

                static addAbortSignal: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static compose: any;

                static defaultMaxListeners: any;

                static destroy: any;

                static errorMonitor: any;

                static finished: any;

                static getEventListeners: any;

                static init: any;

                static isDisturbed: any;

                static isErrored: any;

                static isReadable: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static pipeline: any;

                static promises: any;

                static setMaxListeners: any;

                static usingDomains: any;

            }

            namespace promises {
                // Too-deep object hierarchy from fs.FileWriteStream.Transform.Stream.promises
                const finished: any;

                // Too-deep object hierarchy from fs.FileWriteStream.Transform.Stream.promises
                const pipeline: any;

            }

        }

        namespace Writable {
            class Duplex {
                constructor(options: any);

                cork(): void;

                end(chunk: any, encoding: any, cb: any): any;

                setDefaultEncoding(encoding: any): any;

                uncork(): void;

                write(chunk: any, encoding: any, cb: any): any;

                static Duplex: any;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static PassThrough: any;

                static Readable: any;

                static ReadableState: any;

                static Stream: any;

                static Transform: any;

                static Writable: any;

                static addAbortSignal: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static compose: any;

                static defaultMaxListeners: any;

                static destroy: any;

                static errorMonitor: any;

                static finished: any;

                static from: any;

                static getEventListeners: any;

                static init: any;

                static isDisturbed: any;

                static isErrored: any;

                static isReadable: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static pipeline: any;

                static promises: any;

                static setMaxListeners: any;

                static usingDomains: any;

                static wrap: any;

            }

            class EventEmitter {
                constructor(opts: any);

                addListener(type: any, listener: any): any;

                emit(type: any, args: any): any;

                eventNames(): any;

                getMaxListeners(): any;

                listenerCount(type: any): any;

                listeners(type: any): any;

                off(type: any, listener: any): any;

                on(type: any, listener: any): any;

                once(type: any, listener: any): any;

                prependListener(type: any, listener: any): any;

                prependOnceListener(type: any, listener: any): any;

                rawListeners(type: any): any;

                removeAllListeners(type: any, ...args: any[]): any;

                removeListener(type: any, listener: any): any;

                setMaxListeners(n: any): any;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static defaultMaxListeners: any;

                static errorMonitor: any;

                static getEventListeners: any;

                static init: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static setMaxListeners: any;

                static usingDomains: any;

            }

            class EventEmitterAsyncResource {
                constructor(...args: any[]);

                emit(...args: any[]): void;

                emitDestroy(...args: any[]): void;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static defaultMaxListeners: any;

                static errorMonitor: any;

                static getEventListeners: any;

                static init: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static setMaxListeners: any;

                static usingDomains: any;

            }

            class PassThrough {
                constructor(options: any);

                static Duplex: any;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static PassThrough: any;

                static Readable: any;

                static ReadableState: any;

                static Stream: any;

                static Transform: any;

                static Writable: any;

                static addAbortSignal: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static compose: any;

                static defaultMaxListeners: any;

                static destroy: any;

                static errorMonitor: any;

                static finished: any;

                static from: any;

                static getEventListeners: any;

                static init: any;

                static isDisturbed: any;

                static isErrored: any;

                static isReadable: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static pipeline: any;

                static promises: any;

                static setMaxListeners: any;

                static usingDomains: any;

                static wrap: any;

            }

            class Readable {
                constructor(options: any);

                addListener(ev: any, fn: any): any;

                destroy(err: any, cb: any): any;

                filter(args: any): any;

                isPaused(): any;

                iterator(options: any): any;

                map(args: any): any;

                off(ev: any, fn: any): any;

                on(ev: any, fn: any): any;

                pause(): any;

                pipe(dest: any, pipeOpts: any): any;

                push(chunk: any, encoding: any): any;

                read(n: any): any;

                removeAllListeners(ev: any, ...args: any[]): any;

                removeListener(ev: any, fn: any): any;

                resume(): any;

                setEncoding(enc: any): any;

                unpipe(dest: any): any;

                unshift(chunk: any, encoding: any): any;

                wrap(stream: any): any;

                static Duplex: any;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static PassThrough: any;

                static Readable: any;

                static ReadableState: any;

                static Stream: any;

                static Transform: any;

                static Writable: any;

                static addAbortSignal: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static compose: any;

                static defaultMaxListeners: any;

                static destroy: any;

                static errorMonitor: any;

                static finished: any;

                static from: any;

                static getEventListeners: any;

                static init: any;

                static isDisturbed: any;

                static isErrored: any;

                static isReadable: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static pipeline: any;

                static promises: any;

                static setMaxListeners: any;

                static usingDomains: any;

                static wrap: any;

            }

            class Stream {
                constructor(opts: any);

                pipe(dest: any, options: any): any;

                static Duplex: any;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static PassThrough: any;

                static Readable: any;

                static Stream: any;

                static Transform: any;

                static Writable: any;

                static addAbortSignal: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static compose: any;

                static defaultMaxListeners: any;

                static destroy: any;

                static errorMonitor: any;

                static finished: any;

                static getEventListeners: any;

                static init: any;

                static isDisturbed: any;

                static isErrored: any;

                static isReadable: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static pipeline: any;

                static promises: any;

                static setMaxListeners: any;

                static usingDomains: any;

            }

            class WritableState {
                constructor(options: any, stream: any, isDuplex: any);

                getBuffer(): any;

            }

            namespace promises {
                // Too-deep object hierarchy from fs.FileWriteStream.Transform.Writable.promises
                const finished: any;

                // Too-deep object hierarchy from fs.FileWriteStream.Transform.Writable.promises
                const pipeline: any;

            }

        }

        namespace promises {
            function finished(stream: any, opts: any): any;

            function pipeline(streams: any): any;

        }

    }

    namespace Writable {
        class Duplex {
            constructor(options: any);

            cork(): void;

            end(chunk: any, encoding: any, cb: any): any;

            setDefaultEncoding(encoding: any): any;

            uncork(): void;

            write(chunk: any, encoding: any, cb: any): any;

            static Duplex: any;

            static Writable: any;

            static addAbortSignal(signal: any, stream: any): any;

            static captureRejectionSymbol: any;

            static captureRejections: boolean;

            static compose(streams: any): any;

            static defaultMaxListeners: number;

            static destroy(stream: any, err: any): any;

            static errorMonitor: any;

            static finished(stream: any, options: any, callback: any, ...args: any[]): any;

            static from(body: any): any;

            static getEventListeners(emitterOrTarget: any, type: any): any;

            static init(opts: any): void;

            static isDisturbed(stream: any): any;

            static isErrored(stream: any): any;

            static isReadable(stream: any): any;

            static kMaxEventTargetListeners: any;

            static kMaxEventTargetListenersWarned: any;

            static listenerCount(emitter: any, type: any): any;

            static on(emitter: any, event: any, options: any): any;

            static once(emitter: any, name: any, options: any): any;

            static pipeline(streams: any): any;

            static setMaxListeners(n: any, eventTargets: any): void;

            static usingDomains: boolean;

            static wrap(src: any, options: any): any;

        }

        class EventEmitter {
            constructor(opts: any);

            addListener(type: any, listener: any): any;

            emit(type: any, args: any): any;

            eventNames(): any;

            getMaxListeners(): any;

            listenerCount(type: any): any;

            listeners(type: any): any;

            off(type: any, listener: any): any;

            on(type: any, listener: any): any;

            once(type: any, listener: any): any;

            prependListener(type: any, listener: any): any;

            prependOnceListener(type: any, listener: any): any;

            rawListeners(type: any): any;

            removeAllListeners(type: any, ...args: any[]): any;

            removeListener(type: any, listener: any): any;

            setMaxListeners(n: any): any;

            static EventEmitter: any;

            static captureRejectionSymbol: any;

            static captureRejections: boolean;

            static defaultMaxListeners: number;

            static errorMonitor: any;

            static getEventListeners(emitterOrTarget: any, type: any): any;

            static init(opts: any): void;

            static kMaxEventTargetListeners: any;

            static kMaxEventTargetListenersWarned: any;

            static listenerCount(emitter: any, type: any): any;

            static on(emitter: any, event: any, options: any): any;

            static once(emitter: any, name: any, options: any): any;

            static setMaxListeners(n: any, eventTargets: any): void;

            static usingDomains: boolean;

        }

        class EventEmitterAsyncResource {
            constructor(...args: any[]);

            emit(...args: any[]): void;

            emitDestroy(...args: any[]): void;

            static EventEmitterAsyncResource: any;

            static captureRejectionSymbol: any;

            static captureRejections: boolean;

            static defaultMaxListeners: number;

            static errorMonitor: any;

            static getEventListeners(emitterOrTarget: any, type: any): any;

            static init(opts: any): void;

            static kMaxEventTargetListeners: any;

            static kMaxEventTargetListenersWarned: any;

            static listenerCount(emitter: any, type: any): any;

            static on(emitter: any, event: any, options: any): any;

            static once(emitter: any, name: any, options: any): any;

            static setMaxListeners(n: any, eventTargets: any): void;

            static usingDomains: boolean;

        }

        class PassThrough {
            constructor(options: any);

            static PassThrough: any;

            static Writable: any;

            static addAbortSignal(signal: any, stream: any): any;

            static captureRejectionSymbol: any;

            static captureRejections: boolean;

            static compose(streams: any): any;

            static defaultMaxListeners: number;

            static destroy(stream: any, err: any): any;

            static errorMonitor: any;

            static finished(stream: any, options: any, callback: any, ...args: any[]): any;

            static from(body: any): any;

            static getEventListeners(emitterOrTarget: any, type: any): any;

            static init(opts: any): void;

            static isDisturbed(stream: any): any;

            static isErrored(stream: any): any;

            static isReadable(stream: any): any;

            static kMaxEventTargetListeners: any;

            static kMaxEventTargetListenersWarned: any;

            static listenerCount(emitter: any, type: any): any;

            static on(emitter: any, event: any, options: any): any;

            static once(emitter: any, name: any, options: any): any;

            static pipeline(streams: any): any;

            static setMaxListeners(n: any, eventTargets: any): void;

            static usingDomains: boolean;

            static wrap(src: any, options: any): any;

        }

        class Readable {
            constructor(options: any);

            addListener(ev: any, fn: any): any;

            destroy(err: any, cb: any): any;

            filter(args: any): any;

            isPaused(): any;

            iterator(options: any): any;

            map(args: any): any;

            off(ev: any, fn: any): any;

            on(ev: any, fn: any): any;

            pause(): any;

            pipe(dest: any, pipeOpts: any): any;

            push(chunk: any, encoding: any): any;

            read(n: any): any;

            removeAllListeners(ev: any, ...args: any[]): any;

            removeListener(ev: any, fn: any): any;

            resume(): any;

            setEncoding(enc: any): any;

            unpipe(dest: any): any;

            unshift(chunk: any, encoding: any): any;

            wrap(stream: any): any;

            static Readable: any;

            static Writable: any;

            static addAbortSignal(signal: any, stream: any): any;

            static captureRejectionSymbol: any;

            static captureRejections: boolean;

            static compose(streams: any): any;

            static defaultMaxListeners: number;

            static destroy(stream: any, err: any): any;

            static errorMonitor: any;

            static finished(stream: any, options: any, callback: any, ...args: any[]): any;

            static from(iterable: any, opts: any): any;

            static getEventListeners(emitterOrTarget: any, type: any): any;

            static init(opts: any): void;

            static isDisturbed(stream: any): any;

            static isErrored(stream: any): any;

            static isReadable(stream: any): any;

            static kMaxEventTargetListeners: any;

            static kMaxEventTargetListenersWarned: any;

            static listenerCount(emitter: any, type: any): any;

            static on(emitter: any, event: any, options: any): any;

            static once(emitter: any, name: any, options: any): any;

            static pipeline(streams: any): any;

            static setMaxListeners(n: any, eventTargets: any): void;

            static usingDomains: boolean;

            static wrap(src: any, options: any): any;

        }

        class Stream {
            constructor(opts: any);

            pipe(dest: any, options: any): any;

            static Stream: any;

            static Writable: any;

            static addAbortSignal(signal: any, stream: any): any;

            static captureRejectionSymbol: any;

            static captureRejections: boolean;

            static compose(streams: any): any;

            static defaultMaxListeners: number;

            static destroy(stream: any, err: any): any;

            static errorMonitor: any;

            static finished(stream: any, options: any, callback: any, ...args: any[]): any;

            static getEventListeners(emitterOrTarget: any, type: any): any;

            static init(opts: any): void;

            static isDisturbed(stream: any): any;

            static isErrored(stream: any): any;

            static isReadable(stream: any): any;

            static kMaxEventTargetListeners: any;

            static kMaxEventTargetListenersWarned: any;

            static listenerCount(emitter: any, type: any): any;

            static on(emitter: any, event: any, options: any): any;

            static once(emitter: any, name: any, options: any): any;

            static pipeline(streams: any): any;

            static setMaxListeners(n: any, eventTargets: any): void;

            static usingDomains: boolean;

        }

        class Transform {
            constructor(options: any);

            static Transform: any;

            static Writable: any;

            static addAbortSignal(signal: any, stream: any): any;

            static captureRejectionSymbol: any;

            static captureRejections: boolean;

            static compose(streams: any): any;

            static defaultMaxListeners: number;

            static destroy(stream: any, err: any): any;

            static errorMonitor: any;

            static finished(stream: any, options: any, callback: any, ...args: any[]): any;

            static from(body: any): any;

            static getEventListeners(emitterOrTarget: any, type: any): any;

            static init(opts: any): void;

            static isDisturbed(stream: any): any;

            static isErrored(stream: any): any;

            static isReadable(stream: any): any;

            static kMaxEventTargetListeners: any;

            static kMaxEventTargetListenersWarned: any;

            static listenerCount(emitter: any, type: any): any;

            static on(emitter: any, event: any, options: any): any;

            static once(emitter: any, name: any, options: any): any;

            static pipeline(streams: any): any;

            static setMaxListeners(n: any, eventTargets: any): void;

            static usingDomains: boolean;

            static wrap(src: any, options: any): any;

        }

        class WritableState {
            constructor(options: any, stream: any, isDuplex: any);

            getBuffer(): any;

        }

        namespace Duplex {
            class EventEmitter {
                constructor(opts: any);

                addListener(type: any, listener: any): any;

                emit(type: any, args: any): any;

                eventNames(): any;

                getMaxListeners(): any;

                listenerCount(type: any): any;

                listeners(type: any): any;

                off(type: any, listener: any): any;

                on(type: any, listener: any): any;

                once(type: any, listener: any): any;

                prependListener(type: any, listener: any): any;

                prependOnceListener(type: any, listener: any): any;

                rawListeners(type: any): any;

                removeAllListeners(type: any, ...args: any[]): any;

                removeListener(type: any, listener: any): any;

                setMaxListeners(n: any): any;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static defaultMaxListeners: any;

                static errorMonitor: any;

                static getEventListeners: any;

                static init: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static setMaxListeners: any;

                static usingDomains: any;

            }

            class EventEmitterAsyncResource {
                constructor(...args: any[]);

                emit(...args: any[]): void;

                emitDestroy(...args: any[]): void;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static defaultMaxListeners: any;

                static errorMonitor: any;

                static getEventListeners: any;

                static init: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static setMaxListeners: any;

                static usingDomains: any;

            }

            class PassThrough {
                constructor(options: any);

                static Duplex: any;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static PassThrough: any;

                static Readable: any;

                static ReadableState: any;

                static Stream: any;

                static Transform: any;

                static Writable: any;

                static addAbortSignal: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static compose: any;

                static defaultMaxListeners: any;

                static destroy: any;

                static errorMonitor: any;

                static finished: any;

                static from: any;

                static getEventListeners: any;

                static init: any;

                static isDisturbed: any;

                static isErrored: any;

                static isReadable: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static pipeline: any;

                static promises: any;

                static setMaxListeners: any;

                static usingDomains: any;

                static wrap: any;

            }

            class Readable {
                constructor(options: any);

                addListener(ev: any, fn: any): any;

                destroy(err: any, cb: any): any;

                filter(args: any): any;

                isPaused(): any;

                iterator(options: any): any;

                map(args: any): any;

                off(ev: any, fn: any): any;

                on(ev: any, fn: any): any;

                pause(): any;

                pipe(dest: any, pipeOpts: any): any;

                push(chunk: any, encoding: any): any;

                read(n: any): any;

                removeAllListeners(ev: any, ...args: any[]): any;

                removeListener(ev: any, fn: any): any;

                resume(): any;

                setEncoding(enc: any): any;

                unpipe(dest: any): any;

                unshift(chunk: any, encoding: any): any;

                wrap(stream: any): any;

                static Duplex: any;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static PassThrough: any;

                static Readable: any;

                static ReadableState: any;

                static Stream: any;

                static Transform: any;

                static Writable: any;

                static addAbortSignal: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static compose: any;

                static defaultMaxListeners: any;

                static destroy: any;

                static errorMonitor: any;

                static finished: any;

                static from: any;

                static getEventListeners: any;

                static init: any;

                static isDisturbed: any;

                static isErrored: any;

                static isReadable: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static pipeline: any;

                static promises: any;

                static setMaxListeners: any;

                static usingDomains: any;

                static wrap: any;

            }

            class ReadableState {
                constructor(options: any, stream: any, isDuplex: any);

            }

            class Stream {
                constructor(opts: any);

                pipe(dest: any, options: any): any;

                static Duplex: any;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static PassThrough: any;

                static Readable: any;

                static Stream: any;

                static Transform: any;

                static Writable: any;

                static addAbortSignal: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static compose: any;

                static defaultMaxListeners: any;

                static destroy: any;

                static errorMonitor: any;

                static finished: any;

                static getEventListeners: any;

                static init: any;

                static isDisturbed: any;

                static isErrored: any;

                static isReadable: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static pipeline: any;

                static promises: any;

                static setMaxListeners: any;

                static usingDomains: any;

            }

            class Transform {
                constructor(options: any);

                static Duplex: any;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static PassThrough: any;

                static Readable: any;

                static ReadableState: any;

                static Stream: any;

                static Transform: any;

                static Writable: any;

                static addAbortSignal: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static compose: any;

                static defaultMaxListeners: any;

                static destroy: any;

                static errorMonitor: any;

                static finished: any;

                static from: any;

                static getEventListeners: any;

                static init: any;

                static isDisturbed: any;

                static isErrored: any;

                static isReadable: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static pipeline: any;

                static promises: any;

                static setMaxListeners: any;

                static usingDomains: any;

                static wrap: any;

            }

            namespace promises {
                // Too-deep object hierarchy from fs.FileWriteStream.Writable.Duplex.promises
                const finished: any;

                // Too-deep object hierarchy from fs.FileWriteStream.Writable.Duplex.promises
                const pipeline: any;

            }

        }

        namespace EventEmitter {
            class EventEmitterAsyncResource {
                constructor(...args: any[]);

                emit(...args: any[]): void;

                emitDestroy(...args: any[]): void;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static defaultMaxListeners: any;

                static errorMonitor: any;

                static getEventListeners: any;

                static init: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static setMaxListeners: any;

                static usingDomains: any;

            }

        }

        namespace EventEmitterAsyncResource {
            class EventEmitter {
                constructor(opts: any);

                addListener(type: any, listener: any): any;

                emit(type: any, args: any): any;

                eventNames(): any;

                getMaxListeners(): any;

                listenerCount(type: any): any;

                listeners(type: any): any;

                off(type: any, listener: any): any;

                on(type: any, listener: any): any;

                once(type: any, listener: any): any;

                prependListener(type: any, listener: any): any;

                prependOnceListener(type: any, listener: any): any;

                rawListeners(type: any): any;

                removeAllListeners(type: any, ...args: any[]): any;

                removeListener(type: any, listener: any): any;

                setMaxListeners(n: any): any;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static defaultMaxListeners: any;

                static errorMonitor: any;

                static getEventListeners: any;

                static init: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static setMaxListeners: any;

                static usingDomains: any;

            }

        }

        namespace PassThrough {
            class Duplex {
                constructor(options: any);

                cork(): void;

                end(chunk: any, encoding: any, cb: any): any;

                setDefaultEncoding(encoding: any): any;

                uncork(): void;

                write(chunk: any, encoding: any, cb: any): any;

                static Duplex: any;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static PassThrough: any;

                static Readable: any;

                static ReadableState: any;

                static Stream: any;

                static Transform: any;

                static Writable: any;

                static addAbortSignal: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static compose: any;

                static defaultMaxListeners: any;

                static destroy: any;

                static errorMonitor: any;

                static finished: any;

                static from: any;

                static getEventListeners: any;

                static init: any;

                static isDisturbed: any;

                static isErrored: any;

                static isReadable: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static pipeline: any;

                static promises: any;

                static setMaxListeners: any;

                static usingDomains: any;

                static wrap: any;

            }

            class EventEmitter {
                constructor(opts: any);

                addListener(type: any, listener: any): any;

                emit(type: any, args: any): any;

                eventNames(): any;

                getMaxListeners(): any;

                listenerCount(type: any): any;

                listeners(type: any): any;

                off(type: any, listener: any): any;

                on(type: any, listener: any): any;

                once(type: any, listener: any): any;

                prependListener(type: any, listener: any): any;

                prependOnceListener(type: any, listener: any): any;

                rawListeners(type: any): any;

                removeAllListeners(type: any, ...args: any[]): any;

                removeListener(type: any, listener: any): any;

                setMaxListeners(n: any): any;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static defaultMaxListeners: any;

                static errorMonitor: any;

                static getEventListeners: any;

                static init: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static setMaxListeners: any;

                static usingDomains: any;

            }

            class EventEmitterAsyncResource {
                constructor(...args: any[]);

                emit(...args: any[]): void;

                emitDestroy(...args: any[]): void;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static defaultMaxListeners: any;

                static errorMonitor: any;

                static getEventListeners: any;

                static init: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static setMaxListeners: any;

                static usingDomains: any;

            }

            class Readable {
                constructor(options: any);

                addListener(ev: any, fn: any): any;

                destroy(err: any, cb: any): any;

                filter(args: any): any;

                isPaused(): any;

                iterator(options: any): any;

                map(args: any): any;

                off(ev: any, fn: any): any;

                on(ev: any, fn: any): any;

                pause(): any;

                pipe(dest: any, pipeOpts: any): any;

                push(chunk: any, encoding: any): any;

                read(n: any): any;

                removeAllListeners(ev: any, ...args: any[]): any;

                removeListener(ev: any, fn: any): any;

                resume(): any;

                setEncoding(enc: any): any;

                unpipe(dest: any): any;

                unshift(chunk: any, encoding: any): any;

                wrap(stream: any): any;

                static Duplex: any;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static PassThrough: any;

                static Readable: any;

                static ReadableState: any;

                static Stream: any;

                static Transform: any;

                static Writable: any;

                static addAbortSignal: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static compose: any;

                static defaultMaxListeners: any;

                static destroy: any;

                static errorMonitor: any;

                static finished: any;

                static from: any;

                static getEventListeners: any;

                static init: any;

                static isDisturbed: any;

                static isErrored: any;

                static isReadable: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static pipeline: any;

                static promises: any;

                static setMaxListeners: any;

                static usingDomains: any;

                static wrap: any;

            }

            class ReadableState {
                constructor(options: any, stream: any, isDuplex: any);

            }

            class Stream {
                constructor(opts: any);

                pipe(dest: any, options: any): any;

                static Duplex: any;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static PassThrough: any;

                static Readable: any;

                static Stream: any;

                static Transform: any;

                static Writable: any;

                static addAbortSignal: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static compose: any;

                static defaultMaxListeners: any;

                static destroy: any;

                static errorMonitor: any;

                static finished: any;

                static getEventListeners: any;

                static init: any;

                static isDisturbed: any;

                static isErrored: any;

                static isReadable: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static pipeline: any;

                static promises: any;

                static setMaxListeners: any;

                static usingDomains: any;

            }

            class Transform {
                constructor(options: any);

                static Duplex: any;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static PassThrough: any;

                static Readable: any;

                static ReadableState: any;

                static Stream: any;

                static Transform: any;

                static Writable: any;

                static addAbortSignal: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static compose: any;

                static defaultMaxListeners: any;

                static destroy: any;

                static errorMonitor: any;

                static finished: any;

                static from: any;

                static getEventListeners: any;

                static init: any;

                static isDisturbed: any;

                static isErrored: any;

                static isReadable: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static pipeline: any;

                static promises: any;

                static setMaxListeners: any;

                static usingDomains: any;

                static wrap: any;

            }

            namespace promises {
                // Too-deep object hierarchy from fs.FileWriteStream.Writable.PassThrough.promises
                const finished: any;

                // Too-deep object hierarchy from fs.FileWriteStream.Writable.PassThrough.promises
                const pipeline: any;

            }

        }

        namespace Readable {
            class Duplex {
                constructor(options: any);

                cork(): void;

                end(chunk: any, encoding: any, cb: any): any;

                setDefaultEncoding(encoding: any): any;

                uncork(): void;

                write(chunk: any, encoding: any, cb: any): any;

                static Duplex: any;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static PassThrough: any;

                static Readable: any;

                static ReadableState: any;

                static Stream: any;

                static Transform: any;

                static Writable: any;

                static addAbortSignal: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static compose: any;

                static defaultMaxListeners: any;

                static destroy: any;

                static errorMonitor: any;

                static finished: any;

                static from: any;

                static getEventListeners: any;

                static init: any;

                static isDisturbed: any;

                static isErrored: any;

                static isReadable: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static pipeline: any;

                static promises: any;

                static setMaxListeners: any;

                static usingDomains: any;

                static wrap: any;

            }

            class EventEmitter {
                constructor(opts: any);

                addListener(type: any, listener: any): any;

                emit(type: any, args: any): any;

                eventNames(): any;

                getMaxListeners(): any;

                listenerCount(type: any): any;

                listeners(type: any): any;

                off(type: any, listener: any): any;

                on(type: any, listener: any): any;

                once(type: any, listener: any): any;

                prependListener(type: any, listener: any): any;

                prependOnceListener(type: any, listener: any): any;

                rawListeners(type: any): any;

                removeAllListeners(type: any, ...args: any[]): any;

                removeListener(type: any, listener: any): any;

                setMaxListeners(n: any): any;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static defaultMaxListeners: any;

                static errorMonitor: any;

                static getEventListeners: any;

                static init: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static setMaxListeners: any;

                static usingDomains: any;

            }

            class EventEmitterAsyncResource {
                constructor(...args: any[]);

                emit(...args: any[]): void;

                emitDestroy(...args: any[]): void;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static defaultMaxListeners: any;

                static errorMonitor: any;

                static getEventListeners: any;

                static init: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static setMaxListeners: any;

                static usingDomains: any;

            }

            class PassThrough {
                constructor(options: any);

                static Duplex: any;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static PassThrough: any;

                static Readable: any;

                static ReadableState: any;

                static Stream: any;

                static Transform: any;

                static Writable: any;

                static addAbortSignal: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static compose: any;

                static defaultMaxListeners: any;

                static destroy: any;

                static errorMonitor: any;

                static finished: any;

                static from: any;

                static getEventListeners: any;

                static init: any;

                static isDisturbed: any;

                static isErrored: any;

                static isReadable: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static pipeline: any;

                static promises: any;

                static setMaxListeners: any;

                static usingDomains: any;

                static wrap: any;

            }

            class ReadableState {
                constructor(options: any, stream: any, isDuplex: any);

            }

            class Stream {
                constructor(opts: any);

                pipe(dest: any, options: any): any;

                static Duplex: any;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static PassThrough: any;

                static Readable: any;

                static Stream: any;

                static Transform: any;

                static Writable: any;

                static addAbortSignal: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static compose: any;

                static defaultMaxListeners: any;

                static destroy: any;

                static errorMonitor: any;

                static finished: any;

                static getEventListeners: any;

                static init: any;

                static isDisturbed: any;

                static isErrored: any;

                static isReadable: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static pipeline: any;

                static promises: any;

                static setMaxListeners: any;

                static usingDomains: any;

            }

            class Transform {
                constructor(options: any);

                static Duplex: any;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static PassThrough: any;

                static Readable: any;

                static ReadableState: any;

                static Stream: any;

                static Transform: any;

                static Writable: any;

                static addAbortSignal: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static compose: any;

                static defaultMaxListeners: any;

                static destroy: any;

                static errorMonitor: any;

                static finished: any;

                static from: any;

                static getEventListeners: any;

                static init: any;

                static isDisturbed: any;

                static isErrored: any;

                static isReadable: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static pipeline: any;

                static promises: any;

                static setMaxListeners: any;

                static usingDomains: any;

                static wrap: any;

            }

            namespace promises {
                // Too-deep object hierarchy from fs.FileWriteStream.Writable.Readable.promises
                const finished: any;

                // Too-deep object hierarchy from fs.FileWriteStream.Writable.Readable.promises
                const pipeline: any;

            }

        }

        namespace Stream {
            class Duplex {
                constructor(options: any);

                cork(): void;

                end(chunk: any, encoding: any, cb: any): any;

                setDefaultEncoding(encoding: any): any;

                uncork(): void;

                write(chunk: any, encoding: any, cb: any): any;

                static Duplex: any;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static PassThrough: any;

                static Readable: any;

                static ReadableState: any;

                static Stream: any;

                static Transform: any;

                static Writable: any;

                static addAbortSignal: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static compose: any;

                static defaultMaxListeners: any;

                static destroy: any;

                static errorMonitor: any;

                static finished: any;

                static from: any;

                static getEventListeners: any;

                static init: any;

                static isDisturbed: any;

                static isErrored: any;

                static isReadable: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static pipeline: any;

                static promises: any;

                static setMaxListeners: any;

                static usingDomains: any;

                static wrap: any;

            }

            class EventEmitter {
                constructor(opts: any);

                addListener(type: any, listener: any): any;

                emit(type: any, args: any): any;

                eventNames(): any;

                getMaxListeners(): any;

                listenerCount(type: any): any;

                listeners(type: any): any;

                off(type: any, listener: any): any;

                on(type: any, listener: any): any;

                once(type: any, listener: any): any;

                prependListener(type: any, listener: any): any;

                prependOnceListener(type: any, listener: any): any;

                rawListeners(type: any): any;

                removeAllListeners(type: any, ...args: any[]): any;

                removeListener(type: any, listener: any): any;

                setMaxListeners(n: any): any;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static defaultMaxListeners: any;

                static errorMonitor: any;

                static getEventListeners: any;

                static init: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static setMaxListeners: any;

                static usingDomains: any;

            }

            class EventEmitterAsyncResource {
                constructor(...args: any[]);

                emit(...args: any[]): void;

                emitDestroy(...args: any[]): void;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static defaultMaxListeners: any;

                static errorMonitor: any;

                static getEventListeners: any;

                static init: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static setMaxListeners: any;

                static usingDomains: any;

            }

            class PassThrough {
                constructor(options: any);

                static Duplex: any;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static PassThrough: any;

                static Readable: any;

                static ReadableState: any;

                static Stream: any;

                static Transform: any;

                static Writable: any;

                static addAbortSignal: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static compose: any;

                static defaultMaxListeners: any;

                static destroy: any;

                static errorMonitor: any;

                static finished: any;

                static from: any;

                static getEventListeners: any;

                static init: any;

                static isDisturbed: any;

                static isErrored: any;

                static isReadable: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static pipeline: any;

                static promises: any;

                static setMaxListeners: any;

                static usingDomains: any;

                static wrap: any;

            }

            class Readable {
                constructor(options: any);

                addListener(ev: any, fn: any): any;

                destroy(err: any, cb: any): any;

                filter(args: any): any;

                isPaused(): any;

                iterator(options: any): any;

                map(args: any): any;

                off(ev: any, fn: any): any;

                on(ev: any, fn: any): any;

                pause(): any;

                pipe(dest: any, pipeOpts: any): any;

                push(chunk: any, encoding: any): any;

                read(n: any): any;

                removeAllListeners(ev: any, ...args: any[]): any;

                removeListener(ev: any, fn: any): any;

                resume(): any;

                setEncoding(enc: any): any;

                unpipe(dest: any): any;

                unshift(chunk: any, encoding: any): any;

                wrap(stream: any): any;

                static Duplex: any;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static PassThrough: any;

                static Readable: any;

                static ReadableState: any;

                static Stream: any;

                static Transform: any;

                static Writable: any;

                static addAbortSignal: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static compose: any;

                static defaultMaxListeners: any;

                static destroy: any;

                static errorMonitor: any;

                static finished: any;

                static from: any;

                static getEventListeners: any;

                static init: any;

                static isDisturbed: any;

                static isErrored: any;

                static isReadable: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static pipeline: any;

                static promises: any;

                static setMaxListeners: any;

                static usingDomains: any;

                static wrap: any;

            }

            class Transform {
                constructor(options: any);

                static Duplex: any;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static PassThrough: any;

                static Readable: any;

                static ReadableState: any;

                static Stream: any;

                static Transform: any;

                static Writable: any;

                static addAbortSignal: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static compose: any;

                static defaultMaxListeners: any;

                static destroy: any;

                static errorMonitor: any;

                static finished: any;

                static from: any;

                static getEventListeners: any;

                static init: any;

                static isDisturbed: any;

                static isErrored: any;

                static isReadable: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static pipeline: any;

                static promises: any;

                static setMaxListeners: any;

                static usingDomains: any;

                static wrap: any;

            }

            namespace promises {
                // Too-deep object hierarchy from fs.FileWriteStream.Writable.Stream.promises
                const finished: any;

                // Too-deep object hierarchy from fs.FileWriteStream.Writable.Stream.promises
                const pipeline: any;

            }

        }

        namespace Transform {
            class Duplex {
                constructor(options: any);

                cork(): void;

                end(chunk: any, encoding: any, cb: any): any;

                setDefaultEncoding(encoding: any): any;

                uncork(): void;

                write(chunk: any, encoding: any, cb: any): any;

                static Duplex: any;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static PassThrough: any;

                static Readable: any;

                static ReadableState: any;

                static Stream: any;

                static Transform: any;

                static Writable: any;

                static addAbortSignal: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static compose: any;

                static defaultMaxListeners: any;

                static destroy: any;

                static errorMonitor: any;

                static finished: any;

                static from: any;

                static getEventListeners: any;

                static init: any;

                static isDisturbed: any;

                static isErrored: any;

                static isReadable: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static pipeline: any;

                static promises: any;

                static setMaxListeners: any;

                static usingDomains: any;

                static wrap: any;

            }

            class EventEmitter {
                constructor(opts: any);

                addListener(type: any, listener: any): any;

                emit(type: any, args: any): any;

                eventNames(): any;

                getMaxListeners(): any;

                listenerCount(type: any): any;

                listeners(type: any): any;

                off(type: any, listener: any): any;

                on(type: any, listener: any): any;

                once(type: any, listener: any): any;

                prependListener(type: any, listener: any): any;

                prependOnceListener(type: any, listener: any): any;

                rawListeners(type: any): any;

                removeAllListeners(type: any, ...args: any[]): any;

                removeListener(type: any, listener: any): any;

                setMaxListeners(n: any): any;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static defaultMaxListeners: any;

                static errorMonitor: any;

                static getEventListeners: any;

                static init: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static setMaxListeners: any;

                static usingDomains: any;

            }

            class EventEmitterAsyncResource {
                constructor(...args: any[]);

                emit(...args: any[]): void;

                emitDestroy(...args: any[]): void;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static defaultMaxListeners: any;

                static errorMonitor: any;

                static getEventListeners: any;

                static init: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static setMaxListeners: any;

                static usingDomains: any;

            }

            class PassThrough {
                constructor(options: any);

                static Duplex: any;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static PassThrough: any;

                static Readable: any;

                static ReadableState: any;

                static Stream: any;

                static Transform: any;

                static Writable: any;

                static addAbortSignal: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static compose: any;

                static defaultMaxListeners: any;

                static destroy: any;

                static errorMonitor: any;

                static finished: any;

                static from: any;

                static getEventListeners: any;

                static init: any;

                static isDisturbed: any;

                static isErrored: any;

                static isReadable: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static pipeline: any;

                static promises: any;

                static setMaxListeners: any;

                static usingDomains: any;

                static wrap: any;

            }

            class Readable {
                constructor(options: any);

                addListener(ev: any, fn: any): any;

                destroy(err: any, cb: any): any;

                filter(args: any): any;

                isPaused(): any;

                iterator(options: any): any;

                map(args: any): any;

                off(ev: any, fn: any): any;

                on(ev: any, fn: any): any;

                pause(): any;

                pipe(dest: any, pipeOpts: any): any;

                push(chunk: any, encoding: any): any;

                read(n: any): any;

                removeAllListeners(ev: any, ...args: any[]): any;

                removeListener(ev: any, fn: any): any;

                resume(): any;

                setEncoding(enc: any): any;

                unpipe(dest: any): any;

                unshift(chunk: any, encoding: any): any;

                wrap(stream: any): any;

                static Duplex: any;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static PassThrough: any;

                static Readable: any;

                static ReadableState: any;

                static Stream: any;

                static Transform: any;

                static Writable: any;

                static addAbortSignal: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static compose: any;

                static defaultMaxListeners: any;

                static destroy: any;

                static errorMonitor: any;

                static finished: any;

                static from: any;

                static getEventListeners: any;

                static init: any;

                static isDisturbed: any;

                static isErrored: any;

                static isReadable: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static pipeline: any;

                static promises: any;

                static setMaxListeners: any;

                static usingDomains: any;

                static wrap: any;

            }

            class ReadableState {
                constructor(options: any, stream: any, isDuplex: any);

            }

            class Stream {
                constructor(opts: any);

                pipe(dest: any, options: any): any;

                static Duplex: any;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static PassThrough: any;

                static Readable: any;

                static Stream: any;

                static Transform: any;

                static Writable: any;

                static addAbortSignal: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static compose: any;

                static defaultMaxListeners: any;

                static destroy: any;

                static errorMonitor: any;

                static finished: any;

                static getEventListeners: any;

                static init: any;

                static isDisturbed: any;

                static isErrored: any;

                static isReadable: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static pipeline: any;

                static promises: any;

                static setMaxListeners: any;

                static usingDomains: any;

            }

            namespace promises {
                // Too-deep object hierarchy from fs.FileWriteStream.Writable.Transform.promises
                const finished: any;

                // Too-deep object hierarchy from fs.FileWriteStream.Writable.Transform.promises
                const pipeline: any;

            }

        }

        namespace promises {
            function finished(stream: any, opts: any): any;

            function pipeline(streams: any): any;

        }

    }

    namespace promises {
        function finished(stream: any, opts: any): any;

        function pipeline(streams: any): any;

    }

}

export namespace ReadStream {
    class Duplex {
        constructor(options: any);

        cork(): void;

        end(chunk: any, encoding: any, cb: any): any;

        setDefaultEncoding(encoding: any): any;

        uncork(): void;

        write(chunk: any, encoding: any, cb: any): any;

        static Duplex: any;

        static addAbortSignal(signal: any, stream: any): any;

        static captureRejectionSymbol: any;

        static captureRejections: boolean;

        static compose(streams: any): any;

        static defaultMaxListeners: number;

        static destroy(stream: any, err: any): any;

        static errorMonitor: any;

        static finished(stream: any, options: any, callback: any, ...args: any[]): any;

        static from(body: any): any;

        static getEventListeners(emitterOrTarget: any, type: any): any;

        static init(opts: any): void;

        static isDisturbed(stream: any): any;

        static isErrored(stream: any): any;

        static isReadable(stream: any): any;

        static kMaxEventTargetListeners: any;

        static kMaxEventTargetListenersWarned: any;

        static listenerCount(emitter: any, type: any): any;

        static on(emitter: any, event: any, options: any): any;

        static once(emitter: any, name: any, options: any): any;

        static pipeline(streams: any): any;

        static setMaxListeners(n: any, eventTargets: any): void;

        static usingDomains: boolean;

        static wrap(src: any, options: any): any;

    }

    class EventEmitter {
        constructor(opts: any);

        addListener(type: any, listener: any): any;

        emit(type: any, args: any): any;

        eventNames(): any;

        getMaxListeners(): any;

        listenerCount(type: any): any;

        listeners(type: any): any;

        off(type: any, listener: any): any;

        on(type: any, listener: any): any;

        once(type: any, listener: any): any;

        prependListener(type: any, listener: any): any;

        prependOnceListener(type: any, listener: any): any;

        rawListeners(type: any): any;

        removeAllListeners(type: any, ...args: any[]): any;

        removeListener(type: any, listener: any): any;

        setMaxListeners(n: any): any;

        static EventEmitter: any;

        static captureRejectionSymbol: any;

        static captureRejections: boolean;

        static defaultMaxListeners: number;

        static errorMonitor: any;

        static getEventListeners(emitterOrTarget: any, type: any): any;

        static init(opts: any): void;

        static kMaxEventTargetListeners: any;

        static kMaxEventTargetListenersWarned: any;

        static listenerCount(emitter: any, type: any): any;

        static on(emitter: any, event: any, options: any): any;

        static once(emitter: any, name: any, options: any): any;

        static setMaxListeners(n: any, eventTargets: any): void;

        static usingDomains: boolean;

    }

    class EventEmitterAsyncResource {
        constructor(...args: any[]);

        emit(...args: any[]): void;

        emitDestroy(...args: any[]): void;

        static EventEmitterAsyncResource: any;

        static captureRejectionSymbol: any;

        static captureRejections: boolean;

        static defaultMaxListeners: number;

        static errorMonitor: any;

        static getEventListeners(emitterOrTarget: any, type: any): any;

        static init(opts: any): void;

        static kMaxEventTargetListeners: any;

        static kMaxEventTargetListenersWarned: any;

        static listenerCount(emitter: any, type: any): any;

        static on(emitter: any, event: any, options: any): any;

        static once(emitter: any, name: any, options: any): any;

        static setMaxListeners(n: any, eventTargets: any): void;

        static usingDomains: boolean;

    }

    class PassThrough {
        constructor(options: any);

        static PassThrough: any;

        static addAbortSignal(signal: any, stream: any): any;

        static captureRejectionSymbol: any;

        static captureRejections: boolean;

        static compose(streams: any): any;

        static defaultMaxListeners: number;

        static destroy(stream: any, err: any): any;

        static errorMonitor: any;

        static finished(stream: any, options: any, callback: any, ...args: any[]): any;

        static from(body: any): any;

        static getEventListeners(emitterOrTarget: any, type: any): any;

        static init(opts: any): void;

        static isDisturbed(stream: any): any;

        static isErrored(stream: any): any;

        static isReadable(stream: any): any;

        static kMaxEventTargetListeners: any;

        static kMaxEventTargetListenersWarned: any;

        static listenerCount(emitter: any, type: any): any;

        static on(emitter: any, event: any, options: any): any;

        static once(emitter: any, name: any, options: any): any;

        static pipeline(streams: any): any;

        static setMaxListeners(n: any, eventTargets: any): void;

        static usingDomains: boolean;

        static wrap(src: any, options: any): any;

    }

    class Readable {
        constructor(options: any);

        addListener(ev: any, fn: any): any;

        destroy(err: any, cb: any): any;

        filter(args: any): any;

        isPaused(): any;

        iterator(options: any): any;

        map(args: any): any;

        off(ev: any, fn: any): any;

        on(ev: any, fn: any): any;

        pause(): any;

        pipe(dest: any, pipeOpts: any): any;

        push(chunk: any, encoding: any): any;

        read(n: any): any;

        removeAllListeners(ev: any, ...args: any[]): any;

        removeListener(ev: any, fn: any): any;

        resume(): any;

        setEncoding(enc: any): any;

        unpipe(dest: any): any;

        unshift(chunk: any, encoding: any): any;

        wrap(stream: any): any;

        static Readable: any;

        static addAbortSignal(signal: any, stream: any): any;

        static captureRejectionSymbol: any;

        static captureRejections: boolean;

        static compose(streams: any): any;

        static defaultMaxListeners: number;

        static destroy(stream: any, err: any): any;

        static errorMonitor: any;

        static finished(stream: any, options: any, callback: any, ...args: any[]): any;

        static from(iterable: any, opts: any): any;

        static getEventListeners(emitterOrTarget: any, type: any): any;

        static init(opts: any): void;

        static isDisturbed(stream: any): any;

        static isErrored(stream: any): any;

        static isReadable(stream: any): any;

        static kMaxEventTargetListeners: any;

        static kMaxEventTargetListenersWarned: any;

        static listenerCount(emitter: any, type: any): any;

        static on(emitter: any, event: any, options: any): any;

        static once(emitter: any, name: any, options: any): any;

        static pipeline(streams: any): any;

        static setMaxListeners(n: any, eventTargets: any): void;

        static usingDomains: boolean;

        static wrap(src: any, options: any): any;

    }

    class ReadableState {
        constructor(options: any, stream: any, isDuplex: any);

    }

    class Stream {
        constructor(opts: any);

        pipe(dest: any, options: any): any;

        static Stream: any;

        static addAbortSignal(signal: any, stream: any): any;

        static captureRejectionSymbol: any;

        static captureRejections: boolean;

        static compose(streams: any): any;

        static defaultMaxListeners: number;

        static destroy(stream: any, err: any): any;

        static errorMonitor: any;

        static finished(stream: any, options: any, callback: any, ...args: any[]): any;

        static getEventListeners(emitterOrTarget: any, type: any): any;

        static init(opts: any): void;

        static isDisturbed(stream: any): any;

        static isErrored(stream: any): any;

        static isReadable(stream: any): any;

        static kMaxEventTargetListeners: any;

        static kMaxEventTargetListenersWarned: any;

        static listenerCount(emitter: any, type: any): any;

        static on(emitter: any, event: any, options: any): any;

        static once(emitter: any, name: any, options: any): any;

        static pipeline(streams: any): any;

        static setMaxListeners(n: any, eventTargets: any): void;

        static usingDomains: boolean;

    }

    class Transform {
        constructor(options: any);

        static Transform: any;

        static addAbortSignal(signal: any, stream: any): any;

        static captureRejectionSymbol: any;

        static captureRejections: boolean;

        static compose(streams: any): any;

        static defaultMaxListeners: number;

        static destroy(stream: any, err: any): any;

        static errorMonitor: any;

        static finished(stream: any, options: any, callback: any, ...args: any[]): any;

        static from(body: any): any;

        static getEventListeners(emitterOrTarget: any, type: any): any;

        static init(opts: any): void;

        static isDisturbed(stream: any): any;

        static isErrored(stream: any): any;

        static isReadable(stream: any): any;

        static kMaxEventTargetListeners: any;

        static kMaxEventTargetListenersWarned: any;

        static listenerCount(emitter: any, type: any): any;

        static on(emitter: any, event: any, options: any): any;

        static once(emitter: any, name: any, options: any): any;

        static pipeline(streams: any): any;

        static setMaxListeners(n: any, eventTargets: any): void;

        static usingDomains: boolean;

        static wrap(src: any, options: any): any;

    }

    class Writable {
        constructor(options: any);

        cork(): void;

        destroy(err: any, cb: any): any;

        end(chunk: any, encoding: any, cb: any): any;

        pipe(): void;

        setDefaultEncoding(encoding: any): any;

        uncork(): void;

        write(chunk: any, encoding: any, cb: any): any;

        static Writable: any;

        static addAbortSignal(signal: any, stream: any): any;

        static captureRejectionSymbol: any;

        static captureRejections: boolean;

        static compose(streams: any): any;

        static defaultMaxListeners: number;

        static destroy(stream: any, err: any): any;

        static errorMonitor: any;

        static finished(stream: any, options: any, callback: any, ...args: any[]): any;

        static getEventListeners(emitterOrTarget: any, type: any): any;

        static init(opts: any): void;

        static isDisturbed(stream: any): any;

        static isErrored(stream: any): any;

        static isReadable(stream: any): any;

        static kMaxEventTargetListeners: any;

        static kMaxEventTargetListenersWarned: any;

        static listenerCount(emitter: any, type: any): any;

        static on(emitter: any, event: any, options: any): any;

        static once(emitter: any, name: any, options: any): any;

        static pipeline(streams: any): any;

        static setMaxListeners(n: any, eventTargets: any): void;

        static usingDomains: boolean;

    }

    namespace Duplex {
        class EventEmitter {
            constructor(opts: any);

            addListener(type: any, listener: any): any;

            emit(type: any, args: any): any;

            eventNames(): any;

            getMaxListeners(): any;

            listenerCount(type: any): any;

            listeners(type: any): any;

            off(type: any, listener: any): any;

            on(type: any, listener: any): any;

            once(type: any, listener: any): any;

            prependListener(type: any, listener: any): any;

            prependOnceListener(type: any, listener: any): any;

            rawListeners(type: any): any;

            removeAllListeners(type: any, ...args: any[]): any;

            removeListener(type: any, listener: any): any;

            setMaxListeners(n: any): any;

            static EventEmitter: any;

            static captureRejectionSymbol: any;

            static captureRejections: boolean;

            static defaultMaxListeners: number;

            static errorMonitor: any;

            static getEventListeners(emitterOrTarget: any, type: any): any;

            static init(opts: any): void;

            static kMaxEventTargetListeners: any;

            static kMaxEventTargetListenersWarned: any;

            static listenerCount(emitter: any, type: any): any;

            static on(emitter: any, event: any, options: any): any;

            static once(emitter: any, name: any, options: any): any;

            static setMaxListeners(n: any, eventTargets: any): void;

            static usingDomains: boolean;

        }

        class EventEmitterAsyncResource {
            constructor(...args: any[]);

            emit(...args: any[]): void;

            emitDestroy(...args: any[]): void;

            static EventEmitterAsyncResource: any;

            static captureRejectionSymbol: any;

            static captureRejections: boolean;

            static defaultMaxListeners: number;

            static errorMonitor: any;

            static getEventListeners(emitterOrTarget: any, type: any): any;

            static init(opts: any): void;

            static kMaxEventTargetListeners: any;

            static kMaxEventTargetListenersWarned: any;

            static listenerCount(emitter: any, type: any): any;

            static on(emitter: any, event: any, options: any): any;

            static once(emitter: any, name: any, options: any): any;

            static setMaxListeners(n: any, eventTargets: any): void;

            static usingDomains: boolean;

        }

        class PassThrough {
            constructor(options: any);

            static Duplex: any;

            static PassThrough: any;

            static addAbortSignal(signal: any, stream: any): any;

            static captureRejectionSymbol: any;

            static captureRejections: boolean;

            static compose(streams: any): any;

            static defaultMaxListeners: number;

            static destroy(stream: any, err: any): any;

            static errorMonitor: any;

            static finished(stream: any, options: any, callback: any, ...args: any[]): any;

            static from(body: any): any;

            static getEventListeners(emitterOrTarget: any, type: any): any;

            static init(opts: any): void;

            static isDisturbed(stream: any): any;

            static isErrored(stream: any): any;

            static isReadable(stream: any): any;

            static kMaxEventTargetListeners: any;

            static kMaxEventTargetListenersWarned: any;

            static listenerCount(emitter: any, type: any): any;

            static on(emitter: any, event: any, options: any): any;

            static once(emitter: any, name: any, options: any): any;

            static pipeline(streams: any): any;

            static setMaxListeners(n: any, eventTargets: any): void;

            static usingDomains: boolean;

            static wrap(src: any, options: any): any;

        }

        class Readable {
            constructor(options: any);

            addListener(ev: any, fn: any): any;

            destroy(err: any, cb: any): any;

            filter(args: any): any;

            isPaused(): any;

            iterator(options: any): any;

            map(args: any): any;

            off(ev: any, fn: any): any;

            on(ev: any, fn: any): any;

            pause(): any;

            pipe(dest: any, pipeOpts: any): any;

            push(chunk: any, encoding: any): any;

            read(n: any): any;

            removeAllListeners(ev: any, ...args: any[]): any;

            removeListener(ev: any, fn: any): any;

            resume(): any;

            setEncoding(enc: any): any;

            unpipe(dest: any): any;

            unshift(chunk: any, encoding: any): any;

            wrap(stream: any): any;

            static Duplex: any;

            static Readable: any;

            static addAbortSignal(signal: any, stream: any): any;

            static captureRejectionSymbol: any;

            static captureRejections: boolean;

            static compose(streams: any): any;

            static defaultMaxListeners: number;

            static destroy(stream: any, err: any): any;

            static errorMonitor: any;

            static finished(stream: any, options: any, callback: any, ...args: any[]): any;

            static from(iterable: any, opts: any): any;

            static getEventListeners(emitterOrTarget: any, type: any): any;

            static init(opts: any): void;

            static isDisturbed(stream: any): any;

            static isErrored(stream: any): any;

            static isReadable(stream: any): any;

            static kMaxEventTargetListeners: any;

            static kMaxEventTargetListenersWarned: any;

            static listenerCount(emitter: any, type: any): any;

            static on(emitter: any, event: any, options: any): any;

            static once(emitter: any, name: any, options: any): any;

            static pipeline(streams: any): any;

            static setMaxListeners(n: any, eventTargets: any): void;

            static usingDomains: boolean;

            static wrap(src: any, options: any): any;

        }

        class ReadableState {
            constructor(options: any, stream: any, isDuplex: any);

        }

        class Stream {
            constructor(opts: any);

            pipe(dest: any, options: any): any;

            static Duplex: any;

            static Stream: any;

            static addAbortSignal(signal: any, stream: any): any;

            static captureRejectionSymbol: any;

            static captureRejections: boolean;

            static compose(streams: any): any;

            static defaultMaxListeners: number;

            static destroy(stream: any, err: any): any;

            static errorMonitor: any;

            static finished(stream: any, options: any, callback: any, ...args: any[]): any;

            static getEventListeners(emitterOrTarget: any, type: any): any;

            static init(opts: any): void;

            static isDisturbed(stream: any): any;

            static isErrored(stream: any): any;

            static isReadable(stream: any): any;

            static kMaxEventTargetListeners: any;

            static kMaxEventTargetListenersWarned: any;

            static listenerCount(emitter: any, type: any): any;

            static on(emitter: any, event: any, options: any): any;

            static once(emitter: any, name: any, options: any): any;

            static pipeline(streams: any): any;

            static setMaxListeners(n: any, eventTargets: any): void;

            static usingDomains: boolean;

        }

        class Transform {
            constructor(options: any);

            static Duplex: any;

            static Transform: any;

            static addAbortSignal(signal: any, stream: any): any;

            static captureRejectionSymbol: any;

            static captureRejections: boolean;

            static compose(streams: any): any;

            static defaultMaxListeners: number;

            static destroy(stream: any, err: any): any;

            static errorMonitor: any;

            static finished(stream: any, options: any, callback: any, ...args: any[]): any;

            static from(body: any): any;

            static getEventListeners(emitterOrTarget: any, type: any): any;

            static init(opts: any): void;

            static isDisturbed(stream: any): any;

            static isErrored(stream: any): any;

            static isReadable(stream: any): any;

            static kMaxEventTargetListeners: any;

            static kMaxEventTargetListenersWarned: any;

            static listenerCount(emitter: any, type: any): any;

            static on(emitter: any, event: any, options: any): any;

            static once(emitter: any, name: any, options: any): any;

            static pipeline(streams: any): any;

            static setMaxListeners(n: any, eventTargets: any): void;

            static usingDomains: boolean;

            static wrap(src: any, options: any): any;

        }

        class Writable {
            constructor(options: any);

            cork(): void;

            destroy(err: any, cb: any): any;

            end(chunk: any, encoding: any, cb: any): any;

            pipe(): void;

            setDefaultEncoding(encoding: any): any;

            uncork(): void;

            write(chunk: any, encoding: any, cb: any): any;

            static Duplex: any;

            static Writable: any;

            static addAbortSignal(signal: any, stream: any): any;

            static captureRejectionSymbol: any;

            static captureRejections: boolean;

            static compose(streams: any): any;

            static defaultMaxListeners: number;

            static destroy(stream: any, err: any): any;

            static errorMonitor: any;

            static finished(stream: any, options: any, callback: any, ...args: any[]): any;

            static getEventListeners(emitterOrTarget: any, type: any): any;

            static init(opts: any): void;

            static isDisturbed(stream: any): any;

            static isErrored(stream: any): any;

            static isReadable(stream: any): any;

            static kMaxEventTargetListeners: any;

            static kMaxEventTargetListenersWarned: any;

            static listenerCount(emitter: any, type: any): any;

            static on(emitter: any, event: any, options: any): any;

            static once(emitter: any, name: any, options: any): any;

            static pipeline(streams: any): any;

            static setMaxListeners(n: any, eventTargets: any): void;

            static usingDomains: boolean;

        }

        namespace EventEmitter {
            class EventEmitterAsyncResource {
                constructor(...args: any[]);

                emit(...args: any[]): void;

                emitDestroy(...args: any[]): void;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static defaultMaxListeners: any;

                static errorMonitor: any;

                static getEventListeners: any;

                static init: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static setMaxListeners: any;

                static usingDomains: any;

            }

        }

        namespace EventEmitterAsyncResource {
            class EventEmitter {
                constructor(opts: any);

                addListener(type: any, listener: any): any;

                emit(type: any, args: any): any;

                eventNames(): any;

                getMaxListeners(): any;

                listenerCount(type: any): any;

                listeners(type: any): any;

                off(type: any, listener: any): any;

                on(type: any, listener: any): any;

                once(type: any, listener: any): any;

                prependListener(type: any, listener: any): any;

                prependOnceListener(type: any, listener: any): any;

                rawListeners(type: any): any;

                removeAllListeners(type: any, ...args: any[]): any;

                removeListener(type: any, listener: any): any;

                setMaxListeners(n: any): any;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static defaultMaxListeners: any;

                static errorMonitor: any;

                static getEventListeners: any;

                static init: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static setMaxListeners: any;

                static usingDomains: any;

            }

        }

        namespace PassThrough {
            class EventEmitter {
                constructor(opts: any);

                addListener(type: any, listener: any): any;

                emit(type: any, args: any): any;

                eventNames(): any;

                getMaxListeners(): any;

                listenerCount(type: any): any;

                listeners(type: any): any;

                off(type: any, listener: any): any;

                on(type: any, listener: any): any;

                once(type: any, listener: any): any;

                prependListener(type: any, listener: any): any;

                prependOnceListener(type: any, listener: any): any;

                rawListeners(type: any): any;

                removeAllListeners(type: any, ...args: any[]): any;

                removeListener(type: any, listener: any): any;

                setMaxListeners(n: any): any;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static defaultMaxListeners: any;

                static errorMonitor: any;

                static getEventListeners: any;

                static init: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static setMaxListeners: any;

                static usingDomains: any;

            }

            class EventEmitterAsyncResource {
                constructor(...args: any[]);

                emit(...args: any[]): void;

                emitDestroy(...args: any[]): void;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static defaultMaxListeners: any;

                static errorMonitor: any;

                static getEventListeners: any;

                static init: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static setMaxListeners: any;

                static usingDomains: any;

            }

            class Readable {
                constructor(options: any);

                addListener(ev: any, fn: any): any;

                destroy(err: any, cb: any): any;

                filter(args: any): any;

                isPaused(): any;

                iterator(options: any): any;

                map(args: any): any;

                off(ev: any, fn: any): any;

                on(ev: any, fn: any): any;

                pause(): any;

                pipe(dest: any, pipeOpts: any): any;

                push(chunk: any, encoding: any): any;

                read(n: any): any;

                removeAllListeners(ev: any, ...args: any[]): any;

                removeListener(ev: any, fn: any): any;

                resume(): any;

                setEncoding(enc: any): any;

                unpipe(dest: any): any;

                unshift(chunk: any, encoding: any): any;

                wrap(stream: any): any;

                static Duplex: any;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static PassThrough: any;

                static Readable: any;

                static ReadableState: any;

                static Stream: any;

                static Transform: any;

                static Writable: any;

                static addAbortSignal: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static compose: any;

                static defaultMaxListeners: any;

                static destroy: any;

                static errorMonitor: any;

                static finished: any;

                static from: any;

                static getEventListeners: any;

                static init: any;

                static isDisturbed: any;

                static isErrored: any;

                static isReadable: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static pipeline: any;

                static promises: any;

                static setMaxListeners: any;

                static usingDomains: any;

                static wrap: any;

            }

            class ReadableState {
                constructor(options: any, stream: any, isDuplex: any);

            }

            class Stream {
                constructor(opts: any);

                pipe(dest: any, options: any): any;

                static Duplex: any;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static PassThrough: any;

                static Readable: any;

                static Stream: any;

                static Transform: any;

                static Writable: any;

                static addAbortSignal: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static compose: any;

                static defaultMaxListeners: any;

                static destroy: any;

                static errorMonitor: any;

                static finished: any;

                static getEventListeners: any;

                static init: any;

                static isDisturbed: any;

                static isErrored: any;

                static isReadable: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static pipeline: any;

                static promises: any;

                static setMaxListeners: any;

                static usingDomains: any;

            }

            class Transform {
                constructor(options: any);

                static Duplex: any;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static PassThrough: any;

                static Readable: any;

                static ReadableState: any;

                static Stream: any;

                static Transform: any;

                static Writable: any;

                static addAbortSignal: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static compose: any;

                static defaultMaxListeners: any;

                static destroy: any;

                static errorMonitor: any;

                static finished: any;

                static from: any;

                static getEventListeners: any;

                static init: any;

                static isDisturbed: any;

                static isErrored: any;

                static isReadable: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static pipeline: any;

                static promises: any;

                static setMaxListeners: any;

                static usingDomains: any;

                static wrap: any;

            }

            class Writable {
                constructor(options: any);

                cork(): void;

                destroy(err: any, cb: any): any;

                end(chunk: any, encoding: any, cb: any): any;

                pipe(): void;

                setDefaultEncoding(encoding: any): any;

                uncork(): void;

                write(chunk: any, encoding: any, cb: any): any;

                static Duplex: any;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static PassThrough: any;

                static Readable: any;

                static Stream: any;

                static Transform: any;

                static Writable: any;

                static WritableState: any;

                static addAbortSignal: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static compose: any;

                static defaultMaxListeners: any;

                static destroy: any;

                static errorMonitor: any;

                static finished: any;

                static getEventListeners: any;

                static init: any;

                static isDisturbed: any;

                static isErrored: any;

                static isReadable: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static pipeline: any;

                static promises: any;

                static setMaxListeners: any;

                static usingDomains: any;

            }

            namespace promises {
                // Too-deep object hierarchy from fs.ReadStream.Duplex.PassThrough.promises
                const finished: any;

                // Too-deep object hierarchy from fs.ReadStream.Duplex.PassThrough.promises
                const pipeline: any;

            }

        }

        namespace Readable {
            class EventEmitter {
                constructor(opts: any);

                addListener(type: any, listener: any): any;

                emit(type: any, args: any): any;

                eventNames(): any;

                getMaxListeners(): any;

                listenerCount(type: any): any;

                listeners(type: any): any;

                off(type: any, listener: any): any;

                on(type: any, listener: any): any;

                once(type: any, listener: any): any;

                prependListener(type: any, listener: any): any;

                prependOnceListener(type: any, listener: any): any;

                rawListeners(type: any): any;

                removeAllListeners(type: any, ...args: any[]): any;

                removeListener(type: any, listener: any): any;

                setMaxListeners(n: any): any;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static defaultMaxListeners: any;

                static errorMonitor: any;

                static getEventListeners: any;

                static init: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static setMaxListeners: any;

                static usingDomains: any;

            }

            class EventEmitterAsyncResource {
                constructor(...args: any[]);

                emit(...args: any[]): void;

                emitDestroy(...args: any[]): void;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static defaultMaxListeners: any;

                static errorMonitor: any;

                static getEventListeners: any;

                static init: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static setMaxListeners: any;

                static usingDomains: any;

            }

            class PassThrough {
                constructor(options: any);

                static Duplex: any;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static PassThrough: any;

                static Readable: any;

                static ReadableState: any;

                static Stream: any;

                static Transform: any;

                static Writable: any;

                static addAbortSignal: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static compose: any;

                static defaultMaxListeners: any;

                static destroy: any;

                static errorMonitor: any;

                static finished: any;

                static from: any;

                static getEventListeners: any;

                static init: any;

                static isDisturbed: any;

                static isErrored: any;

                static isReadable: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static pipeline: any;

                static promises: any;

                static setMaxListeners: any;

                static usingDomains: any;

                static wrap: any;

            }

            class ReadableState {
                constructor(options: any, stream: any, isDuplex: any);

            }

            class Stream {
                constructor(opts: any);

                pipe(dest: any, options: any): any;

                static Duplex: any;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static PassThrough: any;

                static Readable: any;

                static Stream: any;

                static Transform: any;

                static Writable: any;

                static addAbortSignal: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static compose: any;

                static defaultMaxListeners: any;

                static destroy: any;

                static errorMonitor: any;

                static finished: any;

                static getEventListeners: any;

                static init: any;

                static isDisturbed: any;

                static isErrored: any;

                static isReadable: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static pipeline: any;

                static promises: any;

                static setMaxListeners: any;

                static usingDomains: any;

            }

            class Transform {
                constructor(options: any);

                static Duplex: any;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static PassThrough: any;

                static Readable: any;

                static ReadableState: any;

                static Stream: any;

                static Transform: any;

                static Writable: any;

                static addAbortSignal: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static compose: any;

                static defaultMaxListeners: any;

                static destroy: any;

                static errorMonitor: any;

                static finished: any;

                static from: any;

                static getEventListeners: any;

                static init: any;

                static isDisturbed: any;

                static isErrored: any;

                static isReadable: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static pipeline: any;

                static promises: any;

                static setMaxListeners: any;

                static usingDomains: any;

                static wrap: any;

            }

            class Writable {
                constructor(options: any);

                cork(): void;

                destroy(err: any, cb: any): any;

                end(chunk: any, encoding: any, cb: any): any;

                pipe(): void;

                setDefaultEncoding(encoding: any): any;

                uncork(): void;

                write(chunk: any, encoding: any, cb: any): any;

                static Duplex: any;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static PassThrough: any;

                static Readable: any;

                static Stream: any;

                static Transform: any;

                static Writable: any;

                static WritableState: any;

                static addAbortSignal: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static compose: any;

                static defaultMaxListeners: any;

                static destroy: any;

                static errorMonitor: any;

                static finished: any;

                static getEventListeners: any;

                static init: any;

                static isDisturbed: any;

                static isErrored: any;

                static isReadable: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static pipeline: any;

                static promises: any;

                static setMaxListeners: any;

                static usingDomains: any;

            }

            namespace promises {
                // Too-deep object hierarchy from fs.ReadStream.Duplex.Readable.promises
                const finished: any;

                // Too-deep object hierarchy from fs.ReadStream.Duplex.Readable.promises
                const pipeline: any;

            }

        }

        namespace Stream {
            class EventEmitter {
                constructor(opts: any);

                addListener(type: any, listener: any): any;

                emit(type: any, args: any): any;

                eventNames(): any;

                getMaxListeners(): any;

                listenerCount(type: any): any;

                listeners(type: any): any;

                off(type: any, listener: any): any;

                on(type: any, listener: any): any;

                once(type: any, listener: any): any;

                prependListener(type: any, listener: any): any;

                prependOnceListener(type: any, listener: any): any;

                rawListeners(type: any): any;

                removeAllListeners(type: any, ...args: any[]): any;

                removeListener(type: any, listener: any): any;

                setMaxListeners(n: any): any;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static defaultMaxListeners: any;

                static errorMonitor: any;

                static getEventListeners: any;

                static init: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static setMaxListeners: any;

                static usingDomains: any;

            }

            class EventEmitterAsyncResource {
                constructor(...args: any[]);

                emit(...args: any[]): void;

                emitDestroy(...args: any[]): void;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static defaultMaxListeners: any;

                static errorMonitor: any;

                static getEventListeners: any;

                static init: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static setMaxListeners: any;

                static usingDomains: any;

            }

            class PassThrough {
                constructor(options: any);

                static Duplex: any;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static PassThrough: any;

                static Readable: any;

                static ReadableState: any;

                static Stream: any;

                static Transform: any;

                static Writable: any;

                static addAbortSignal: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static compose: any;

                static defaultMaxListeners: any;

                static destroy: any;

                static errorMonitor: any;

                static finished: any;

                static from: any;

                static getEventListeners: any;

                static init: any;

                static isDisturbed: any;

                static isErrored: any;

                static isReadable: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static pipeline: any;

                static promises: any;

                static setMaxListeners: any;

                static usingDomains: any;

                static wrap: any;

            }

            class Readable {
                constructor(options: any);

                addListener(ev: any, fn: any): any;

                destroy(err: any, cb: any): any;

                filter(args: any): any;

                isPaused(): any;

                iterator(options: any): any;

                map(args: any): any;

                off(ev: any, fn: any): any;

                on(ev: any, fn: any): any;

                pause(): any;

                pipe(dest: any, pipeOpts: any): any;

                push(chunk: any, encoding: any): any;

                read(n: any): any;

                removeAllListeners(ev: any, ...args: any[]): any;

                removeListener(ev: any, fn: any): any;

                resume(): any;

                setEncoding(enc: any): any;

                unpipe(dest: any): any;

                unshift(chunk: any, encoding: any): any;

                wrap(stream: any): any;

                static Duplex: any;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static PassThrough: any;

                static Readable: any;

                static ReadableState: any;

                static Stream: any;

                static Transform: any;

                static Writable: any;

                static addAbortSignal: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static compose: any;

                static defaultMaxListeners: any;

                static destroy: any;

                static errorMonitor: any;

                static finished: any;

                static from: any;

                static getEventListeners: any;

                static init: any;

                static isDisturbed: any;

                static isErrored: any;

                static isReadable: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static pipeline: any;

                static promises: any;

                static setMaxListeners: any;

                static usingDomains: any;

                static wrap: any;

            }

            class Transform {
                constructor(options: any);

                static Duplex: any;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static PassThrough: any;

                static Readable: any;

                static ReadableState: any;

                static Stream: any;

                static Transform: any;

                static Writable: any;

                static addAbortSignal: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static compose: any;

                static defaultMaxListeners: any;

                static destroy: any;

                static errorMonitor: any;

                static finished: any;

                static from: any;

                static getEventListeners: any;

                static init: any;

                static isDisturbed: any;

                static isErrored: any;

                static isReadable: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static pipeline: any;

                static promises: any;

                static setMaxListeners: any;

                static usingDomains: any;

                static wrap: any;

            }

            class Writable {
                constructor(options: any);

                cork(): void;

                destroy(err: any, cb: any): any;

                end(chunk: any, encoding: any, cb: any): any;

                pipe(): void;

                setDefaultEncoding(encoding: any): any;

                uncork(): void;

                write(chunk: any, encoding: any, cb: any): any;

                static Duplex: any;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static PassThrough: any;

                static Readable: any;

                static Stream: any;

                static Transform: any;

                static Writable: any;

                static WritableState: any;

                static addAbortSignal: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static compose: any;

                static defaultMaxListeners: any;

                static destroy: any;

                static errorMonitor: any;

                static finished: any;

                static getEventListeners: any;

                static init: any;

                static isDisturbed: any;

                static isErrored: any;

                static isReadable: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static pipeline: any;

                static promises: any;

                static setMaxListeners: any;

                static usingDomains: any;

            }

            namespace promises {
                // Too-deep object hierarchy from fs.ReadStream.Duplex.Stream.promises
                const finished: any;

                // Too-deep object hierarchy from fs.ReadStream.Duplex.Stream.promises
                const pipeline: any;

            }

        }

        namespace Transform {
            class EventEmitter {
                constructor(opts: any);

                addListener(type: any, listener: any): any;

                emit(type: any, args: any): any;

                eventNames(): any;

                getMaxListeners(): any;

                listenerCount(type: any): any;

                listeners(type: any): any;

                off(type: any, listener: any): any;

                on(type: any, listener: any): any;

                once(type: any, listener: any): any;

                prependListener(type: any, listener: any): any;

                prependOnceListener(type: any, listener: any): any;

                rawListeners(type: any): any;

                removeAllListeners(type: any, ...args: any[]): any;

                removeListener(type: any, listener: any): any;

                setMaxListeners(n: any): any;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static defaultMaxListeners: any;

                static errorMonitor: any;

                static getEventListeners: any;

                static init: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static setMaxListeners: any;

                static usingDomains: any;

            }

            class EventEmitterAsyncResource {
                constructor(...args: any[]);

                emit(...args: any[]): void;

                emitDestroy(...args: any[]): void;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static defaultMaxListeners: any;

                static errorMonitor: any;

                static getEventListeners: any;

                static init: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static setMaxListeners: any;

                static usingDomains: any;

            }

            class PassThrough {
                constructor(options: any);

                static Duplex: any;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static PassThrough: any;

                static Readable: any;

                static ReadableState: any;

                static Stream: any;

                static Transform: any;

                static Writable: any;

                static addAbortSignal: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static compose: any;

                static defaultMaxListeners: any;

                static destroy: any;

                static errorMonitor: any;

                static finished: any;

                static from: any;

                static getEventListeners: any;

                static init: any;

                static isDisturbed: any;

                static isErrored: any;

                static isReadable: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static pipeline: any;

                static promises: any;

                static setMaxListeners: any;

                static usingDomains: any;

                static wrap: any;

            }

            class Readable {
                constructor(options: any);

                addListener(ev: any, fn: any): any;

                destroy(err: any, cb: any): any;

                filter(args: any): any;

                isPaused(): any;

                iterator(options: any): any;

                map(args: any): any;

                off(ev: any, fn: any): any;

                on(ev: any, fn: any): any;

                pause(): any;

                pipe(dest: any, pipeOpts: any): any;

                push(chunk: any, encoding: any): any;

                read(n: any): any;

                removeAllListeners(ev: any, ...args: any[]): any;

                removeListener(ev: any, fn: any): any;

                resume(): any;

                setEncoding(enc: any): any;

                unpipe(dest: any): any;

                unshift(chunk: any, encoding: any): any;

                wrap(stream: any): any;

                static Duplex: any;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static PassThrough: any;

                static Readable: any;

                static ReadableState: any;

                static Stream: any;

                static Transform: any;

                static Writable: any;

                static addAbortSignal: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static compose: any;

                static defaultMaxListeners: any;

                static destroy: any;

                static errorMonitor: any;

                static finished: any;

                static from: any;

                static getEventListeners: any;

                static init: any;

                static isDisturbed: any;

                static isErrored: any;

                static isReadable: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static pipeline: any;

                static promises: any;

                static setMaxListeners: any;

                static usingDomains: any;

                static wrap: any;

            }

            class ReadableState {
                constructor(options: any, stream: any, isDuplex: any);

            }

            class Stream {
                constructor(opts: any);

                pipe(dest: any, options: any): any;

                static Duplex: any;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static PassThrough: any;

                static Readable: any;

                static Stream: any;

                static Transform: any;

                static Writable: any;

                static addAbortSignal: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static compose: any;

                static defaultMaxListeners: any;

                static destroy: any;

                static errorMonitor: any;

                static finished: any;

                static getEventListeners: any;

                static init: any;

                static isDisturbed: any;

                static isErrored: any;

                static isReadable: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static pipeline: any;

                static promises: any;

                static setMaxListeners: any;

                static usingDomains: any;

            }

            class Writable {
                constructor(options: any);

                cork(): void;

                destroy(err: any, cb: any): any;

                end(chunk: any, encoding: any, cb: any): any;

                pipe(): void;

                setDefaultEncoding(encoding: any): any;

                uncork(): void;

                write(chunk: any, encoding: any, cb: any): any;

                static Duplex: any;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static PassThrough: any;

                static Readable: any;

                static Stream: any;

                static Transform: any;

                static Writable: any;

                static WritableState: any;

                static addAbortSignal: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static compose: any;

                static defaultMaxListeners: any;

                static destroy: any;

                static errorMonitor: any;

                static finished: any;

                static getEventListeners: any;

                static init: any;

                static isDisturbed: any;

                static isErrored: any;

                static isReadable: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static pipeline: any;

                static promises: any;

                static setMaxListeners: any;

                static usingDomains: any;

            }

            namespace promises {
                // Too-deep object hierarchy from fs.ReadStream.Duplex.Transform.promises
                const finished: any;

                // Too-deep object hierarchy from fs.ReadStream.Duplex.Transform.promises
                const pipeline: any;

            }

        }

        namespace Writable {
            class EventEmitter {
                constructor(opts: any);

                addListener(type: any, listener: any): any;

                emit(type: any, args: any): any;

                eventNames(): any;

                getMaxListeners(): any;

                listenerCount(type: any): any;

                listeners(type: any): any;

                off(type: any, listener: any): any;

                on(type: any, listener: any): any;

                once(type: any, listener: any): any;

                prependListener(type: any, listener: any): any;

                prependOnceListener(type: any, listener: any): any;

                rawListeners(type: any): any;

                removeAllListeners(type: any, ...args: any[]): any;

                removeListener(type: any, listener: any): any;

                setMaxListeners(n: any): any;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static defaultMaxListeners: any;

                static errorMonitor: any;

                static getEventListeners: any;

                static init: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static setMaxListeners: any;

                static usingDomains: any;

            }

            class EventEmitterAsyncResource {
                constructor(...args: any[]);

                emit(...args: any[]): void;

                emitDestroy(...args: any[]): void;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static defaultMaxListeners: any;

                static errorMonitor: any;

                static getEventListeners: any;

                static init: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static setMaxListeners: any;

                static usingDomains: any;

            }

            class PassThrough {
                constructor(options: any);

                static Duplex: any;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static PassThrough: any;

                static Readable: any;

                static ReadableState: any;

                static Stream: any;

                static Transform: any;

                static Writable: any;

                static addAbortSignal: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static compose: any;

                static defaultMaxListeners: any;

                static destroy: any;

                static errorMonitor: any;

                static finished: any;

                static from: any;

                static getEventListeners: any;

                static init: any;

                static isDisturbed: any;

                static isErrored: any;

                static isReadable: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static pipeline: any;

                static promises: any;

                static setMaxListeners: any;

                static usingDomains: any;

                static wrap: any;

            }

            class Readable {
                constructor(options: any);

                addListener(ev: any, fn: any): any;

                destroy(err: any, cb: any): any;

                filter(args: any): any;

                isPaused(): any;

                iterator(options: any): any;

                map(args: any): any;

                off(ev: any, fn: any): any;

                on(ev: any, fn: any): any;

                pause(): any;

                pipe(dest: any, pipeOpts: any): any;

                push(chunk: any, encoding: any): any;

                read(n: any): any;

                removeAllListeners(ev: any, ...args: any[]): any;

                removeListener(ev: any, fn: any): any;

                resume(): any;

                setEncoding(enc: any): any;

                unpipe(dest: any): any;

                unshift(chunk: any, encoding: any): any;

                wrap(stream: any): any;

                static Duplex: any;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static PassThrough: any;

                static Readable: any;

                static ReadableState: any;

                static Stream: any;

                static Transform: any;

                static Writable: any;

                static addAbortSignal: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static compose: any;

                static defaultMaxListeners: any;

                static destroy: any;

                static errorMonitor: any;

                static finished: any;

                static from: any;

                static getEventListeners: any;

                static init: any;

                static isDisturbed: any;

                static isErrored: any;

                static isReadable: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static pipeline: any;

                static promises: any;

                static setMaxListeners: any;

                static usingDomains: any;

                static wrap: any;

            }

            class Stream {
                constructor(opts: any);

                pipe(dest: any, options: any): any;

                static Duplex: any;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static PassThrough: any;

                static Readable: any;

                static Stream: any;

                static Transform: any;

                static Writable: any;

                static addAbortSignal: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static compose: any;

                static defaultMaxListeners: any;

                static destroy: any;

                static errorMonitor: any;

                static finished: any;

                static getEventListeners: any;

                static init: any;

                static isDisturbed: any;

                static isErrored: any;

                static isReadable: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static pipeline: any;

                static promises: any;

                static setMaxListeners: any;

                static usingDomains: any;

            }

            class Transform {
                constructor(options: any);

                static Duplex: any;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static PassThrough: any;

                static Readable: any;

                static ReadableState: any;

                static Stream: any;

                static Transform: any;

                static Writable: any;

                static addAbortSignal: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static compose: any;

                static defaultMaxListeners: any;

                static destroy: any;

                static errorMonitor: any;

                static finished: any;

                static from: any;

                static getEventListeners: any;

                static init: any;

                static isDisturbed: any;

                static isErrored: any;

                static isReadable: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static pipeline: any;

                static promises: any;

                static setMaxListeners: any;

                static usingDomains: any;

                static wrap: any;

            }

            class WritableState {
                constructor(options: any, stream: any, isDuplex: any);

                getBuffer(): any;

            }

            namespace promises {
                // Too-deep object hierarchy from fs.ReadStream.Duplex.Writable.promises
                const finished: any;

                // Too-deep object hierarchy from fs.ReadStream.Duplex.Writable.promises
                const pipeline: any;

            }

        }

        namespace promises {
            function finished(stream: any, opts: any): any;

            function pipeline(streams: any): any;

        }

    }

    namespace EventEmitter {
        class EventEmitterAsyncResource {
            constructor(...args: any[]);

            emit(...args: any[]): void;

            emitDestroy(...args: any[]): void;

            static EventEmitter: any;

            static EventEmitterAsyncResource: any;

            static captureRejectionSymbol: any;

            static captureRejections: boolean;

            static defaultMaxListeners: number;

            static errorMonitor: any;

            static getEventListeners(emitterOrTarget: any, type: any): any;

            static init(opts: any): void;

            static kMaxEventTargetListeners: any;

            static kMaxEventTargetListenersWarned: any;

            static listenerCount(emitter: any, type: any): any;

            static on(emitter: any, event: any, options: any): any;

            static once(emitter: any, name: any, options: any): any;

            static setMaxListeners(n: any, eventTargets: any): void;

            static usingDomains: boolean;

        }

    }

    namespace EventEmitterAsyncResource {
        class EventEmitter {
            constructor(opts: any);

            addListener(type: any, listener: any): any;

            emit(type: any, args: any): any;

            eventNames(): any;

            getMaxListeners(): any;

            listenerCount(type: any): any;

            listeners(type: any): any;

            off(type: any, listener: any): any;

            on(type: any, listener: any): any;

            once(type: any, listener: any): any;

            prependListener(type: any, listener: any): any;

            prependOnceListener(type: any, listener: any): any;

            rawListeners(type: any): any;

            removeAllListeners(type: any, ...args: any[]): any;

            removeListener(type: any, listener: any): any;

            setMaxListeners(n: any): any;

            static EventEmitter: any;

            static EventEmitterAsyncResource: any;

            static captureRejectionSymbol: any;

            static captureRejections: boolean;

            static defaultMaxListeners: number;

            static errorMonitor: any;

            static getEventListeners(emitterOrTarget: any, type: any): any;

            static init(opts: any): void;

            static kMaxEventTargetListeners: any;

            static kMaxEventTargetListenersWarned: any;

            static listenerCount(emitter: any, type: any): any;

            static on(emitter: any, event: any, options: any): any;

            static once(emitter: any, name: any, options: any): any;

            static setMaxListeners(n: any, eventTargets: any): void;

            static usingDomains: boolean;

        }

    }

    namespace PassThrough {
        class Duplex {
            constructor(options: any);

            cork(): void;

            end(chunk: any, encoding: any, cb: any): any;

            setDefaultEncoding(encoding: any): any;

            uncork(): void;

            write(chunk: any, encoding: any, cb: any): any;

            static Duplex: any;

            static PassThrough: any;

            static addAbortSignal(signal: any, stream: any): any;

            static captureRejectionSymbol: any;

            static captureRejections: boolean;

            static compose(streams: any): any;

            static defaultMaxListeners: number;

            static destroy(stream: any, err: any): any;

            static errorMonitor: any;

            static finished(stream: any, options: any, callback: any, ...args: any[]): any;

            static from(body: any): any;

            static getEventListeners(emitterOrTarget: any, type: any): any;

            static init(opts: any): void;

            static isDisturbed(stream: any): any;

            static isErrored(stream: any): any;

            static isReadable(stream: any): any;

            static kMaxEventTargetListeners: any;

            static kMaxEventTargetListenersWarned: any;

            static listenerCount(emitter: any, type: any): any;

            static on(emitter: any, event: any, options: any): any;

            static once(emitter: any, name: any, options: any): any;

            static pipeline(streams: any): any;

            static setMaxListeners(n: any, eventTargets: any): void;

            static usingDomains: boolean;

            static wrap(src: any, options: any): any;

        }

        class EventEmitter {
            constructor(opts: any);

            addListener(type: any, listener: any): any;

            emit(type: any, args: any): any;

            eventNames(): any;

            getMaxListeners(): any;

            listenerCount(type: any): any;

            listeners(type: any): any;

            off(type: any, listener: any): any;

            on(type: any, listener: any): any;

            once(type: any, listener: any): any;

            prependListener(type: any, listener: any): any;

            prependOnceListener(type: any, listener: any): any;

            rawListeners(type: any): any;

            removeAllListeners(type: any, ...args: any[]): any;

            removeListener(type: any, listener: any): any;

            setMaxListeners(n: any): any;

            static EventEmitter: any;

            static captureRejectionSymbol: any;

            static captureRejections: boolean;

            static defaultMaxListeners: number;

            static errorMonitor: any;

            static getEventListeners(emitterOrTarget: any, type: any): any;

            static init(opts: any): void;

            static kMaxEventTargetListeners: any;

            static kMaxEventTargetListenersWarned: any;

            static listenerCount(emitter: any, type: any): any;

            static on(emitter: any, event: any, options: any): any;

            static once(emitter: any, name: any, options: any): any;

            static setMaxListeners(n: any, eventTargets: any): void;

            static usingDomains: boolean;

        }

        class EventEmitterAsyncResource {
            constructor(...args: any[]);

            emit(...args: any[]): void;

            emitDestroy(...args: any[]): void;

            static EventEmitterAsyncResource: any;

            static captureRejectionSymbol: any;

            static captureRejections: boolean;

            static defaultMaxListeners: number;

            static errorMonitor: any;

            static getEventListeners(emitterOrTarget: any, type: any): any;

            static init(opts: any): void;

            static kMaxEventTargetListeners: any;

            static kMaxEventTargetListenersWarned: any;

            static listenerCount(emitter: any, type: any): any;

            static on(emitter: any, event: any, options: any): any;

            static once(emitter: any, name: any, options: any): any;

            static setMaxListeners(n: any, eventTargets: any): void;

            static usingDomains: boolean;

        }

        class Readable {
            constructor(options: any);

            addListener(ev: any, fn: any): any;

            destroy(err: any, cb: any): any;

            filter(args: any): any;

            isPaused(): any;

            iterator(options: any): any;

            map(args: any): any;

            off(ev: any, fn: any): any;

            on(ev: any, fn: any): any;

            pause(): any;

            pipe(dest: any, pipeOpts: any): any;

            push(chunk: any, encoding: any): any;

            read(n: any): any;

            removeAllListeners(ev: any, ...args: any[]): any;

            removeListener(ev: any, fn: any): any;

            resume(): any;

            setEncoding(enc: any): any;

            unpipe(dest: any): any;

            unshift(chunk: any, encoding: any): any;

            wrap(stream: any): any;

            static PassThrough: any;

            static Readable: any;

            static addAbortSignal(signal: any, stream: any): any;

            static captureRejectionSymbol: any;

            static captureRejections: boolean;

            static compose(streams: any): any;

            static defaultMaxListeners: number;

            static destroy(stream: any, err: any): any;

            static errorMonitor: any;

            static finished(stream: any, options: any, callback: any, ...args: any[]): any;

            static from(iterable: any, opts: any): any;

            static getEventListeners(emitterOrTarget: any, type: any): any;

            static init(opts: any): void;

            static isDisturbed(stream: any): any;

            static isErrored(stream: any): any;

            static isReadable(stream: any): any;

            static kMaxEventTargetListeners: any;

            static kMaxEventTargetListenersWarned: any;

            static listenerCount(emitter: any, type: any): any;

            static on(emitter: any, event: any, options: any): any;

            static once(emitter: any, name: any, options: any): any;

            static pipeline(streams: any): any;

            static setMaxListeners(n: any, eventTargets: any): void;

            static usingDomains: boolean;

            static wrap(src: any, options: any): any;

        }

        class ReadableState {
            constructor(options: any, stream: any, isDuplex: any);

        }

        class Stream {
            constructor(opts: any);

            pipe(dest: any, options: any): any;

            static PassThrough: any;

            static Stream: any;

            static addAbortSignal(signal: any, stream: any): any;

            static captureRejectionSymbol: any;

            static captureRejections: boolean;

            static compose(streams: any): any;

            static defaultMaxListeners: number;

            static destroy(stream: any, err: any): any;

            static errorMonitor: any;

            static finished(stream: any, options: any, callback: any, ...args: any[]): any;

            static getEventListeners(emitterOrTarget: any, type: any): any;

            static init(opts: any): void;

            static isDisturbed(stream: any): any;

            static isErrored(stream: any): any;

            static isReadable(stream: any): any;

            static kMaxEventTargetListeners: any;

            static kMaxEventTargetListenersWarned: any;

            static listenerCount(emitter: any, type: any): any;

            static on(emitter: any, event: any, options: any): any;

            static once(emitter: any, name: any, options: any): any;

            static pipeline(streams: any): any;

            static setMaxListeners(n: any, eventTargets: any): void;

            static usingDomains: boolean;

        }

        class Transform {
            constructor(options: any);

            static PassThrough: any;

            static Transform: any;

            static addAbortSignal(signal: any, stream: any): any;

            static captureRejectionSymbol: any;

            static captureRejections: boolean;

            static compose(streams: any): any;

            static defaultMaxListeners: number;

            static destroy(stream: any, err: any): any;

            static errorMonitor: any;

            static finished(stream: any, options: any, callback: any, ...args: any[]): any;

            static from(body: any): any;

            static getEventListeners(emitterOrTarget: any, type: any): any;

            static init(opts: any): void;

            static isDisturbed(stream: any): any;

            static isErrored(stream: any): any;

            static isReadable(stream: any): any;

            static kMaxEventTargetListeners: any;

            static kMaxEventTargetListenersWarned: any;

            static listenerCount(emitter: any, type: any): any;

            static on(emitter: any, event: any, options: any): any;

            static once(emitter: any, name: any, options: any): any;

            static pipeline(streams: any): any;

            static setMaxListeners(n: any, eventTargets: any): void;

            static usingDomains: boolean;

            static wrap(src: any, options: any): any;

        }

        class Writable {
            constructor(options: any);

            cork(): void;

            destroy(err: any, cb: any): any;

            end(chunk: any, encoding: any, cb: any): any;

            pipe(): void;

            setDefaultEncoding(encoding: any): any;

            uncork(): void;

            write(chunk: any, encoding: any, cb: any): any;

            static PassThrough: any;

            static Writable: any;

            static addAbortSignal(signal: any, stream: any): any;

            static captureRejectionSymbol: any;

            static captureRejections: boolean;

            static compose(streams: any): any;

            static defaultMaxListeners: number;

            static destroy(stream: any, err: any): any;

            static errorMonitor: any;

            static finished(stream: any, options: any, callback: any, ...args: any[]): any;

            static getEventListeners(emitterOrTarget: any, type: any): any;

            static init(opts: any): void;

            static isDisturbed(stream: any): any;

            static isErrored(stream: any): any;

            static isReadable(stream: any): any;

            static kMaxEventTargetListeners: any;

            static kMaxEventTargetListenersWarned: any;

            static listenerCount(emitter: any, type: any): any;

            static on(emitter: any, event: any, options: any): any;

            static once(emitter: any, name: any, options: any): any;

            static pipeline(streams: any): any;

            static setMaxListeners(n: any, eventTargets: any): void;

            static usingDomains: boolean;

        }

        namespace Duplex {
            class EventEmitter {
                constructor(opts: any);

                addListener(type: any, listener: any): any;

                emit(type: any, args: any): any;

                eventNames(): any;

                getMaxListeners(): any;

                listenerCount(type: any): any;

                listeners(type: any): any;

                off(type: any, listener: any): any;

                on(type: any, listener: any): any;

                once(type: any, listener: any): any;

                prependListener(type: any, listener: any): any;

                prependOnceListener(type: any, listener: any): any;

                rawListeners(type: any): any;

                removeAllListeners(type: any, ...args: any[]): any;

                removeListener(type: any, listener: any): any;

                setMaxListeners(n: any): any;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static defaultMaxListeners: any;

                static errorMonitor: any;

                static getEventListeners: any;

                static init: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static setMaxListeners: any;

                static usingDomains: any;

            }

            class EventEmitterAsyncResource {
                constructor(...args: any[]);

                emit(...args: any[]): void;

                emitDestroy(...args: any[]): void;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static defaultMaxListeners: any;

                static errorMonitor: any;

                static getEventListeners: any;

                static init: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static setMaxListeners: any;

                static usingDomains: any;

            }

            class Readable {
                constructor(options: any);

                addListener(ev: any, fn: any): any;

                destroy(err: any, cb: any): any;

                filter(args: any): any;

                isPaused(): any;

                iterator(options: any): any;

                map(args: any): any;

                off(ev: any, fn: any): any;

                on(ev: any, fn: any): any;

                pause(): any;

                pipe(dest: any, pipeOpts: any): any;

                push(chunk: any, encoding: any): any;

                read(n: any): any;

                removeAllListeners(ev: any, ...args: any[]): any;

                removeListener(ev: any, fn: any): any;

                resume(): any;

                setEncoding(enc: any): any;

                unpipe(dest: any): any;

                unshift(chunk: any, encoding: any): any;

                wrap(stream: any): any;

                static Duplex: any;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static PassThrough: any;

                static Readable: any;

                static ReadableState: any;

                static Stream: any;

                static Transform: any;

                static Writable: any;

                static addAbortSignal: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static compose: any;

                static defaultMaxListeners: any;

                static destroy: any;

                static errorMonitor: any;

                static finished: any;

                static from: any;

                static getEventListeners: any;

                static init: any;

                static isDisturbed: any;

                static isErrored: any;

                static isReadable: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static pipeline: any;

                static promises: any;

                static setMaxListeners: any;

                static usingDomains: any;

                static wrap: any;

            }

            class ReadableState {
                constructor(options: any, stream: any, isDuplex: any);

            }

            class Stream {
                constructor(opts: any);

                pipe(dest: any, options: any): any;

                static Duplex: any;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static PassThrough: any;

                static Readable: any;

                static Stream: any;

                static Transform: any;

                static Writable: any;

                static addAbortSignal: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static compose: any;

                static defaultMaxListeners: any;

                static destroy: any;

                static errorMonitor: any;

                static finished: any;

                static getEventListeners: any;

                static init: any;

                static isDisturbed: any;

                static isErrored: any;

                static isReadable: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static pipeline: any;

                static promises: any;

                static setMaxListeners: any;

                static usingDomains: any;

            }

            class Transform {
                constructor(options: any);

                static Duplex: any;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static PassThrough: any;

                static Readable: any;

                static ReadableState: any;

                static Stream: any;

                static Transform: any;

                static Writable: any;

                static addAbortSignal: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static compose: any;

                static defaultMaxListeners: any;

                static destroy: any;

                static errorMonitor: any;

                static finished: any;

                static from: any;

                static getEventListeners: any;

                static init: any;

                static isDisturbed: any;

                static isErrored: any;

                static isReadable: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static pipeline: any;

                static promises: any;

                static setMaxListeners: any;

                static usingDomains: any;

                static wrap: any;

            }

            class Writable {
                constructor(options: any);

                cork(): void;

                destroy(err: any, cb: any): any;

                end(chunk: any, encoding: any, cb: any): any;

                pipe(): void;

                setDefaultEncoding(encoding: any): any;

                uncork(): void;

                write(chunk: any, encoding: any, cb: any): any;

                static Duplex: any;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static PassThrough: any;

                static Readable: any;

                static Stream: any;

                static Transform: any;

                static Writable: any;

                static WritableState: any;

                static addAbortSignal: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static compose: any;

                static defaultMaxListeners: any;

                static destroy: any;

                static errorMonitor: any;

                static finished: any;

                static getEventListeners: any;

                static init: any;

                static isDisturbed: any;

                static isErrored: any;

                static isReadable: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static pipeline: any;

                static promises: any;

                static setMaxListeners: any;

                static usingDomains: any;

            }

            namespace promises {
                // Too-deep object hierarchy from fs.ReadStream.PassThrough.Duplex.promises
                const finished: any;

                // Too-deep object hierarchy from fs.ReadStream.PassThrough.Duplex.promises
                const pipeline: any;

            }

        }

        namespace EventEmitter {
            class EventEmitterAsyncResource {
                constructor(...args: any[]);

                emit(...args: any[]): void;

                emitDestroy(...args: any[]): void;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static defaultMaxListeners: any;

                static errorMonitor: any;

                static getEventListeners: any;

                static init: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static setMaxListeners: any;

                static usingDomains: any;

            }

        }

        namespace EventEmitterAsyncResource {
            class EventEmitter {
                constructor(opts: any);

                addListener(type: any, listener: any): any;

                emit(type: any, args: any): any;

                eventNames(): any;

                getMaxListeners(): any;

                listenerCount(type: any): any;

                listeners(type: any): any;

                off(type: any, listener: any): any;

                on(type: any, listener: any): any;

                once(type: any, listener: any): any;

                prependListener(type: any, listener: any): any;

                prependOnceListener(type: any, listener: any): any;

                rawListeners(type: any): any;

                removeAllListeners(type: any, ...args: any[]): any;

                removeListener(type: any, listener: any): any;

                setMaxListeners(n: any): any;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static defaultMaxListeners: any;

                static errorMonitor: any;

                static getEventListeners: any;

                static init: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static setMaxListeners: any;

                static usingDomains: any;

            }

        }

        namespace Readable {
            class Duplex {
                constructor(options: any);

                cork(): void;

                end(chunk: any, encoding: any, cb: any): any;

                setDefaultEncoding(encoding: any): any;

                uncork(): void;

                write(chunk: any, encoding: any, cb: any): any;

                static Duplex: any;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static PassThrough: any;

                static Readable: any;

                static ReadableState: any;

                static Stream: any;

                static Transform: any;

                static Writable: any;

                static addAbortSignal: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static compose: any;

                static defaultMaxListeners: any;

                static destroy: any;

                static errorMonitor: any;

                static finished: any;

                static from: any;

                static getEventListeners: any;

                static init: any;

                static isDisturbed: any;

                static isErrored: any;

                static isReadable: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static pipeline: any;

                static promises: any;

                static setMaxListeners: any;

                static usingDomains: any;

                static wrap: any;

            }

            class EventEmitter {
                constructor(opts: any);

                addListener(type: any, listener: any): any;

                emit(type: any, args: any): any;

                eventNames(): any;

                getMaxListeners(): any;

                listenerCount(type: any): any;

                listeners(type: any): any;

                off(type: any, listener: any): any;

                on(type: any, listener: any): any;

                once(type: any, listener: any): any;

                prependListener(type: any, listener: any): any;

                prependOnceListener(type: any, listener: any): any;

                rawListeners(type: any): any;

                removeAllListeners(type: any, ...args: any[]): any;

                removeListener(type: any, listener: any): any;

                setMaxListeners(n: any): any;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static defaultMaxListeners: any;

                static errorMonitor: any;

                static getEventListeners: any;

                static init: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static setMaxListeners: any;

                static usingDomains: any;

            }

            class EventEmitterAsyncResource {
                constructor(...args: any[]);

                emit(...args: any[]): void;

                emitDestroy(...args: any[]): void;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static defaultMaxListeners: any;

                static errorMonitor: any;

                static getEventListeners: any;

                static init: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static setMaxListeners: any;

                static usingDomains: any;

            }

            class ReadableState {
                constructor(options: any, stream: any, isDuplex: any);

            }

            class Stream {
                constructor(opts: any);

                pipe(dest: any, options: any): any;

                static Duplex: any;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static PassThrough: any;

                static Readable: any;

                static Stream: any;

                static Transform: any;

                static Writable: any;

                static addAbortSignal: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static compose: any;

                static defaultMaxListeners: any;

                static destroy: any;

                static errorMonitor: any;

                static finished: any;

                static getEventListeners: any;

                static init: any;

                static isDisturbed: any;

                static isErrored: any;

                static isReadable: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static pipeline: any;

                static promises: any;

                static setMaxListeners: any;

                static usingDomains: any;

            }

            class Transform {
                constructor(options: any);

                static Duplex: any;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static PassThrough: any;

                static Readable: any;

                static ReadableState: any;

                static Stream: any;

                static Transform: any;

                static Writable: any;

                static addAbortSignal: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static compose: any;

                static defaultMaxListeners: any;

                static destroy: any;

                static errorMonitor: any;

                static finished: any;

                static from: any;

                static getEventListeners: any;

                static init: any;

                static isDisturbed: any;

                static isErrored: any;

                static isReadable: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static pipeline: any;

                static promises: any;

                static setMaxListeners: any;

                static usingDomains: any;

                static wrap: any;

            }

            class Writable {
                constructor(options: any);

                cork(): void;

                destroy(err: any, cb: any): any;

                end(chunk: any, encoding: any, cb: any): any;

                pipe(): void;

                setDefaultEncoding(encoding: any): any;

                uncork(): void;

                write(chunk: any, encoding: any, cb: any): any;

                static Duplex: any;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static PassThrough: any;

                static Readable: any;

                static Stream: any;

                static Transform: any;

                static Writable: any;

                static WritableState: any;

                static addAbortSignal: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static compose: any;

                static defaultMaxListeners: any;

                static destroy: any;

                static errorMonitor: any;

                static finished: any;

                static getEventListeners: any;

                static init: any;

                static isDisturbed: any;

                static isErrored: any;

                static isReadable: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static pipeline: any;

                static promises: any;

                static setMaxListeners: any;

                static usingDomains: any;

            }

            namespace promises {
                // Too-deep object hierarchy from fs.ReadStream.PassThrough.Readable.promises
                const finished: any;

                // Too-deep object hierarchy from fs.ReadStream.PassThrough.Readable.promises
                const pipeline: any;

            }

        }

        namespace Stream {
            class Duplex {
                constructor(options: any);

                cork(): void;

                end(chunk: any, encoding: any, cb: any): any;

                setDefaultEncoding(encoding: any): any;

                uncork(): void;

                write(chunk: any, encoding: any, cb: any): any;

                static Duplex: any;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static PassThrough: any;

                static Readable: any;

                static ReadableState: any;

                static Stream: any;

                static Transform: any;

                static Writable: any;

                static addAbortSignal: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static compose: any;

                static defaultMaxListeners: any;

                static destroy: any;

                static errorMonitor: any;

                static finished: any;

                static from: any;

                static getEventListeners: any;

                static init: any;

                static isDisturbed: any;

                static isErrored: any;

                static isReadable: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static pipeline: any;

                static promises: any;

                static setMaxListeners: any;

                static usingDomains: any;

                static wrap: any;

            }

            class EventEmitter {
                constructor(opts: any);

                addListener(type: any, listener: any): any;

                emit(type: any, args: any): any;

                eventNames(): any;

                getMaxListeners(): any;

                listenerCount(type: any): any;

                listeners(type: any): any;

                off(type: any, listener: any): any;

                on(type: any, listener: any): any;

                once(type: any, listener: any): any;

                prependListener(type: any, listener: any): any;

                prependOnceListener(type: any, listener: any): any;

                rawListeners(type: any): any;

                removeAllListeners(type: any, ...args: any[]): any;

                removeListener(type: any, listener: any): any;

                setMaxListeners(n: any): any;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static defaultMaxListeners: any;

                static errorMonitor: any;

                static getEventListeners: any;

                static init: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static setMaxListeners: any;

                static usingDomains: any;

            }

            class EventEmitterAsyncResource {
                constructor(...args: any[]);

                emit(...args: any[]): void;

                emitDestroy(...args: any[]): void;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static defaultMaxListeners: any;

                static errorMonitor: any;

                static getEventListeners: any;

                static init: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static setMaxListeners: any;

                static usingDomains: any;

            }

            class Readable {
                constructor(options: any);

                addListener(ev: any, fn: any): any;

                destroy(err: any, cb: any): any;

                filter(args: any): any;

                isPaused(): any;

                iterator(options: any): any;

                map(args: any): any;

                off(ev: any, fn: any): any;

                on(ev: any, fn: any): any;

                pause(): any;

                pipe(dest: any, pipeOpts: any): any;

                push(chunk: any, encoding: any): any;

                read(n: any): any;

                removeAllListeners(ev: any, ...args: any[]): any;

                removeListener(ev: any, fn: any): any;

                resume(): any;

                setEncoding(enc: any): any;

                unpipe(dest: any): any;

                unshift(chunk: any, encoding: any): any;

                wrap(stream: any): any;

                static Duplex: any;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static PassThrough: any;

                static Readable: any;

                static ReadableState: any;

                static Stream: any;

                static Transform: any;

                static Writable: any;

                static addAbortSignal: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static compose: any;

                static defaultMaxListeners: any;

                static destroy: any;

                static errorMonitor: any;

                static finished: any;

                static from: any;

                static getEventListeners: any;

                static init: any;

                static isDisturbed: any;

                static isErrored: any;

                static isReadable: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static pipeline: any;

                static promises: any;

                static setMaxListeners: any;

                static usingDomains: any;

                static wrap: any;

            }

            class Transform {
                constructor(options: any);

                static Duplex: any;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static PassThrough: any;

                static Readable: any;

                static ReadableState: any;

                static Stream: any;

                static Transform: any;

                static Writable: any;

                static addAbortSignal: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static compose: any;

                static defaultMaxListeners: any;

                static destroy: any;

                static errorMonitor: any;

                static finished: any;

                static from: any;

                static getEventListeners: any;

                static init: any;

                static isDisturbed: any;

                static isErrored: any;

                static isReadable: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static pipeline: any;

                static promises: any;

                static setMaxListeners: any;

                static usingDomains: any;

                static wrap: any;

            }

            class Writable {
                constructor(options: any);

                cork(): void;

                destroy(err: any, cb: any): any;

                end(chunk: any, encoding: any, cb: any): any;

                pipe(): void;

                setDefaultEncoding(encoding: any): any;

                uncork(): void;

                write(chunk: any, encoding: any, cb: any): any;

                static Duplex: any;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static PassThrough: any;

                static Readable: any;

                static Stream: any;

                static Transform: any;

                static Writable: any;

                static WritableState: any;

                static addAbortSignal: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static compose: any;

                static defaultMaxListeners: any;

                static destroy: any;

                static errorMonitor: any;

                static finished: any;

                static getEventListeners: any;

                static init: any;

                static isDisturbed: any;

                static isErrored: any;

                static isReadable: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static pipeline: any;

                static promises: any;

                static setMaxListeners: any;

                static usingDomains: any;

            }

            namespace promises {
                // Too-deep object hierarchy from fs.ReadStream.PassThrough.Stream.promises
                const finished: any;

                // Too-deep object hierarchy from fs.ReadStream.PassThrough.Stream.promises
                const pipeline: any;

            }

        }

        namespace Transform {
            class Duplex {
                constructor(options: any);

                cork(): void;

                end(chunk: any, encoding: any, cb: any): any;

                setDefaultEncoding(encoding: any): any;

                uncork(): void;

                write(chunk: any, encoding: any, cb: any): any;

                static Duplex: any;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static PassThrough: any;

                static Readable: any;

                static ReadableState: any;

                static Stream: any;

                static Transform: any;

                static Writable: any;

                static addAbortSignal: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static compose: any;

                static defaultMaxListeners: any;

                static destroy: any;

                static errorMonitor: any;

                static finished: any;

                static from: any;

                static getEventListeners: any;

                static init: any;

                static isDisturbed: any;

                static isErrored: any;

                static isReadable: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static pipeline: any;

                static promises: any;

                static setMaxListeners: any;

                static usingDomains: any;

                static wrap: any;

            }

            class EventEmitter {
                constructor(opts: any);

                addListener(type: any, listener: any): any;

                emit(type: any, args: any): any;

                eventNames(): any;

                getMaxListeners(): any;

                listenerCount(type: any): any;

                listeners(type: any): any;

                off(type: any, listener: any): any;

                on(type: any, listener: any): any;

                once(type: any, listener: any): any;

                prependListener(type: any, listener: any): any;

                prependOnceListener(type: any, listener: any): any;

                rawListeners(type: any): any;

                removeAllListeners(type: any, ...args: any[]): any;

                removeListener(type: any, listener: any): any;

                setMaxListeners(n: any): any;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static defaultMaxListeners: any;

                static errorMonitor: any;

                static getEventListeners: any;

                static init: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static setMaxListeners: any;

                static usingDomains: any;

            }

            class EventEmitterAsyncResource {
                constructor(...args: any[]);

                emit(...args: any[]): void;

                emitDestroy(...args: any[]): void;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static defaultMaxListeners: any;

                static errorMonitor: any;

                static getEventListeners: any;

                static init: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static setMaxListeners: any;

                static usingDomains: any;

            }

            class Readable {
                constructor(options: any);

                addListener(ev: any, fn: any): any;

                destroy(err: any, cb: any): any;

                filter(args: any): any;

                isPaused(): any;

                iterator(options: any): any;

                map(args: any): any;

                off(ev: any, fn: any): any;

                on(ev: any, fn: any): any;

                pause(): any;

                pipe(dest: any, pipeOpts: any): any;

                push(chunk: any, encoding: any): any;

                read(n: any): any;

                removeAllListeners(ev: any, ...args: any[]): any;

                removeListener(ev: any, fn: any): any;

                resume(): any;

                setEncoding(enc: any): any;

                unpipe(dest: any): any;

                unshift(chunk: any, encoding: any): any;

                wrap(stream: any): any;

                static Duplex: any;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static PassThrough: any;

                static Readable: any;

                static ReadableState: any;

                static Stream: any;

                static Transform: any;

                static Writable: any;

                static addAbortSignal: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static compose: any;

                static defaultMaxListeners: any;

                static destroy: any;

                static errorMonitor: any;

                static finished: any;

                static from: any;

                static getEventListeners: any;

                static init: any;

                static isDisturbed: any;

                static isErrored: any;

                static isReadable: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static pipeline: any;

                static promises: any;

                static setMaxListeners: any;

                static usingDomains: any;

                static wrap: any;

            }

            class ReadableState {
                constructor(options: any, stream: any, isDuplex: any);

            }

            class Stream {
                constructor(opts: any);

                pipe(dest: any, options: any): any;

                static Duplex: any;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static PassThrough: any;

                static Readable: any;

                static Stream: any;

                static Transform: any;

                static Writable: any;

                static addAbortSignal: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static compose: any;

                static defaultMaxListeners: any;

                static destroy: any;

                static errorMonitor: any;

                static finished: any;

                static getEventListeners: any;

                static init: any;

                static isDisturbed: any;

                static isErrored: any;

                static isReadable: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static pipeline: any;

                static promises: any;

                static setMaxListeners: any;

                static usingDomains: any;

            }

            class Writable {
                constructor(options: any);

                cork(): void;

                destroy(err: any, cb: any): any;

                end(chunk: any, encoding: any, cb: any): any;

                pipe(): void;

                setDefaultEncoding(encoding: any): any;

                uncork(): void;

                write(chunk: any, encoding: any, cb: any): any;

                static Duplex: any;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static PassThrough: any;

                static Readable: any;

                static Stream: any;

                static Transform: any;

                static Writable: any;

                static WritableState: any;

                static addAbortSignal: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static compose: any;

                static defaultMaxListeners: any;

                static destroy: any;

                static errorMonitor: any;

                static finished: any;

                static getEventListeners: any;

                static init: any;

                static isDisturbed: any;

                static isErrored: any;

                static isReadable: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static pipeline: any;

                static promises: any;

                static setMaxListeners: any;

                static usingDomains: any;

            }

            namespace promises {
                // Too-deep object hierarchy from fs.ReadStream.PassThrough.Transform.promises
                const finished: any;

                // Too-deep object hierarchy from fs.ReadStream.PassThrough.Transform.promises
                const pipeline: any;

            }

        }

        namespace Writable {
            class Duplex {
                constructor(options: any);

                cork(): void;

                end(chunk: any, encoding: any, cb: any): any;

                setDefaultEncoding(encoding: any): any;

                uncork(): void;

                write(chunk: any, encoding: any, cb: any): any;

                static Duplex: any;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static PassThrough: any;

                static Readable: any;

                static ReadableState: any;

                static Stream: any;

                static Transform: any;

                static Writable: any;

                static addAbortSignal: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static compose: any;

                static defaultMaxListeners: any;

                static destroy: any;

                static errorMonitor: any;

                static finished: any;

                static from: any;

                static getEventListeners: any;

                static init: any;

                static isDisturbed: any;

                static isErrored: any;

                static isReadable: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static pipeline: any;

                static promises: any;

                static setMaxListeners: any;

                static usingDomains: any;

                static wrap: any;

            }

            class EventEmitter {
                constructor(opts: any);

                addListener(type: any, listener: any): any;

                emit(type: any, args: any): any;

                eventNames(): any;

                getMaxListeners(): any;

                listenerCount(type: any): any;

                listeners(type: any): any;

                off(type: any, listener: any): any;

                on(type: any, listener: any): any;

                once(type: any, listener: any): any;

                prependListener(type: any, listener: any): any;

                prependOnceListener(type: any, listener: any): any;

                rawListeners(type: any): any;

                removeAllListeners(type: any, ...args: any[]): any;

                removeListener(type: any, listener: any): any;

                setMaxListeners(n: any): any;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static defaultMaxListeners: any;

                static errorMonitor: any;

                static getEventListeners: any;

                static init: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static setMaxListeners: any;

                static usingDomains: any;

            }

            class EventEmitterAsyncResource {
                constructor(...args: any[]);

                emit(...args: any[]): void;

                emitDestroy(...args: any[]): void;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static defaultMaxListeners: any;

                static errorMonitor: any;

                static getEventListeners: any;

                static init: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static setMaxListeners: any;

                static usingDomains: any;

            }

            class Readable {
                constructor(options: any);

                addListener(ev: any, fn: any): any;

                destroy(err: any, cb: any): any;

                filter(args: any): any;

                isPaused(): any;

                iterator(options: any): any;

                map(args: any): any;

                off(ev: any, fn: any): any;

                on(ev: any, fn: any): any;

                pause(): any;

                pipe(dest: any, pipeOpts: any): any;

                push(chunk: any, encoding: any): any;

                read(n: any): any;

                removeAllListeners(ev: any, ...args: any[]): any;

                removeListener(ev: any, fn: any): any;

                resume(): any;

                setEncoding(enc: any): any;

                unpipe(dest: any): any;

                unshift(chunk: any, encoding: any): any;

                wrap(stream: any): any;

                static Duplex: any;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static PassThrough: any;

                static Readable: any;

                static ReadableState: any;

                static Stream: any;

                static Transform: any;

                static Writable: any;

                static addAbortSignal: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static compose: any;

                static defaultMaxListeners: any;

                static destroy: any;

                static errorMonitor: any;

                static finished: any;

                static from: any;

                static getEventListeners: any;

                static init: any;

                static isDisturbed: any;

                static isErrored: any;

                static isReadable: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static pipeline: any;

                static promises: any;

                static setMaxListeners: any;

                static usingDomains: any;

                static wrap: any;

            }

            class Stream {
                constructor(opts: any);

                pipe(dest: any, options: any): any;

                static Duplex: any;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static PassThrough: any;

                static Readable: any;

                static Stream: any;

                static Transform: any;

                static Writable: any;

                static addAbortSignal: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static compose: any;

                static defaultMaxListeners: any;

                static destroy: any;

                static errorMonitor: any;

                static finished: any;

                static getEventListeners: any;

                static init: any;

                static isDisturbed: any;

                static isErrored: any;

                static isReadable: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static pipeline: any;

                static promises: any;

                static setMaxListeners: any;

                static usingDomains: any;

            }

            class Transform {
                constructor(options: any);

                static Duplex: any;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static PassThrough: any;

                static Readable: any;

                static ReadableState: any;

                static Stream: any;

                static Transform: any;

                static Writable: any;

                static addAbortSignal: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static compose: any;

                static defaultMaxListeners: any;

                static destroy: any;

                static errorMonitor: any;

                static finished: any;

                static from: any;

                static getEventListeners: any;

                static init: any;

                static isDisturbed: any;

                static isErrored: any;

                static isReadable: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static pipeline: any;

                static promises: any;

                static setMaxListeners: any;

                static usingDomains: any;

                static wrap: any;

            }

            class WritableState {
                constructor(options: any, stream: any, isDuplex: any);

                getBuffer(): any;

            }

            namespace promises {
                // Too-deep object hierarchy from fs.ReadStream.PassThrough.Writable.promises
                const finished: any;

                // Too-deep object hierarchy from fs.ReadStream.PassThrough.Writable.promises
                const pipeline: any;

            }

        }

        namespace promises {
            function finished(stream: any, opts: any): any;

            function pipeline(streams: any): any;

        }

    }

    namespace Readable {
        class Duplex {
            constructor(options: any);

            cork(): void;

            end(chunk: any, encoding: any, cb: any): any;

            setDefaultEncoding(encoding: any): any;

            uncork(): void;

            write(chunk: any, encoding: any, cb: any): any;

            static Duplex: any;

            static Readable: any;

            static addAbortSignal(signal: any, stream: any): any;

            static captureRejectionSymbol: any;

            static captureRejections: boolean;

            static compose(streams: any): any;

            static defaultMaxListeners: number;

            static destroy(stream: any, err: any): any;

            static errorMonitor: any;

            static finished(stream: any, options: any, callback: any, ...args: any[]): any;

            static from(body: any): any;

            static getEventListeners(emitterOrTarget: any, type: any): any;

            static init(opts: any): void;

            static isDisturbed(stream: any): any;

            static isErrored(stream: any): any;

            static isReadable(stream: any): any;

            static kMaxEventTargetListeners: any;

            static kMaxEventTargetListenersWarned: any;

            static listenerCount(emitter: any, type: any): any;

            static on(emitter: any, event: any, options: any): any;

            static once(emitter: any, name: any, options: any): any;

            static pipeline(streams: any): any;

            static setMaxListeners(n: any, eventTargets: any): void;

            static usingDomains: boolean;

            static wrap(src: any, options: any): any;

        }

        class EventEmitter {
            constructor(opts: any);

            addListener(type: any, listener: any): any;

            emit(type: any, args: any): any;

            eventNames(): any;

            getMaxListeners(): any;

            listenerCount(type: any): any;

            listeners(type: any): any;

            off(type: any, listener: any): any;

            on(type: any, listener: any): any;

            once(type: any, listener: any): any;

            prependListener(type: any, listener: any): any;

            prependOnceListener(type: any, listener: any): any;

            rawListeners(type: any): any;

            removeAllListeners(type: any, ...args: any[]): any;

            removeListener(type: any, listener: any): any;

            setMaxListeners(n: any): any;

            static EventEmitter: any;

            static captureRejectionSymbol: any;

            static captureRejections: boolean;

            static defaultMaxListeners: number;

            static errorMonitor: any;

            static getEventListeners(emitterOrTarget: any, type: any): any;

            static init(opts: any): void;

            static kMaxEventTargetListeners: any;

            static kMaxEventTargetListenersWarned: any;

            static listenerCount(emitter: any, type: any): any;

            static on(emitter: any, event: any, options: any): any;

            static once(emitter: any, name: any, options: any): any;

            static setMaxListeners(n: any, eventTargets: any): void;

            static usingDomains: boolean;

        }

        class EventEmitterAsyncResource {
            constructor(...args: any[]);

            emit(...args: any[]): void;

            emitDestroy(...args: any[]): void;

            static EventEmitterAsyncResource: any;

            static captureRejectionSymbol: any;

            static captureRejections: boolean;

            static defaultMaxListeners: number;

            static errorMonitor: any;

            static getEventListeners(emitterOrTarget: any, type: any): any;

            static init(opts: any): void;

            static kMaxEventTargetListeners: any;

            static kMaxEventTargetListenersWarned: any;

            static listenerCount(emitter: any, type: any): any;

            static on(emitter: any, event: any, options: any): any;

            static once(emitter: any, name: any, options: any): any;

            static setMaxListeners(n: any, eventTargets: any): void;

            static usingDomains: boolean;

        }

        class PassThrough {
            constructor(options: any);

            static PassThrough: any;

            static Readable: any;

            static addAbortSignal(signal: any, stream: any): any;

            static captureRejectionSymbol: any;

            static captureRejections: boolean;

            static compose(streams: any): any;

            static defaultMaxListeners: number;

            static destroy(stream: any, err: any): any;

            static errorMonitor: any;

            static finished(stream: any, options: any, callback: any, ...args: any[]): any;

            static from(body: any): any;

            static getEventListeners(emitterOrTarget: any, type: any): any;

            static init(opts: any): void;

            static isDisturbed(stream: any): any;

            static isErrored(stream: any): any;

            static isReadable(stream: any): any;

            static kMaxEventTargetListeners: any;

            static kMaxEventTargetListenersWarned: any;

            static listenerCount(emitter: any, type: any): any;

            static on(emitter: any, event: any, options: any): any;

            static once(emitter: any, name: any, options: any): any;

            static pipeline(streams: any): any;

            static setMaxListeners(n: any, eventTargets: any): void;

            static usingDomains: boolean;

            static wrap(src: any, options: any): any;

        }

        class ReadableState {
            constructor(options: any, stream: any, isDuplex: any);

        }

        class Stream {
            constructor(opts: any);

            pipe(dest: any, options: any): any;

            static Readable: any;

            static Stream: any;

            static addAbortSignal(signal: any, stream: any): any;

            static captureRejectionSymbol: any;

            static captureRejections: boolean;

            static compose(streams: any): any;

            static defaultMaxListeners: number;

            static destroy(stream: any, err: any): any;

            static errorMonitor: any;

            static finished(stream: any, options: any, callback: any, ...args: any[]): any;

            static getEventListeners(emitterOrTarget: any, type: any): any;

            static init(opts: any): void;

            static isDisturbed(stream: any): any;

            static isErrored(stream: any): any;

            static isReadable(stream: any): any;

            static kMaxEventTargetListeners: any;

            static kMaxEventTargetListenersWarned: any;

            static listenerCount(emitter: any, type: any): any;

            static on(emitter: any, event: any, options: any): any;

            static once(emitter: any, name: any, options: any): any;

            static pipeline(streams: any): any;

            static setMaxListeners(n: any, eventTargets: any): void;

            static usingDomains: boolean;

        }

        class Transform {
            constructor(options: any);

            static Readable: any;

            static Transform: any;

            static addAbortSignal(signal: any, stream: any): any;

            static captureRejectionSymbol: any;

            static captureRejections: boolean;

            static compose(streams: any): any;

            static defaultMaxListeners: number;

            static destroy(stream: any, err: any): any;

            static errorMonitor: any;

            static finished(stream: any, options: any, callback: any, ...args: any[]): any;

            static from(body: any): any;

            static getEventListeners(emitterOrTarget: any, type: any): any;

            static init(opts: any): void;

            static isDisturbed(stream: any): any;

            static isErrored(stream: any): any;

            static isReadable(stream: any): any;

            static kMaxEventTargetListeners: any;

            static kMaxEventTargetListenersWarned: any;

            static listenerCount(emitter: any, type: any): any;

            static on(emitter: any, event: any, options: any): any;

            static once(emitter: any, name: any, options: any): any;

            static pipeline(streams: any): any;

            static setMaxListeners(n: any, eventTargets: any): void;

            static usingDomains: boolean;

            static wrap(src: any, options: any): any;

        }

        class Writable {
            constructor(options: any);

            cork(): void;

            destroy(err: any, cb: any): any;

            end(chunk: any, encoding: any, cb: any): any;

            pipe(): void;

            setDefaultEncoding(encoding: any): any;

            uncork(): void;

            write(chunk: any, encoding: any, cb: any): any;

            static Readable: any;

            static Writable: any;

            static addAbortSignal(signal: any, stream: any): any;

            static captureRejectionSymbol: any;

            static captureRejections: boolean;

            static compose(streams: any): any;

            static defaultMaxListeners: number;

            static destroy(stream: any, err: any): any;

            static errorMonitor: any;

            static finished(stream: any, options: any, callback: any, ...args: any[]): any;

            static getEventListeners(emitterOrTarget: any, type: any): any;

            static init(opts: any): void;

            static isDisturbed(stream: any): any;

            static isErrored(stream: any): any;

            static isReadable(stream: any): any;

            static kMaxEventTargetListeners: any;

            static kMaxEventTargetListenersWarned: any;

            static listenerCount(emitter: any, type: any): any;

            static on(emitter: any, event: any, options: any): any;

            static once(emitter: any, name: any, options: any): any;

            static pipeline(streams: any): any;

            static setMaxListeners(n: any, eventTargets: any): void;

            static usingDomains: boolean;

        }

        namespace Duplex {
            class EventEmitter {
                constructor(opts: any);

                addListener(type: any, listener: any): any;

                emit(type: any, args: any): any;

                eventNames(): any;

                getMaxListeners(): any;

                listenerCount(type: any): any;

                listeners(type: any): any;

                off(type: any, listener: any): any;

                on(type: any, listener: any): any;

                once(type: any, listener: any): any;

                prependListener(type: any, listener: any): any;

                prependOnceListener(type: any, listener: any): any;

                rawListeners(type: any): any;

                removeAllListeners(type: any, ...args: any[]): any;

                removeListener(type: any, listener: any): any;

                setMaxListeners(n: any): any;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static defaultMaxListeners: any;

                static errorMonitor: any;

                static getEventListeners: any;

                static init: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static setMaxListeners: any;

                static usingDomains: any;

            }

            class EventEmitterAsyncResource {
                constructor(...args: any[]);

                emit(...args: any[]): void;

                emitDestroy(...args: any[]): void;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static defaultMaxListeners: any;

                static errorMonitor: any;

                static getEventListeners: any;

                static init: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static setMaxListeners: any;

                static usingDomains: any;

            }

            class PassThrough {
                constructor(options: any);

                static Duplex: any;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static PassThrough: any;

                static Readable: any;

                static ReadableState: any;

                static Stream: any;

                static Transform: any;

                static Writable: any;

                static addAbortSignal: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static compose: any;

                static defaultMaxListeners: any;

                static destroy: any;

                static errorMonitor: any;

                static finished: any;

                static from: any;

                static getEventListeners: any;

                static init: any;

                static isDisturbed: any;

                static isErrored: any;

                static isReadable: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static pipeline: any;

                static promises: any;

                static setMaxListeners: any;

                static usingDomains: any;

                static wrap: any;

            }

            class ReadableState {
                constructor(options: any, stream: any, isDuplex: any);

            }

            class Stream {
                constructor(opts: any);

                pipe(dest: any, options: any): any;

                static Duplex: any;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static PassThrough: any;

                static Readable: any;

                static Stream: any;

                static Transform: any;

                static Writable: any;

                static addAbortSignal: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static compose: any;

                static defaultMaxListeners: any;

                static destroy: any;

                static errorMonitor: any;

                static finished: any;

                static getEventListeners: any;

                static init: any;

                static isDisturbed: any;

                static isErrored: any;

                static isReadable: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static pipeline: any;

                static promises: any;

                static setMaxListeners: any;

                static usingDomains: any;

            }

            class Transform {
                constructor(options: any);

                static Duplex: any;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static PassThrough: any;

                static Readable: any;

                static ReadableState: any;

                static Stream: any;

                static Transform: any;

                static Writable: any;

                static addAbortSignal: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static compose: any;

                static defaultMaxListeners: any;

                static destroy: any;

                static errorMonitor: any;

                static finished: any;

                static from: any;

                static getEventListeners: any;

                static init: any;

                static isDisturbed: any;

                static isErrored: any;

                static isReadable: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static pipeline: any;

                static promises: any;

                static setMaxListeners: any;

                static usingDomains: any;

                static wrap: any;

            }

            class Writable {
                constructor(options: any);

                cork(): void;

                destroy(err: any, cb: any): any;

                end(chunk: any, encoding: any, cb: any): any;

                pipe(): void;

                setDefaultEncoding(encoding: any): any;

                uncork(): void;

                write(chunk: any, encoding: any, cb: any): any;

                static Duplex: any;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static PassThrough: any;

                static Readable: any;

                static Stream: any;

                static Transform: any;

                static Writable: any;

                static WritableState: any;

                static addAbortSignal: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static compose: any;

                static defaultMaxListeners: any;

                static destroy: any;

                static errorMonitor: any;

                static finished: any;

                static getEventListeners: any;

                static init: any;

                static isDisturbed: any;

                static isErrored: any;

                static isReadable: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static pipeline: any;

                static promises: any;

                static setMaxListeners: any;

                static usingDomains: any;

            }

            namespace promises {
                // Too-deep object hierarchy from fs.ReadStream.Readable.Duplex.promises
                const finished: any;

                // Too-deep object hierarchy from fs.ReadStream.Readable.Duplex.promises
                const pipeline: any;

            }

        }

        namespace EventEmitter {
            class EventEmitterAsyncResource {
                constructor(...args: any[]);

                emit(...args: any[]): void;

                emitDestroy(...args: any[]): void;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static defaultMaxListeners: any;

                static errorMonitor: any;

                static getEventListeners: any;

                static init: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static setMaxListeners: any;

                static usingDomains: any;

            }

        }

        namespace EventEmitterAsyncResource {
            class EventEmitter {
                constructor(opts: any);

                addListener(type: any, listener: any): any;

                emit(type: any, args: any): any;

                eventNames(): any;

                getMaxListeners(): any;

                listenerCount(type: any): any;

                listeners(type: any): any;

                off(type: any, listener: any): any;

                on(type: any, listener: any): any;

                once(type: any, listener: any): any;

                prependListener(type: any, listener: any): any;

                prependOnceListener(type: any, listener: any): any;

                rawListeners(type: any): any;

                removeAllListeners(type: any, ...args: any[]): any;

                removeListener(type: any, listener: any): any;

                setMaxListeners(n: any): any;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static defaultMaxListeners: any;

                static errorMonitor: any;

                static getEventListeners: any;

                static init: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static setMaxListeners: any;

                static usingDomains: any;

            }

        }

        namespace PassThrough {
            class Duplex {
                constructor(options: any);

                cork(): void;

                end(chunk: any, encoding: any, cb: any): any;

                setDefaultEncoding(encoding: any): any;

                uncork(): void;

                write(chunk: any, encoding: any, cb: any): any;

                static Duplex: any;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static PassThrough: any;

                static Readable: any;

                static ReadableState: any;

                static Stream: any;

                static Transform: any;

                static Writable: any;

                static addAbortSignal: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static compose: any;

                static defaultMaxListeners: any;

                static destroy: any;

                static errorMonitor: any;

                static finished: any;

                static from: any;

                static getEventListeners: any;

                static init: any;

                static isDisturbed: any;

                static isErrored: any;

                static isReadable: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static pipeline: any;

                static promises: any;

                static setMaxListeners: any;

                static usingDomains: any;

                static wrap: any;

            }

            class EventEmitter {
                constructor(opts: any);

                addListener(type: any, listener: any): any;

                emit(type: any, args: any): any;

                eventNames(): any;

                getMaxListeners(): any;

                listenerCount(type: any): any;

                listeners(type: any): any;

                off(type: any, listener: any): any;

                on(type: any, listener: any): any;

                once(type: any, listener: any): any;

                prependListener(type: any, listener: any): any;

                prependOnceListener(type: any, listener: any): any;

                rawListeners(type: any): any;

                removeAllListeners(type: any, ...args: any[]): any;

                removeListener(type: any, listener: any): any;

                setMaxListeners(n: any): any;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static defaultMaxListeners: any;

                static errorMonitor: any;

                static getEventListeners: any;

                static init: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static setMaxListeners: any;

                static usingDomains: any;

            }

            class EventEmitterAsyncResource {
                constructor(...args: any[]);

                emit(...args: any[]): void;

                emitDestroy(...args: any[]): void;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static defaultMaxListeners: any;

                static errorMonitor: any;

                static getEventListeners: any;

                static init: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static setMaxListeners: any;

                static usingDomains: any;

            }

            class ReadableState {
                constructor(options: any, stream: any, isDuplex: any);

            }

            class Stream {
                constructor(opts: any);

                pipe(dest: any, options: any): any;

                static Duplex: any;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static PassThrough: any;

                static Readable: any;

                static Stream: any;

                static Transform: any;

                static Writable: any;

                static addAbortSignal: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static compose: any;

                static defaultMaxListeners: any;

                static destroy: any;

                static errorMonitor: any;

                static finished: any;

                static getEventListeners: any;

                static init: any;

                static isDisturbed: any;

                static isErrored: any;

                static isReadable: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static pipeline: any;

                static promises: any;

                static setMaxListeners: any;

                static usingDomains: any;

            }

            class Transform {
                constructor(options: any);

                static Duplex: any;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static PassThrough: any;

                static Readable: any;

                static ReadableState: any;

                static Stream: any;

                static Transform: any;

                static Writable: any;

                static addAbortSignal: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static compose: any;

                static defaultMaxListeners: any;

                static destroy: any;

                static errorMonitor: any;

                static finished: any;

                static from: any;

                static getEventListeners: any;

                static init: any;

                static isDisturbed: any;

                static isErrored: any;

                static isReadable: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static pipeline: any;

                static promises: any;

                static setMaxListeners: any;

                static usingDomains: any;

                static wrap: any;

            }

            class Writable {
                constructor(options: any);

                cork(): void;

                destroy(err: any, cb: any): any;

                end(chunk: any, encoding: any, cb: any): any;

                pipe(): void;

                setDefaultEncoding(encoding: any): any;

                uncork(): void;

                write(chunk: any, encoding: any, cb: any): any;

                static Duplex: any;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static PassThrough: any;

                static Readable: any;

                static Stream: any;

                static Transform: any;

                static Writable: any;

                static WritableState: any;

                static addAbortSignal: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static compose: any;

                static defaultMaxListeners: any;

                static destroy: any;

                static errorMonitor: any;

                static finished: any;

                static getEventListeners: any;

                static init: any;

                static isDisturbed: any;

                static isErrored: any;

                static isReadable: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static pipeline: any;

                static promises: any;

                static setMaxListeners: any;

                static usingDomains: any;

            }

            namespace promises {
                // Too-deep object hierarchy from fs.ReadStream.Readable.PassThrough.promises
                const finished: any;

                // Too-deep object hierarchy from fs.ReadStream.Readable.PassThrough.promises
                const pipeline: any;

            }

        }

        namespace Stream {
            class Duplex {
                constructor(options: any);

                cork(): void;

                end(chunk: any, encoding: any, cb: any): any;

                setDefaultEncoding(encoding: any): any;

                uncork(): void;

                write(chunk: any, encoding: any, cb: any): any;

                static Duplex: any;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static PassThrough: any;

                static Readable: any;

                static ReadableState: any;

                static Stream: any;

                static Transform: any;

                static Writable: any;

                static addAbortSignal: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static compose: any;

                static defaultMaxListeners: any;

                static destroy: any;

                static errorMonitor: any;

                static finished: any;

                static from: any;

                static getEventListeners: any;

                static init: any;

                static isDisturbed: any;

                static isErrored: any;

                static isReadable: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static pipeline: any;

                static promises: any;

                static setMaxListeners: any;

                static usingDomains: any;

                static wrap: any;

            }

            class EventEmitter {
                constructor(opts: any);

                addListener(type: any, listener: any): any;

                emit(type: any, args: any): any;

                eventNames(): any;

                getMaxListeners(): any;

                listenerCount(type: any): any;

                listeners(type: any): any;

                off(type: any, listener: any): any;

                on(type: any, listener: any): any;

                once(type: any, listener: any): any;

                prependListener(type: any, listener: any): any;

                prependOnceListener(type: any, listener: any): any;

                rawListeners(type: any): any;

                removeAllListeners(type: any, ...args: any[]): any;

                removeListener(type: any, listener: any): any;

                setMaxListeners(n: any): any;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static defaultMaxListeners: any;

                static errorMonitor: any;

                static getEventListeners: any;

                static init: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static setMaxListeners: any;

                static usingDomains: any;

            }

            class EventEmitterAsyncResource {
                constructor(...args: any[]);

                emit(...args: any[]): void;

                emitDestroy(...args: any[]): void;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static defaultMaxListeners: any;

                static errorMonitor: any;

                static getEventListeners: any;

                static init: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static setMaxListeners: any;

                static usingDomains: any;

            }

            class PassThrough {
                constructor(options: any);

                static Duplex: any;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static PassThrough: any;

                static Readable: any;

                static ReadableState: any;

                static Stream: any;

                static Transform: any;

                static Writable: any;

                static addAbortSignal: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static compose: any;

                static defaultMaxListeners: any;

                static destroy: any;

                static errorMonitor: any;

                static finished: any;

                static from: any;

                static getEventListeners: any;

                static init: any;

                static isDisturbed: any;

                static isErrored: any;

                static isReadable: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static pipeline: any;

                static promises: any;

                static setMaxListeners: any;

                static usingDomains: any;

                static wrap: any;

            }

            class Transform {
                constructor(options: any);

                static Duplex: any;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static PassThrough: any;

                static Readable: any;

                static ReadableState: any;

                static Stream: any;

                static Transform: any;

                static Writable: any;

                static addAbortSignal: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static compose: any;

                static defaultMaxListeners: any;

                static destroy: any;

                static errorMonitor: any;

                static finished: any;

                static from: any;

                static getEventListeners: any;

                static init: any;

                static isDisturbed: any;

                static isErrored: any;

                static isReadable: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static pipeline: any;

                static promises: any;

                static setMaxListeners: any;

                static usingDomains: any;

                static wrap: any;

            }

            class Writable {
                constructor(options: any);

                cork(): void;

                destroy(err: any, cb: any): any;

                end(chunk: any, encoding: any, cb: any): any;

                pipe(): void;

                setDefaultEncoding(encoding: any): any;

                uncork(): void;

                write(chunk: any, encoding: any, cb: any): any;

                static Duplex: any;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static PassThrough: any;

                static Readable: any;

                static Stream: any;

                static Transform: any;

                static Writable: any;

                static WritableState: any;

                static addAbortSignal: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static compose: any;

                static defaultMaxListeners: any;

                static destroy: any;

                static errorMonitor: any;

                static finished: any;

                static getEventListeners: any;

                static init: any;

                static isDisturbed: any;

                static isErrored: any;

                static isReadable: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static pipeline: any;

                static promises: any;

                static setMaxListeners: any;

                static usingDomains: any;

            }

            namespace promises {
                // Too-deep object hierarchy from fs.ReadStream.Readable.Stream.promises
                const finished: any;

                // Too-deep object hierarchy from fs.ReadStream.Readable.Stream.promises
                const pipeline: any;

            }

        }

        namespace Transform {
            class Duplex {
                constructor(options: any);

                cork(): void;

                end(chunk: any, encoding: any, cb: any): any;

                setDefaultEncoding(encoding: any): any;

                uncork(): void;

                write(chunk: any, encoding: any, cb: any): any;

                static Duplex: any;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static PassThrough: any;

                static Readable: any;

                static ReadableState: any;

                static Stream: any;

                static Transform: any;

                static Writable: any;

                static addAbortSignal: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static compose: any;

                static defaultMaxListeners: any;

                static destroy: any;

                static errorMonitor: any;

                static finished: any;

                static from: any;

                static getEventListeners: any;

                static init: any;

                static isDisturbed: any;

                static isErrored: any;

                static isReadable: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static pipeline: any;

                static promises: any;

                static setMaxListeners: any;

                static usingDomains: any;

                static wrap: any;

            }

            class EventEmitter {
                constructor(opts: any);

                addListener(type: any, listener: any): any;

                emit(type: any, args: any): any;

                eventNames(): any;

                getMaxListeners(): any;

                listenerCount(type: any): any;

                listeners(type: any): any;

                off(type: any, listener: any): any;

                on(type: any, listener: any): any;

                once(type: any, listener: any): any;

                prependListener(type: any, listener: any): any;

                prependOnceListener(type: any, listener: any): any;

                rawListeners(type: any): any;

                removeAllListeners(type: any, ...args: any[]): any;

                removeListener(type: any, listener: any): any;

                setMaxListeners(n: any): any;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static defaultMaxListeners: any;

                static errorMonitor: any;

                static getEventListeners: any;

                static init: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static setMaxListeners: any;

                static usingDomains: any;

            }

            class EventEmitterAsyncResource {
                constructor(...args: any[]);

                emit(...args: any[]): void;

                emitDestroy(...args: any[]): void;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static defaultMaxListeners: any;

                static errorMonitor: any;

                static getEventListeners: any;

                static init: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static setMaxListeners: any;

                static usingDomains: any;

            }

            class PassThrough {
                constructor(options: any);

                static Duplex: any;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static PassThrough: any;

                static Readable: any;

                static ReadableState: any;

                static Stream: any;

                static Transform: any;

                static Writable: any;

                static addAbortSignal: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static compose: any;

                static defaultMaxListeners: any;

                static destroy: any;

                static errorMonitor: any;

                static finished: any;

                static from: any;

                static getEventListeners: any;

                static init: any;

                static isDisturbed: any;

                static isErrored: any;

                static isReadable: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static pipeline: any;

                static promises: any;

                static setMaxListeners: any;

                static usingDomains: any;

                static wrap: any;

            }

            class ReadableState {
                constructor(options: any, stream: any, isDuplex: any);

            }

            class Stream {
                constructor(opts: any);

                pipe(dest: any, options: any): any;

                static Duplex: any;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static PassThrough: any;

                static Readable: any;

                static Stream: any;

                static Transform: any;

                static Writable: any;

                static addAbortSignal: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static compose: any;

                static defaultMaxListeners: any;

                static destroy: any;

                static errorMonitor: any;

                static finished: any;

                static getEventListeners: any;

                static init: any;

                static isDisturbed: any;

                static isErrored: any;

                static isReadable: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static pipeline: any;

                static promises: any;

                static setMaxListeners: any;

                static usingDomains: any;

            }

            class Writable {
                constructor(options: any);

                cork(): void;

                destroy(err: any, cb: any): any;

                end(chunk: any, encoding: any, cb: any): any;

                pipe(): void;

                setDefaultEncoding(encoding: any): any;

                uncork(): void;

                write(chunk: any, encoding: any, cb: any): any;

                static Duplex: any;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static PassThrough: any;

                static Readable: any;

                static Stream: any;

                static Transform: any;

                static Writable: any;

                static WritableState: any;

                static addAbortSignal: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static compose: any;

                static defaultMaxListeners: any;

                static destroy: any;

                static errorMonitor: any;

                static finished: any;

                static getEventListeners: any;

                static init: any;

                static isDisturbed: any;

                static isErrored: any;

                static isReadable: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static pipeline: any;

                static promises: any;

                static setMaxListeners: any;

                static usingDomains: any;

            }

            namespace promises {
                // Too-deep object hierarchy from fs.ReadStream.Readable.Transform.promises
                const finished: any;

                // Too-deep object hierarchy from fs.ReadStream.Readable.Transform.promises
                const pipeline: any;

            }

        }

        namespace Writable {
            class Duplex {
                constructor(options: any);

                cork(): void;

                end(chunk: any, encoding: any, cb: any): any;

                setDefaultEncoding(encoding: any): any;

                uncork(): void;

                write(chunk: any, encoding: any, cb: any): any;

                static Duplex: any;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static PassThrough: any;

                static Readable: any;

                static ReadableState: any;

                static Stream: any;

                static Transform: any;

                static Writable: any;

                static addAbortSignal: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static compose: any;

                static defaultMaxListeners: any;

                static destroy: any;

                static errorMonitor: any;

                static finished: any;

                static from: any;

                static getEventListeners: any;

                static init: any;

                static isDisturbed: any;

                static isErrored: any;

                static isReadable: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static pipeline: any;

                static promises: any;

                static setMaxListeners: any;

                static usingDomains: any;

                static wrap: any;

            }

            class EventEmitter {
                constructor(opts: any);

                addListener(type: any, listener: any): any;

                emit(type: any, args: any): any;

                eventNames(): any;

                getMaxListeners(): any;

                listenerCount(type: any): any;

                listeners(type: any): any;

                off(type: any, listener: any): any;

                on(type: any, listener: any): any;

                once(type: any, listener: any): any;

                prependListener(type: any, listener: any): any;

                prependOnceListener(type: any, listener: any): any;

                rawListeners(type: any): any;

                removeAllListeners(type: any, ...args: any[]): any;

                removeListener(type: any, listener: any): any;

                setMaxListeners(n: any): any;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static defaultMaxListeners: any;

                static errorMonitor: any;

                static getEventListeners: any;

                static init: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static setMaxListeners: any;

                static usingDomains: any;

            }

            class EventEmitterAsyncResource {
                constructor(...args: any[]);

                emit(...args: any[]): void;

                emitDestroy(...args: any[]): void;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static defaultMaxListeners: any;

                static errorMonitor: any;

                static getEventListeners: any;

                static init: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static setMaxListeners: any;

                static usingDomains: any;

            }

            class PassThrough {
                constructor(options: any);

                static Duplex: any;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static PassThrough: any;

                static Readable: any;

                static ReadableState: any;

                static Stream: any;

                static Transform: any;

                static Writable: any;

                static addAbortSignal: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static compose: any;

                static defaultMaxListeners: any;

                static destroy: any;

                static errorMonitor: any;

                static finished: any;

                static from: any;

                static getEventListeners: any;

                static init: any;

                static isDisturbed: any;

                static isErrored: any;

                static isReadable: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static pipeline: any;

                static promises: any;

                static setMaxListeners: any;

                static usingDomains: any;

                static wrap: any;

            }

            class Stream {
                constructor(opts: any);

                pipe(dest: any, options: any): any;

                static Duplex: any;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static PassThrough: any;

                static Readable: any;

                static Stream: any;

                static Transform: any;

                static Writable: any;

                static addAbortSignal: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static compose: any;

                static defaultMaxListeners: any;

                static destroy: any;

                static errorMonitor: any;

                static finished: any;

                static getEventListeners: any;

                static init: any;

                static isDisturbed: any;

                static isErrored: any;

                static isReadable: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static pipeline: any;

                static promises: any;

                static setMaxListeners: any;

                static usingDomains: any;

            }

            class Transform {
                constructor(options: any);

                static Duplex: any;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static PassThrough: any;

                static Readable: any;

                static ReadableState: any;

                static Stream: any;

                static Transform: any;

                static Writable: any;

                static addAbortSignal: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static compose: any;

                static defaultMaxListeners: any;

                static destroy: any;

                static errorMonitor: any;

                static finished: any;

                static from: any;

                static getEventListeners: any;

                static init: any;

                static isDisturbed: any;

                static isErrored: any;

                static isReadable: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static pipeline: any;

                static promises: any;

                static setMaxListeners: any;

                static usingDomains: any;

                static wrap: any;

            }

            class WritableState {
                constructor(options: any, stream: any, isDuplex: any);

                getBuffer(): any;

            }

            namespace promises {
                // Too-deep object hierarchy from fs.ReadStream.Readable.Writable.promises
                const finished: any;

                // Too-deep object hierarchy from fs.ReadStream.Readable.Writable.promises
                const pipeline: any;

            }

        }

        namespace promises {
            function finished(stream: any, opts: any): any;

            function pipeline(streams: any): any;

        }

    }

    namespace Stream {
        class Duplex {
            constructor(options: any);

            cork(): void;

            end(chunk: any, encoding: any, cb: any): any;

            setDefaultEncoding(encoding: any): any;

            uncork(): void;

            write(chunk: any, encoding: any, cb: any): any;

            static Duplex: any;

            static Stream: any;

            static addAbortSignal(signal: any, stream: any): any;

            static captureRejectionSymbol: any;

            static captureRejections: boolean;

            static compose(streams: any): any;

            static defaultMaxListeners: number;

            static destroy(stream: any, err: any): any;

            static errorMonitor: any;

            static finished(stream: any, options: any, callback: any, ...args: any[]): any;

            static from(body: any): any;

            static getEventListeners(emitterOrTarget: any, type: any): any;

            static init(opts: any): void;

            static isDisturbed(stream: any): any;

            static isErrored(stream: any): any;

            static isReadable(stream: any): any;

            static kMaxEventTargetListeners: any;

            static kMaxEventTargetListenersWarned: any;

            static listenerCount(emitter: any, type: any): any;

            static on(emitter: any, event: any, options: any): any;

            static once(emitter: any, name: any, options: any): any;

            static pipeline(streams: any): any;

            static setMaxListeners(n: any, eventTargets: any): void;

            static usingDomains: boolean;

            static wrap(src: any, options: any): any;

        }

        class EventEmitter {
            constructor(opts: any);

            addListener(type: any, listener: any): any;

            emit(type: any, args: any): any;

            eventNames(): any;

            getMaxListeners(): any;

            listenerCount(type: any): any;

            listeners(type: any): any;

            off(type: any, listener: any): any;

            on(type: any, listener: any): any;

            once(type: any, listener: any): any;

            prependListener(type: any, listener: any): any;

            prependOnceListener(type: any, listener: any): any;

            rawListeners(type: any): any;

            removeAllListeners(type: any, ...args: any[]): any;

            removeListener(type: any, listener: any): any;

            setMaxListeners(n: any): any;

            static EventEmitter: any;

            static captureRejectionSymbol: any;

            static captureRejections: boolean;

            static defaultMaxListeners: number;

            static errorMonitor: any;

            static getEventListeners(emitterOrTarget: any, type: any): any;

            static init(opts: any): void;

            static kMaxEventTargetListeners: any;

            static kMaxEventTargetListenersWarned: any;

            static listenerCount(emitter: any, type: any): any;

            static on(emitter: any, event: any, options: any): any;

            static once(emitter: any, name: any, options: any): any;

            static setMaxListeners(n: any, eventTargets: any): void;

            static usingDomains: boolean;

        }

        class EventEmitterAsyncResource {
            constructor(...args: any[]);

            emit(...args: any[]): void;

            emitDestroy(...args: any[]): void;

            static EventEmitterAsyncResource: any;

            static captureRejectionSymbol: any;

            static captureRejections: boolean;

            static defaultMaxListeners: number;

            static errorMonitor: any;

            static getEventListeners(emitterOrTarget: any, type: any): any;

            static init(opts: any): void;

            static kMaxEventTargetListeners: any;

            static kMaxEventTargetListenersWarned: any;

            static listenerCount(emitter: any, type: any): any;

            static on(emitter: any, event: any, options: any): any;

            static once(emitter: any, name: any, options: any): any;

            static setMaxListeners(n: any, eventTargets: any): void;

            static usingDomains: boolean;

        }

        class PassThrough {
            constructor(options: any);

            static PassThrough: any;

            static Stream: any;

            static addAbortSignal(signal: any, stream: any): any;

            static captureRejectionSymbol: any;

            static captureRejections: boolean;

            static compose(streams: any): any;

            static defaultMaxListeners: number;

            static destroy(stream: any, err: any): any;

            static errorMonitor: any;

            static finished(stream: any, options: any, callback: any, ...args: any[]): any;

            static from(body: any): any;

            static getEventListeners(emitterOrTarget: any, type: any): any;

            static init(opts: any): void;

            static isDisturbed(stream: any): any;

            static isErrored(stream: any): any;

            static isReadable(stream: any): any;

            static kMaxEventTargetListeners: any;

            static kMaxEventTargetListenersWarned: any;

            static listenerCount(emitter: any, type: any): any;

            static on(emitter: any, event: any, options: any): any;

            static once(emitter: any, name: any, options: any): any;

            static pipeline(streams: any): any;

            static setMaxListeners(n: any, eventTargets: any): void;

            static usingDomains: boolean;

            static wrap(src: any, options: any): any;

        }

        class Readable {
            constructor(options: any);

            addListener(ev: any, fn: any): any;

            destroy(err: any, cb: any): any;

            filter(args: any): any;

            isPaused(): any;

            iterator(options: any): any;

            map(args: any): any;

            off(ev: any, fn: any): any;

            on(ev: any, fn: any): any;

            pause(): any;

            pipe(dest: any, pipeOpts: any): any;

            push(chunk: any, encoding: any): any;

            read(n: any): any;

            removeAllListeners(ev: any, ...args: any[]): any;

            removeListener(ev: any, fn: any): any;

            resume(): any;

            setEncoding(enc: any): any;

            unpipe(dest: any): any;

            unshift(chunk: any, encoding: any): any;

            wrap(stream: any): any;

            static Readable: any;

            static Stream: any;

            static addAbortSignal(signal: any, stream: any): any;

            static captureRejectionSymbol: any;

            static captureRejections: boolean;

            static compose(streams: any): any;

            static defaultMaxListeners: number;

            static destroy(stream: any, err: any): any;

            static errorMonitor: any;

            static finished(stream: any, options: any, callback: any, ...args: any[]): any;

            static from(iterable: any, opts: any): any;

            static getEventListeners(emitterOrTarget: any, type: any): any;

            static init(opts: any): void;

            static isDisturbed(stream: any): any;

            static isErrored(stream: any): any;

            static isReadable(stream: any): any;

            static kMaxEventTargetListeners: any;

            static kMaxEventTargetListenersWarned: any;

            static listenerCount(emitter: any, type: any): any;

            static on(emitter: any, event: any, options: any): any;

            static once(emitter: any, name: any, options: any): any;

            static pipeline(streams: any): any;

            static setMaxListeners(n: any, eventTargets: any): void;

            static usingDomains: boolean;

            static wrap(src: any, options: any): any;

        }

        class Transform {
            constructor(options: any);

            static Stream: any;

            static Transform: any;

            static addAbortSignal(signal: any, stream: any): any;

            static captureRejectionSymbol: any;

            static captureRejections: boolean;

            static compose(streams: any): any;

            static defaultMaxListeners: number;

            static destroy(stream: any, err: any): any;

            static errorMonitor: any;

            static finished(stream: any, options: any, callback: any, ...args: any[]): any;

            static from(body: any): any;

            static getEventListeners(emitterOrTarget: any, type: any): any;

            static init(opts: any): void;

            static isDisturbed(stream: any): any;

            static isErrored(stream: any): any;

            static isReadable(stream: any): any;

            static kMaxEventTargetListeners: any;

            static kMaxEventTargetListenersWarned: any;

            static listenerCount(emitter: any, type: any): any;

            static on(emitter: any, event: any, options: any): any;

            static once(emitter: any, name: any, options: any): any;

            static pipeline(streams: any): any;

            static setMaxListeners(n: any, eventTargets: any): void;

            static usingDomains: boolean;

            static wrap(src: any, options: any): any;

        }

        class Writable {
            constructor(options: any);

            cork(): void;

            destroy(err: any, cb: any): any;

            end(chunk: any, encoding: any, cb: any): any;

            pipe(): void;

            setDefaultEncoding(encoding: any): any;

            uncork(): void;

            write(chunk: any, encoding: any, cb: any): any;

            static Stream: any;

            static Writable: any;

            static addAbortSignal(signal: any, stream: any): any;

            static captureRejectionSymbol: any;

            static captureRejections: boolean;

            static compose(streams: any): any;

            static defaultMaxListeners: number;

            static destroy(stream: any, err: any): any;

            static errorMonitor: any;

            static finished(stream: any, options: any, callback: any, ...args: any[]): any;

            static getEventListeners(emitterOrTarget: any, type: any): any;

            static init(opts: any): void;

            static isDisturbed(stream: any): any;

            static isErrored(stream: any): any;

            static isReadable(stream: any): any;

            static kMaxEventTargetListeners: any;

            static kMaxEventTargetListenersWarned: any;

            static listenerCount(emitter: any, type: any): any;

            static on(emitter: any, event: any, options: any): any;

            static once(emitter: any, name: any, options: any): any;

            static pipeline(streams: any): any;

            static setMaxListeners(n: any, eventTargets: any): void;

            static usingDomains: boolean;

        }

        namespace Duplex {
            class EventEmitter {
                constructor(opts: any);

                addListener(type: any, listener: any): any;

                emit(type: any, args: any): any;

                eventNames(): any;

                getMaxListeners(): any;

                listenerCount(type: any): any;

                listeners(type: any): any;

                off(type: any, listener: any): any;

                on(type: any, listener: any): any;

                once(type: any, listener: any): any;

                prependListener(type: any, listener: any): any;

                prependOnceListener(type: any, listener: any): any;

                rawListeners(type: any): any;

                removeAllListeners(type: any, ...args: any[]): any;

                removeListener(type: any, listener: any): any;

                setMaxListeners(n: any): any;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static defaultMaxListeners: any;

                static errorMonitor: any;

                static getEventListeners: any;

                static init: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static setMaxListeners: any;

                static usingDomains: any;

            }

            class EventEmitterAsyncResource {
                constructor(...args: any[]);

                emit(...args: any[]): void;

                emitDestroy(...args: any[]): void;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static defaultMaxListeners: any;

                static errorMonitor: any;

                static getEventListeners: any;

                static init: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static setMaxListeners: any;

                static usingDomains: any;

            }

            class PassThrough {
                constructor(options: any);

                static Duplex: any;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static PassThrough: any;

                static Readable: any;

                static ReadableState: any;

                static Stream: any;

                static Transform: any;

                static Writable: any;

                static addAbortSignal: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static compose: any;

                static defaultMaxListeners: any;

                static destroy: any;

                static errorMonitor: any;

                static finished: any;

                static from: any;

                static getEventListeners: any;

                static init: any;

                static isDisturbed: any;

                static isErrored: any;

                static isReadable: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static pipeline: any;

                static promises: any;

                static setMaxListeners: any;

                static usingDomains: any;

                static wrap: any;

            }

            class Readable {
                constructor(options: any);

                addListener(ev: any, fn: any): any;

                destroy(err: any, cb: any): any;

                filter(args: any): any;

                isPaused(): any;

                iterator(options: any): any;

                map(args: any): any;

                off(ev: any, fn: any): any;

                on(ev: any, fn: any): any;

                pause(): any;

                pipe(dest: any, pipeOpts: any): any;

                push(chunk: any, encoding: any): any;

                read(n: any): any;

                removeAllListeners(ev: any, ...args: any[]): any;

                removeListener(ev: any, fn: any): any;

                resume(): any;

                setEncoding(enc: any): any;

                unpipe(dest: any): any;

                unshift(chunk: any, encoding: any): any;

                wrap(stream: any): any;

                static Duplex: any;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static PassThrough: any;

                static Readable: any;

                static ReadableState: any;

                static Stream: any;

                static Transform: any;

                static Writable: any;

                static addAbortSignal: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static compose: any;

                static defaultMaxListeners: any;

                static destroy: any;

                static errorMonitor: any;

                static finished: any;

                static from: any;

                static getEventListeners: any;

                static init: any;

                static isDisturbed: any;

                static isErrored: any;

                static isReadable: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static pipeline: any;

                static promises: any;

                static setMaxListeners: any;

                static usingDomains: any;

                static wrap: any;

            }

            class ReadableState {
                constructor(options: any, stream: any, isDuplex: any);

            }

            class Transform {
                constructor(options: any);

                static Duplex: any;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static PassThrough: any;

                static Readable: any;

                static ReadableState: any;

                static Stream: any;

                static Transform: any;

                static Writable: any;

                static addAbortSignal: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static compose: any;

                static defaultMaxListeners: any;

                static destroy: any;

                static errorMonitor: any;

                static finished: any;

                static from: any;

                static getEventListeners: any;

                static init: any;

                static isDisturbed: any;

                static isErrored: any;

                static isReadable: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static pipeline: any;

                static promises: any;

                static setMaxListeners: any;

                static usingDomains: any;

                static wrap: any;

            }

            class Writable {
                constructor(options: any);

                cork(): void;

                destroy(err: any, cb: any): any;

                end(chunk: any, encoding: any, cb: any): any;

                pipe(): void;

                setDefaultEncoding(encoding: any): any;

                uncork(): void;

                write(chunk: any, encoding: any, cb: any): any;

                static Duplex: any;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static PassThrough: any;

                static Readable: any;

                static Stream: any;

                static Transform: any;

                static Writable: any;

                static WritableState: any;

                static addAbortSignal: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static compose: any;

                static defaultMaxListeners: any;

                static destroy: any;

                static errorMonitor: any;

                static finished: any;

                static getEventListeners: any;

                static init: any;

                static isDisturbed: any;

                static isErrored: any;

                static isReadable: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static pipeline: any;

                static promises: any;

                static setMaxListeners: any;

                static usingDomains: any;

            }

            namespace promises {
                // Too-deep object hierarchy from fs.ReadStream.Stream.Duplex.promises
                const finished: any;

                // Too-deep object hierarchy from fs.ReadStream.Stream.Duplex.promises
                const pipeline: any;

            }

        }

        namespace EventEmitter {
            class EventEmitterAsyncResource {
                constructor(...args: any[]);

                emit(...args: any[]): void;

                emitDestroy(...args: any[]): void;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static defaultMaxListeners: any;

                static errorMonitor: any;

                static getEventListeners: any;

                static init: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static setMaxListeners: any;

                static usingDomains: any;

            }

        }

        namespace EventEmitterAsyncResource {
            class EventEmitter {
                constructor(opts: any);

                addListener(type: any, listener: any): any;

                emit(type: any, args: any): any;

                eventNames(): any;

                getMaxListeners(): any;

                listenerCount(type: any): any;

                listeners(type: any): any;

                off(type: any, listener: any): any;

                on(type: any, listener: any): any;

                once(type: any, listener: any): any;

                prependListener(type: any, listener: any): any;

                prependOnceListener(type: any, listener: any): any;

                rawListeners(type: any): any;

                removeAllListeners(type: any, ...args: any[]): any;

                removeListener(type: any, listener: any): any;

                setMaxListeners(n: any): any;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static defaultMaxListeners: any;

                static errorMonitor: any;

                static getEventListeners: any;

                static init: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static setMaxListeners: any;

                static usingDomains: any;

            }

        }

        namespace PassThrough {
            class Duplex {
                constructor(options: any);

                cork(): void;

                end(chunk: any, encoding: any, cb: any): any;

                setDefaultEncoding(encoding: any): any;

                uncork(): void;

                write(chunk: any, encoding: any, cb: any): any;

                static Duplex: any;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static PassThrough: any;

                static Readable: any;

                static ReadableState: any;

                static Stream: any;

                static Transform: any;

                static Writable: any;

                static addAbortSignal: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static compose: any;

                static defaultMaxListeners: any;

                static destroy: any;

                static errorMonitor: any;

                static finished: any;

                static from: any;

                static getEventListeners: any;

                static init: any;

                static isDisturbed: any;

                static isErrored: any;

                static isReadable: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static pipeline: any;

                static promises: any;

                static setMaxListeners: any;

                static usingDomains: any;

                static wrap: any;

            }

            class EventEmitter {
                constructor(opts: any);

                addListener(type: any, listener: any): any;

                emit(type: any, args: any): any;

                eventNames(): any;

                getMaxListeners(): any;

                listenerCount(type: any): any;

                listeners(type: any): any;

                off(type: any, listener: any): any;

                on(type: any, listener: any): any;

                once(type: any, listener: any): any;

                prependListener(type: any, listener: any): any;

                prependOnceListener(type: any, listener: any): any;

                rawListeners(type: any): any;

                removeAllListeners(type: any, ...args: any[]): any;

                removeListener(type: any, listener: any): any;

                setMaxListeners(n: any): any;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static defaultMaxListeners: any;

                static errorMonitor: any;

                static getEventListeners: any;

                static init: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static setMaxListeners: any;

                static usingDomains: any;

            }

            class EventEmitterAsyncResource {
                constructor(...args: any[]);

                emit(...args: any[]): void;

                emitDestroy(...args: any[]): void;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static defaultMaxListeners: any;

                static errorMonitor: any;

                static getEventListeners: any;

                static init: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static setMaxListeners: any;

                static usingDomains: any;

            }

            class Readable {
                constructor(options: any);

                addListener(ev: any, fn: any): any;

                destroy(err: any, cb: any): any;

                filter(args: any): any;

                isPaused(): any;

                iterator(options: any): any;

                map(args: any): any;

                off(ev: any, fn: any): any;

                on(ev: any, fn: any): any;

                pause(): any;

                pipe(dest: any, pipeOpts: any): any;

                push(chunk: any, encoding: any): any;

                read(n: any): any;

                removeAllListeners(ev: any, ...args: any[]): any;

                removeListener(ev: any, fn: any): any;

                resume(): any;

                setEncoding(enc: any): any;

                unpipe(dest: any): any;

                unshift(chunk: any, encoding: any): any;

                wrap(stream: any): any;

                static Duplex: any;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static PassThrough: any;

                static Readable: any;

                static ReadableState: any;

                static Stream: any;

                static Transform: any;

                static Writable: any;

                static addAbortSignal: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static compose: any;

                static defaultMaxListeners: any;

                static destroy: any;

                static errorMonitor: any;

                static finished: any;

                static from: any;

                static getEventListeners: any;

                static init: any;

                static isDisturbed: any;

                static isErrored: any;

                static isReadable: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static pipeline: any;

                static promises: any;

                static setMaxListeners: any;

                static usingDomains: any;

                static wrap: any;

            }

            class ReadableState {
                constructor(options: any, stream: any, isDuplex: any);

            }

            class Transform {
                constructor(options: any);

                static Duplex: any;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static PassThrough: any;

                static Readable: any;

                static ReadableState: any;

                static Stream: any;

                static Transform: any;

                static Writable: any;

                static addAbortSignal: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static compose: any;

                static defaultMaxListeners: any;

                static destroy: any;

                static errorMonitor: any;

                static finished: any;

                static from: any;

                static getEventListeners: any;

                static init: any;

                static isDisturbed: any;

                static isErrored: any;

                static isReadable: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static pipeline: any;

                static promises: any;

                static setMaxListeners: any;

                static usingDomains: any;

                static wrap: any;

            }

            class Writable {
                constructor(options: any);

                cork(): void;

                destroy(err: any, cb: any): any;

                end(chunk: any, encoding: any, cb: any): any;

                pipe(): void;

                setDefaultEncoding(encoding: any): any;

                uncork(): void;

                write(chunk: any, encoding: any, cb: any): any;

                static Duplex: any;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static PassThrough: any;

                static Readable: any;

                static Stream: any;

                static Transform: any;

                static Writable: any;

                static WritableState: any;

                static addAbortSignal: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static compose: any;

                static defaultMaxListeners: any;

                static destroy: any;

                static errorMonitor: any;

                static finished: any;

                static getEventListeners: any;

                static init: any;

                static isDisturbed: any;

                static isErrored: any;

                static isReadable: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static pipeline: any;

                static promises: any;

                static setMaxListeners: any;

                static usingDomains: any;

            }

            namespace promises {
                // Too-deep object hierarchy from fs.ReadStream.Stream.PassThrough.promises
                const finished: any;

                // Too-deep object hierarchy from fs.ReadStream.Stream.PassThrough.promises
                const pipeline: any;

            }

        }

        namespace Readable {
            class Duplex {
                constructor(options: any);

                cork(): void;

                end(chunk: any, encoding: any, cb: any): any;

                setDefaultEncoding(encoding: any): any;

                uncork(): void;

                write(chunk: any, encoding: any, cb: any): any;

                static Duplex: any;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static PassThrough: any;

                static Readable: any;

                static ReadableState: any;

                static Stream: any;

                static Transform: any;

                static Writable: any;

                static addAbortSignal: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static compose: any;

                static defaultMaxListeners: any;

                static destroy: any;

                static errorMonitor: any;

                static finished: any;

                static from: any;

                static getEventListeners: any;

                static init: any;

                static isDisturbed: any;

                static isErrored: any;

                static isReadable: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static pipeline: any;

                static promises: any;

                static setMaxListeners: any;

                static usingDomains: any;

                static wrap: any;

            }

            class EventEmitter {
                constructor(opts: any);

                addListener(type: any, listener: any): any;

                emit(type: any, args: any): any;

                eventNames(): any;

                getMaxListeners(): any;

                listenerCount(type: any): any;

                listeners(type: any): any;

                off(type: any, listener: any): any;

                on(type: any, listener: any): any;

                once(type: any, listener: any): any;

                prependListener(type: any, listener: any): any;

                prependOnceListener(type: any, listener: any): any;

                rawListeners(type: any): any;

                removeAllListeners(type: any, ...args: any[]): any;

                removeListener(type: any, listener: any): any;

                setMaxListeners(n: any): any;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static defaultMaxListeners: any;

                static errorMonitor: any;

                static getEventListeners: any;

                static init: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static setMaxListeners: any;

                static usingDomains: any;

            }

            class EventEmitterAsyncResource {
                constructor(...args: any[]);

                emit(...args: any[]): void;

                emitDestroy(...args: any[]): void;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static defaultMaxListeners: any;

                static errorMonitor: any;

                static getEventListeners: any;

                static init: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static setMaxListeners: any;

                static usingDomains: any;

            }

            class PassThrough {
                constructor(options: any);

                static Duplex: any;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static PassThrough: any;

                static Readable: any;

                static ReadableState: any;

                static Stream: any;

                static Transform: any;

                static Writable: any;

                static addAbortSignal: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static compose: any;

                static defaultMaxListeners: any;

                static destroy: any;

                static errorMonitor: any;

                static finished: any;

                static from: any;

                static getEventListeners: any;

                static init: any;

                static isDisturbed: any;

                static isErrored: any;

                static isReadable: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static pipeline: any;

                static promises: any;

                static setMaxListeners: any;

                static usingDomains: any;

                static wrap: any;

            }

            class ReadableState {
                constructor(options: any, stream: any, isDuplex: any);

            }

            class Transform {
                constructor(options: any);

                static Duplex: any;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static PassThrough: any;

                static Readable: any;

                static ReadableState: any;

                static Stream: any;

                static Transform: any;

                static Writable: any;

                static addAbortSignal: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static compose: any;

                static defaultMaxListeners: any;

                static destroy: any;

                static errorMonitor: any;

                static finished: any;

                static from: any;

                static getEventListeners: any;

                static init: any;

                static isDisturbed: any;

                static isErrored: any;

                static isReadable: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static pipeline: any;

                static promises: any;

                static setMaxListeners: any;

                static usingDomains: any;

                static wrap: any;

            }

            class Writable {
                constructor(options: any);

                cork(): void;

                destroy(err: any, cb: any): any;

                end(chunk: any, encoding: any, cb: any): any;

                pipe(): void;

                setDefaultEncoding(encoding: any): any;

                uncork(): void;

                write(chunk: any, encoding: any, cb: any): any;

                static Duplex: any;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static PassThrough: any;

                static Readable: any;

                static Stream: any;

                static Transform: any;

                static Writable: any;

                static WritableState: any;

                static addAbortSignal: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static compose: any;

                static defaultMaxListeners: any;

                static destroy: any;

                static errorMonitor: any;

                static finished: any;

                static getEventListeners: any;

                static init: any;

                static isDisturbed: any;

                static isErrored: any;

                static isReadable: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static pipeline: any;

                static promises: any;

                static setMaxListeners: any;

                static usingDomains: any;

            }

            namespace promises {
                // Too-deep object hierarchy from fs.ReadStream.Stream.Readable.promises
                const finished: any;

                // Too-deep object hierarchy from fs.ReadStream.Stream.Readable.promises
                const pipeline: any;

            }

        }

        namespace Transform {
            class Duplex {
                constructor(options: any);

                cork(): void;

                end(chunk: any, encoding: any, cb: any): any;

                setDefaultEncoding(encoding: any): any;

                uncork(): void;

                write(chunk: any, encoding: any, cb: any): any;

                static Duplex: any;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static PassThrough: any;

                static Readable: any;

                static ReadableState: any;

                static Stream: any;

                static Transform: any;

                static Writable: any;

                static addAbortSignal: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static compose: any;

                static defaultMaxListeners: any;

                static destroy: any;

                static errorMonitor: any;

                static finished: any;

                static from: any;

                static getEventListeners: any;

                static init: any;

                static isDisturbed: any;

                static isErrored: any;

                static isReadable: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static pipeline: any;

                static promises: any;

                static setMaxListeners: any;

                static usingDomains: any;

                static wrap: any;

            }

            class EventEmitter {
                constructor(opts: any);

                addListener(type: any, listener: any): any;

                emit(type: any, args: any): any;

                eventNames(): any;

                getMaxListeners(): any;

                listenerCount(type: any): any;

                listeners(type: any): any;

                off(type: any, listener: any): any;

                on(type: any, listener: any): any;

                once(type: any, listener: any): any;

                prependListener(type: any, listener: any): any;

                prependOnceListener(type: any, listener: any): any;

                rawListeners(type: any): any;

                removeAllListeners(type: any, ...args: any[]): any;

                removeListener(type: any, listener: any): any;

                setMaxListeners(n: any): any;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static defaultMaxListeners: any;

                static errorMonitor: any;

                static getEventListeners: any;

                static init: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static setMaxListeners: any;

                static usingDomains: any;

            }

            class EventEmitterAsyncResource {
                constructor(...args: any[]);

                emit(...args: any[]): void;

                emitDestroy(...args: any[]): void;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static defaultMaxListeners: any;

                static errorMonitor: any;

                static getEventListeners: any;

                static init: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static setMaxListeners: any;

                static usingDomains: any;

            }

            class PassThrough {
                constructor(options: any);

                static Duplex: any;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static PassThrough: any;

                static Readable: any;

                static ReadableState: any;

                static Stream: any;

                static Transform: any;

                static Writable: any;

                static addAbortSignal: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static compose: any;

                static defaultMaxListeners: any;

                static destroy: any;

                static errorMonitor: any;

                static finished: any;

                static from: any;

                static getEventListeners: any;

                static init: any;

                static isDisturbed: any;

                static isErrored: any;

                static isReadable: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static pipeline: any;

                static promises: any;

                static setMaxListeners: any;

                static usingDomains: any;

                static wrap: any;

            }

            class Readable {
                constructor(options: any);

                addListener(ev: any, fn: any): any;

                destroy(err: any, cb: any): any;

                filter(args: any): any;

                isPaused(): any;

                iterator(options: any): any;

                map(args: any): any;

                off(ev: any, fn: any): any;

                on(ev: any, fn: any): any;

                pause(): any;

                pipe(dest: any, pipeOpts: any): any;

                push(chunk: any, encoding: any): any;

                read(n: any): any;

                removeAllListeners(ev: any, ...args: any[]): any;

                removeListener(ev: any, fn: any): any;

                resume(): any;

                setEncoding(enc: any): any;

                unpipe(dest: any): any;

                unshift(chunk: any, encoding: any): any;

                wrap(stream: any): any;

                static Duplex: any;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static PassThrough: any;

                static Readable: any;

                static ReadableState: any;

                static Stream: any;

                static Transform: any;

                static Writable: any;

                static addAbortSignal: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static compose: any;

                static defaultMaxListeners: any;

                static destroy: any;

                static errorMonitor: any;

                static finished: any;

                static from: any;

                static getEventListeners: any;

                static init: any;

                static isDisturbed: any;

                static isErrored: any;

                static isReadable: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static pipeline: any;

                static promises: any;

                static setMaxListeners: any;

                static usingDomains: any;

                static wrap: any;

            }

            class ReadableState {
                constructor(options: any, stream: any, isDuplex: any);

            }

            class Writable {
                constructor(options: any);

                cork(): void;

                destroy(err: any, cb: any): any;

                end(chunk: any, encoding: any, cb: any): any;

                pipe(): void;

                setDefaultEncoding(encoding: any): any;

                uncork(): void;

                write(chunk: any, encoding: any, cb: any): any;

                static Duplex: any;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static PassThrough: any;

                static Readable: any;

                static Stream: any;

                static Transform: any;

                static Writable: any;

                static WritableState: any;

                static addAbortSignal: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static compose: any;

                static defaultMaxListeners: any;

                static destroy: any;

                static errorMonitor: any;

                static finished: any;

                static getEventListeners: any;

                static init: any;

                static isDisturbed: any;

                static isErrored: any;

                static isReadable: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static pipeline: any;

                static promises: any;

                static setMaxListeners: any;

                static usingDomains: any;

            }

            namespace promises {
                // Too-deep object hierarchy from fs.ReadStream.Stream.Transform.promises
                const finished: any;

                // Too-deep object hierarchy from fs.ReadStream.Stream.Transform.promises
                const pipeline: any;

            }

        }

        namespace Writable {
            class Duplex {
                constructor(options: any);

                cork(): void;

                end(chunk: any, encoding: any, cb: any): any;

                setDefaultEncoding(encoding: any): any;

                uncork(): void;

                write(chunk: any, encoding: any, cb: any): any;

                static Duplex: any;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static PassThrough: any;

                static Readable: any;

                static ReadableState: any;

                static Stream: any;

                static Transform: any;

                static Writable: any;

                static addAbortSignal: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static compose: any;

                static defaultMaxListeners: any;

                static destroy: any;

                static errorMonitor: any;

                static finished: any;

                static from: any;

                static getEventListeners: any;

                static init: any;

                static isDisturbed: any;

                static isErrored: any;

                static isReadable: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static pipeline: any;

                static promises: any;

                static setMaxListeners: any;

                static usingDomains: any;

                static wrap: any;

            }

            class EventEmitter {
                constructor(opts: any);

                addListener(type: any, listener: any): any;

                emit(type: any, args: any): any;

                eventNames(): any;

                getMaxListeners(): any;

                listenerCount(type: any): any;

                listeners(type: any): any;

                off(type: any, listener: any): any;

                on(type: any, listener: any): any;

                once(type: any, listener: any): any;

                prependListener(type: any, listener: any): any;

                prependOnceListener(type: any, listener: any): any;

                rawListeners(type: any): any;

                removeAllListeners(type: any, ...args: any[]): any;

                removeListener(type: any, listener: any): any;

                setMaxListeners(n: any): any;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static defaultMaxListeners: any;

                static errorMonitor: any;

                static getEventListeners: any;

                static init: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static setMaxListeners: any;

                static usingDomains: any;

            }

            class EventEmitterAsyncResource {
                constructor(...args: any[]);

                emit(...args: any[]): void;

                emitDestroy(...args: any[]): void;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static defaultMaxListeners: any;

                static errorMonitor: any;

                static getEventListeners: any;

                static init: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static setMaxListeners: any;

                static usingDomains: any;

            }

            class PassThrough {
                constructor(options: any);

                static Duplex: any;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static PassThrough: any;

                static Readable: any;

                static ReadableState: any;

                static Stream: any;

                static Transform: any;

                static Writable: any;

                static addAbortSignal: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static compose: any;

                static defaultMaxListeners: any;

                static destroy: any;

                static errorMonitor: any;

                static finished: any;

                static from: any;

                static getEventListeners: any;

                static init: any;

                static isDisturbed: any;

                static isErrored: any;

                static isReadable: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static pipeline: any;

                static promises: any;

                static setMaxListeners: any;

                static usingDomains: any;

                static wrap: any;

            }

            class Readable {
                constructor(options: any);

                addListener(ev: any, fn: any): any;

                destroy(err: any, cb: any): any;

                filter(args: any): any;

                isPaused(): any;

                iterator(options: any): any;

                map(args: any): any;

                off(ev: any, fn: any): any;

                on(ev: any, fn: any): any;

                pause(): any;

                pipe(dest: any, pipeOpts: any): any;

                push(chunk: any, encoding: any): any;

                read(n: any): any;

                removeAllListeners(ev: any, ...args: any[]): any;

                removeListener(ev: any, fn: any): any;

                resume(): any;

                setEncoding(enc: any): any;

                unpipe(dest: any): any;

                unshift(chunk: any, encoding: any): any;

                wrap(stream: any): any;

                static Duplex: any;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static PassThrough: any;

                static Readable: any;

                static ReadableState: any;

                static Stream: any;

                static Transform: any;

                static Writable: any;

                static addAbortSignal: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static compose: any;

                static defaultMaxListeners: any;

                static destroy: any;

                static errorMonitor: any;

                static finished: any;

                static from: any;

                static getEventListeners: any;

                static init: any;

                static isDisturbed: any;

                static isErrored: any;

                static isReadable: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static pipeline: any;

                static promises: any;

                static setMaxListeners: any;

                static usingDomains: any;

                static wrap: any;

            }

            class Transform {
                constructor(options: any);

                static Duplex: any;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static PassThrough: any;

                static Readable: any;

                static ReadableState: any;

                static Stream: any;

                static Transform: any;

                static Writable: any;

                static addAbortSignal: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static compose: any;

                static defaultMaxListeners: any;

                static destroy: any;

                static errorMonitor: any;

                static finished: any;

                static from: any;

                static getEventListeners: any;

                static init: any;

                static isDisturbed: any;

                static isErrored: any;

                static isReadable: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static pipeline: any;

                static promises: any;

                static setMaxListeners: any;

                static usingDomains: any;

                static wrap: any;

            }

            class WritableState {
                constructor(options: any, stream: any, isDuplex: any);

                getBuffer(): any;

            }

            namespace promises {
                // Too-deep object hierarchy from fs.ReadStream.Stream.Writable.promises
                const finished: any;

                // Too-deep object hierarchy from fs.ReadStream.Stream.Writable.promises
                const pipeline: any;

            }

        }

        namespace promises {
            function finished(stream: any, opts: any): any;

            function pipeline(streams: any): any;

        }

    }

    namespace Transform {
        class Duplex {
            constructor(options: any);

            cork(): void;

            end(chunk: any, encoding: any, cb: any): any;

            setDefaultEncoding(encoding: any): any;

            uncork(): void;

            write(chunk: any, encoding: any, cb: any): any;

            static Duplex: any;

            static Transform: any;

            static addAbortSignal(signal: any, stream: any): any;

            static captureRejectionSymbol: any;

            static captureRejections: boolean;

            static compose(streams: any): any;

            static defaultMaxListeners: number;

            static destroy(stream: any, err: any): any;

            static errorMonitor: any;

            static finished(stream: any, options: any, callback: any, ...args: any[]): any;

            static from(body: any): any;

            static getEventListeners(emitterOrTarget: any, type: any): any;

            static init(opts: any): void;

            static isDisturbed(stream: any): any;

            static isErrored(stream: any): any;

            static isReadable(stream: any): any;

            static kMaxEventTargetListeners: any;

            static kMaxEventTargetListenersWarned: any;

            static listenerCount(emitter: any, type: any): any;

            static on(emitter: any, event: any, options: any): any;

            static once(emitter: any, name: any, options: any): any;

            static pipeline(streams: any): any;

            static setMaxListeners(n: any, eventTargets: any): void;

            static usingDomains: boolean;

            static wrap(src: any, options: any): any;

        }

        class EventEmitter {
            constructor(opts: any);

            addListener(type: any, listener: any): any;

            emit(type: any, args: any): any;

            eventNames(): any;

            getMaxListeners(): any;

            listenerCount(type: any): any;

            listeners(type: any): any;

            off(type: any, listener: any): any;

            on(type: any, listener: any): any;

            once(type: any, listener: any): any;

            prependListener(type: any, listener: any): any;

            prependOnceListener(type: any, listener: any): any;

            rawListeners(type: any): any;

            removeAllListeners(type: any, ...args: any[]): any;

            removeListener(type: any, listener: any): any;

            setMaxListeners(n: any): any;

            static EventEmitter: any;

            static captureRejectionSymbol: any;

            static captureRejections: boolean;

            static defaultMaxListeners: number;

            static errorMonitor: any;

            static getEventListeners(emitterOrTarget: any, type: any): any;

            static init(opts: any): void;

            static kMaxEventTargetListeners: any;

            static kMaxEventTargetListenersWarned: any;

            static listenerCount(emitter: any, type: any): any;

            static on(emitter: any, event: any, options: any): any;

            static once(emitter: any, name: any, options: any): any;

            static setMaxListeners(n: any, eventTargets: any): void;

            static usingDomains: boolean;

        }

        class EventEmitterAsyncResource {
            constructor(...args: any[]);

            emit(...args: any[]): void;

            emitDestroy(...args: any[]): void;

            static EventEmitterAsyncResource: any;

            static captureRejectionSymbol: any;

            static captureRejections: boolean;

            static defaultMaxListeners: number;

            static errorMonitor: any;

            static getEventListeners(emitterOrTarget: any, type: any): any;

            static init(opts: any): void;

            static kMaxEventTargetListeners: any;

            static kMaxEventTargetListenersWarned: any;

            static listenerCount(emitter: any, type: any): any;

            static on(emitter: any, event: any, options: any): any;

            static once(emitter: any, name: any, options: any): any;

            static setMaxListeners(n: any, eventTargets: any): void;

            static usingDomains: boolean;

        }

        class PassThrough {
            constructor(options: any);

            static PassThrough: any;

            static Transform: any;

            static addAbortSignal(signal: any, stream: any): any;

            static captureRejectionSymbol: any;

            static captureRejections: boolean;

            static compose(streams: any): any;

            static defaultMaxListeners: number;

            static destroy(stream: any, err: any): any;

            static errorMonitor: any;

            static finished(stream: any, options: any, callback: any, ...args: any[]): any;

            static from(body: any): any;

            static getEventListeners(emitterOrTarget: any, type: any): any;

            static init(opts: any): void;

            static isDisturbed(stream: any): any;

            static isErrored(stream: any): any;

            static isReadable(stream: any): any;

            static kMaxEventTargetListeners: any;

            static kMaxEventTargetListenersWarned: any;

            static listenerCount(emitter: any, type: any): any;

            static on(emitter: any, event: any, options: any): any;

            static once(emitter: any, name: any, options: any): any;

            static pipeline(streams: any): any;

            static setMaxListeners(n: any, eventTargets: any): void;

            static usingDomains: boolean;

            static wrap(src: any, options: any): any;

        }

        class Readable {
            constructor(options: any);

            addListener(ev: any, fn: any): any;

            destroy(err: any, cb: any): any;

            filter(args: any): any;

            isPaused(): any;

            iterator(options: any): any;

            map(args: any): any;

            off(ev: any, fn: any): any;

            on(ev: any, fn: any): any;

            pause(): any;

            pipe(dest: any, pipeOpts: any): any;

            push(chunk: any, encoding: any): any;

            read(n: any): any;

            removeAllListeners(ev: any, ...args: any[]): any;

            removeListener(ev: any, fn: any): any;

            resume(): any;

            setEncoding(enc: any): any;

            unpipe(dest: any): any;

            unshift(chunk: any, encoding: any): any;

            wrap(stream: any): any;

            static Readable: any;

            static Transform: any;

            static addAbortSignal(signal: any, stream: any): any;

            static captureRejectionSymbol: any;

            static captureRejections: boolean;

            static compose(streams: any): any;

            static defaultMaxListeners: number;

            static destroy(stream: any, err: any): any;

            static errorMonitor: any;

            static finished(stream: any, options: any, callback: any, ...args: any[]): any;

            static from(iterable: any, opts: any): any;

            static getEventListeners(emitterOrTarget: any, type: any): any;

            static init(opts: any): void;

            static isDisturbed(stream: any): any;

            static isErrored(stream: any): any;

            static isReadable(stream: any): any;

            static kMaxEventTargetListeners: any;

            static kMaxEventTargetListenersWarned: any;

            static listenerCount(emitter: any, type: any): any;

            static on(emitter: any, event: any, options: any): any;

            static once(emitter: any, name: any, options: any): any;

            static pipeline(streams: any): any;

            static setMaxListeners(n: any, eventTargets: any): void;

            static usingDomains: boolean;

            static wrap(src: any, options: any): any;

        }

        class ReadableState {
            constructor(options: any, stream: any, isDuplex: any);

        }

        class Stream {
            constructor(opts: any);

            pipe(dest: any, options: any): any;

            static Stream: any;

            static Transform: any;

            static addAbortSignal(signal: any, stream: any): any;

            static captureRejectionSymbol: any;

            static captureRejections: boolean;

            static compose(streams: any): any;

            static defaultMaxListeners: number;

            static destroy(stream: any, err: any): any;

            static errorMonitor: any;

            static finished(stream: any, options: any, callback: any, ...args: any[]): any;

            static getEventListeners(emitterOrTarget: any, type: any): any;

            static init(opts: any): void;

            static isDisturbed(stream: any): any;

            static isErrored(stream: any): any;

            static isReadable(stream: any): any;

            static kMaxEventTargetListeners: any;

            static kMaxEventTargetListenersWarned: any;

            static listenerCount(emitter: any, type: any): any;

            static on(emitter: any, event: any, options: any): any;

            static once(emitter: any, name: any, options: any): any;

            static pipeline(streams: any): any;

            static setMaxListeners(n: any, eventTargets: any): void;

            static usingDomains: boolean;

        }

        class Writable {
            constructor(options: any);

            cork(): void;

            destroy(err: any, cb: any): any;

            end(chunk: any, encoding: any, cb: any): any;

            pipe(): void;

            setDefaultEncoding(encoding: any): any;

            uncork(): void;

            write(chunk: any, encoding: any, cb: any): any;

            static Transform: any;

            static Writable: any;

            static addAbortSignal(signal: any, stream: any): any;

            static captureRejectionSymbol: any;

            static captureRejections: boolean;

            static compose(streams: any): any;

            static defaultMaxListeners: number;

            static destroy(stream: any, err: any): any;

            static errorMonitor: any;

            static finished(stream: any, options: any, callback: any, ...args: any[]): any;

            static getEventListeners(emitterOrTarget: any, type: any): any;

            static init(opts: any): void;

            static isDisturbed(stream: any): any;

            static isErrored(stream: any): any;

            static isReadable(stream: any): any;

            static kMaxEventTargetListeners: any;

            static kMaxEventTargetListenersWarned: any;

            static listenerCount(emitter: any, type: any): any;

            static on(emitter: any, event: any, options: any): any;

            static once(emitter: any, name: any, options: any): any;

            static pipeline(streams: any): any;

            static setMaxListeners(n: any, eventTargets: any): void;

            static usingDomains: boolean;

        }

        namespace Duplex {
            class EventEmitter {
                constructor(opts: any);

                addListener(type: any, listener: any): any;

                emit(type: any, args: any): any;

                eventNames(): any;

                getMaxListeners(): any;

                listenerCount(type: any): any;

                listeners(type: any): any;

                off(type: any, listener: any): any;

                on(type: any, listener: any): any;

                once(type: any, listener: any): any;

                prependListener(type: any, listener: any): any;

                prependOnceListener(type: any, listener: any): any;

                rawListeners(type: any): any;

                removeAllListeners(type: any, ...args: any[]): any;

                removeListener(type: any, listener: any): any;

                setMaxListeners(n: any): any;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static defaultMaxListeners: any;

                static errorMonitor: any;

                static getEventListeners: any;

                static init: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static setMaxListeners: any;

                static usingDomains: any;

            }

            class EventEmitterAsyncResource {
                constructor(...args: any[]);

                emit(...args: any[]): void;

                emitDestroy(...args: any[]): void;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static defaultMaxListeners: any;

                static errorMonitor: any;

                static getEventListeners: any;

                static init: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static setMaxListeners: any;

                static usingDomains: any;

            }

            class PassThrough {
                constructor(options: any);

                static Duplex: any;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static PassThrough: any;

                static Readable: any;

                static ReadableState: any;

                static Stream: any;

                static Transform: any;

                static Writable: any;

                static addAbortSignal: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static compose: any;

                static defaultMaxListeners: any;

                static destroy: any;

                static errorMonitor: any;

                static finished: any;

                static from: any;

                static getEventListeners: any;

                static init: any;

                static isDisturbed: any;

                static isErrored: any;

                static isReadable: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static pipeline: any;

                static promises: any;

                static setMaxListeners: any;

                static usingDomains: any;

                static wrap: any;

            }

            class Readable {
                constructor(options: any);

                addListener(ev: any, fn: any): any;

                destroy(err: any, cb: any): any;

                filter(args: any): any;

                isPaused(): any;

                iterator(options: any): any;

                map(args: any): any;

                off(ev: any, fn: any): any;

                on(ev: any, fn: any): any;

                pause(): any;

                pipe(dest: any, pipeOpts: any): any;

                push(chunk: any, encoding: any): any;

                read(n: any): any;

                removeAllListeners(ev: any, ...args: any[]): any;

                removeListener(ev: any, fn: any): any;

                resume(): any;

                setEncoding(enc: any): any;

                unpipe(dest: any): any;

                unshift(chunk: any, encoding: any): any;

                wrap(stream: any): any;

                static Duplex: any;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static PassThrough: any;

                static Readable: any;

                static ReadableState: any;

                static Stream: any;

                static Transform: any;

                static Writable: any;

                static addAbortSignal: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static compose: any;

                static defaultMaxListeners: any;

                static destroy: any;

                static errorMonitor: any;

                static finished: any;

                static from: any;

                static getEventListeners: any;

                static init: any;

                static isDisturbed: any;

                static isErrored: any;

                static isReadable: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static pipeline: any;

                static promises: any;

                static setMaxListeners: any;

                static usingDomains: any;

                static wrap: any;

            }

            class ReadableState {
                constructor(options: any, stream: any, isDuplex: any);

            }

            class Stream {
                constructor(opts: any);

                pipe(dest: any, options: any): any;

                static Duplex: any;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static PassThrough: any;

                static Readable: any;

                static Stream: any;

                static Transform: any;

                static Writable: any;

                static addAbortSignal: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static compose: any;

                static defaultMaxListeners: any;

                static destroy: any;

                static errorMonitor: any;

                static finished: any;

                static getEventListeners: any;

                static init: any;

                static isDisturbed: any;

                static isErrored: any;

                static isReadable: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static pipeline: any;

                static promises: any;

                static setMaxListeners: any;

                static usingDomains: any;

            }

            class Writable {
                constructor(options: any);

                cork(): void;

                destroy(err: any, cb: any): any;

                end(chunk: any, encoding: any, cb: any): any;

                pipe(): void;

                setDefaultEncoding(encoding: any): any;

                uncork(): void;

                write(chunk: any, encoding: any, cb: any): any;

                static Duplex: any;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static PassThrough: any;

                static Readable: any;

                static Stream: any;

                static Transform: any;

                static Writable: any;

                static WritableState: any;

                static addAbortSignal: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static compose: any;

                static defaultMaxListeners: any;

                static destroy: any;

                static errorMonitor: any;

                static finished: any;

                static getEventListeners: any;

                static init: any;

                static isDisturbed: any;

                static isErrored: any;

                static isReadable: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static pipeline: any;

                static promises: any;

                static setMaxListeners: any;

                static usingDomains: any;

            }

            namespace promises {
                // Too-deep object hierarchy from fs.ReadStream.Transform.Duplex.promises
                const finished: any;

                // Too-deep object hierarchy from fs.ReadStream.Transform.Duplex.promises
                const pipeline: any;

            }

        }

        namespace EventEmitter {
            class EventEmitterAsyncResource {
                constructor(...args: any[]);

                emit(...args: any[]): void;

                emitDestroy(...args: any[]): void;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static defaultMaxListeners: any;

                static errorMonitor: any;

                static getEventListeners: any;

                static init: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static setMaxListeners: any;

                static usingDomains: any;

            }

        }

        namespace EventEmitterAsyncResource {
            class EventEmitter {
                constructor(opts: any);

                addListener(type: any, listener: any): any;

                emit(type: any, args: any): any;

                eventNames(): any;

                getMaxListeners(): any;

                listenerCount(type: any): any;

                listeners(type: any): any;

                off(type: any, listener: any): any;

                on(type: any, listener: any): any;

                once(type: any, listener: any): any;

                prependListener(type: any, listener: any): any;

                prependOnceListener(type: any, listener: any): any;

                rawListeners(type: any): any;

                removeAllListeners(type: any, ...args: any[]): any;

                removeListener(type: any, listener: any): any;

                setMaxListeners(n: any): any;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static defaultMaxListeners: any;

                static errorMonitor: any;

                static getEventListeners: any;

                static init: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static setMaxListeners: any;

                static usingDomains: any;

            }

        }

        namespace PassThrough {
            class Duplex {
                constructor(options: any);

                cork(): void;

                end(chunk: any, encoding: any, cb: any): any;

                setDefaultEncoding(encoding: any): any;

                uncork(): void;

                write(chunk: any, encoding: any, cb: any): any;

                static Duplex: any;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static PassThrough: any;

                static Readable: any;

                static ReadableState: any;

                static Stream: any;

                static Transform: any;

                static Writable: any;

                static addAbortSignal: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static compose: any;

                static defaultMaxListeners: any;

                static destroy: any;

                static errorMonitor: any;

                static finished: any;

                static from: any;

                static getEventListeners: any;

                static init: any;

                static isDisturbed: any;

                static isErrored: any;

                static isReadable: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static pipeline: any;

                static promises: any;

                static setMaxListeners: any;

                static usingDomains: any;

                static wrap: any;

            }

            class EventEmitter {
                constructor(opts: any);

                addListener(type: any, listener: any): any;

                emit(type: any, args: any): any;

                eventNames(): any;

                getMaxListeners(): any;

                listenerCount(type: any): any;

                listeners(type: any): any;

                off(type: any, listener: any): any;

                on(type: any, listener: any): any;

                once(type: any, listener: any): any;

                prependListener(type: any, listener: any): any;

                prependOnceListener(type: any, listener: any): any;

                rawListeners(type: any): any;

                removeAllListeners(type: any, ...args: any[]): any;

                removeListener(type: any, listener: any): any;

                setMaxListeners(n: any): any;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static defaultMaxListeners: any;

                static errorMonitor: any;

                static getEventListeners: any;

                static init: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static setMaxListeners: any;

                static usingDomains: any;

            }

            class EventEmitterAsyncResource {
                constructor(...args: any[]);

                emit(...args: any[]): void;

                emitDestroy(...args: any[]): void;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static defaultMaxListeners: any;

                static errorMonitor: any;

                static getEventListeners: any;

                static init: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static setMaxListeners: any;

                static usingDomains: any;

            }

            class Readable {
                constructor(options: any);

                addListener(ev: any, fn: any): any;

                destroy(err: any, cb: any): any;

                filter(args: any): any;

                isPaused(): any;

                iterator(options: any): any;

                map(args: any): any;

                off(ev: any, fn: any): any;

                on(ev: any, fn: any): any;

                pause(): any;

                pipe(dest: any, pipeOpts: any): any;

                push(chunk: any, encoding: any): any;

                read(n: any): any;

                removeAllListeners(ev: any, ...args: any[]): any;

                removeListener(ev: any, fn: any): any;

                resume(): any;

                setEncoding(enc: any): any;

                unpipe(dest: any): any;

                unshift(chunk: any, encoding: any): any;

                wrap(stream: any): any;

                static Duplex: any;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static PassThrough: any;

                static Readable: any;

                static ReadableState: any;

                static Stream: any;

                static Transform: any;

                static Writable: any;

                static addAbortSignal: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static compose: any;

                static defaultMaxListeners: any;

                static destroy: any;

                static errorMonitor: any;

                static finished: any;

                static from: any;

                static getEventListeners: any;

                static init: any;

                static isDisturbed: any;

                static isErrored: any;

                static isReadable: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static pipeline: any;

                static promises: any;

                static setMaxListeners: any;

                static usingDomains: any;

                static wrap: any;

            }

            class ReadableState {
                constructor(options: any, stream: any, isDuplex: any);

            }

            class Stream {
                constructor(opts: any);

                pipe(dest: any, options: any): any;

                static Duplex: any;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static PassThrough: any;

                static Readable: any;

                static Stream: any;

                static Transform: any;

                static Writable: any;

                static addAbortSignal: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static compose: any;

                static defaultMaxListeners: any;

                static destroy: any;

                static errorMonitor: any;

                static finished: any;

                static getEventListeners: any;

                static init: any;

                static isDisturbed: any;

                static isErrored: any;

                static isReadable: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static pipeline: any;

                static promises: any;

                static setMaxListeners: any;

                static usingDomains: any;

            }

            class Writable {
                constructor(options: any);

                cork(): void;

                destroy(err: any, cb: any): any;

                end(chunk: any, encoding: any, cb: any): any;

                pipe(): void;

                setDefaultEncoding(encoding: any): any;

                uncork(): void;

                write(chunk: any, encoding: any, cb: any): any;

                static Duplex: any;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static PassThrough: any;

                static Readable: any;

                static Stream: any;

                static Transform: any;

                static Writable: any;

                static WritableState: any;

                static addAbortSignal: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static compose: any;

                static defaultMaxListeners: any;

                static destroy: any;

                static errorMonitor: any;

                static finished: any;

                static getEventListeners: any;

                static init: any;

                static isDisturbed: any;

                static isErrored: any;

                static isReadable: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static pipeline: any;

                static promises: any;

                static setMaxListeners: any;

                static usingDomains: any;

            }

            namespace promises {
                // Too-deep object hierarchy from fs.ReadStream.Transform.PassThrough.promises
                const finished: any;

                // Too-deep object hierarchy from fs.ReadStream.Transform.PassThrough.promises
                const pipeline: any;

            }

        }

        namespace Readable {
            class Duplex {
                constructor(options: any);

                cork(): void;

                end(chunk: any, encoding: any, cb: any): any;

                setDefaultEncoding(encoding: any): any;

                uncork(): void;

                write(chunk: any, encoding: any, cb: any): any;

                static Duplex: any;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static PassThrough: any;

                static Readable: any;

                static ReadableState: any;

                static Stream: any;

                static Transform: any;

                static Writable: any;

                static addAbortSignal: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static compose: any;

                static defaultMaxListeners: any;

                static destroy: any;

                static errorMonitor: any;

                static finished: any;

                static from: any;

                static getEventListeners: any;

                static init: any;

                static isDisturbed: any;

                static isErrored: any;

                static isReadable: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static pipeline: any;

                static promises: any;

                static setMaxListeners: any;

                static usingDomains: any;

                static wrap: any;

            }

            class EventEmitter {
                constructor(opts: any);

                addListener(type: any, listener: any): any;

                emit(type: any, args: any): any;

                eventNames(): any;

                getMaxListeners(): any;

                listenerCount(type: any): any;

                listeners(type: any): any;

                off(type: any, listener: any): any;

                on(type: any, listener: any): any;

                once(type: any, listener: any): any;

                prependListener(type: any, listener: any): any;

                prependOnceListener(type: any, listener: any): any;

                rawListeners(type: any): any;

                removeAllListeners(type: any, ...args: any[]): any;

                removeListener(type: any, listener: any): any;

                setMaxListeners(n: any): any;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static defaultMaxListeners: any;

                static errorMonitor: any;

                static getEventListeners: any;

                static init: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static setMaxListeners: any;

                static usingDomains: any;

            }

            class EventEmitterAsyncResource {
                constructor(...args: any[]);

                emit(...args: any[]): void;

                emitDestroy(...args: any[]): void;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static defaultMaxListeners: any;

                static errorMonitor: any;

                static getEventListeners: any;

                static init: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static setMaxListeners: any;

                static usingDomains: any;

            }

            class PassThrough {
                constructor(options: any);

                static Duplex: any;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static PassThrough: any;

                static Readable: any;

                static ReadableState: any;

                static Stream: any;

                static Transform: any;

                static Writable: any;

                static addAbortSignal: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static compose: any;

                static defaultMaxListeners: any;

                static destroy: any;

                static errorMonitor: any;

                static finished: any;

                static from: any;

                static getEventListeners: any;

                static init: any;

                static isDisturbed: any;

                static isErrored: any;

                static isReadable: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static pipeline: any;

                static promises: any;

                static setMaxListeners: any;

                static usingDomains: any;

                static wrap: any;

            }

            class ReadableState {
                constructor(options: any, stream: any, isDuplex: any);

            }

            class Stream {
                constructor(opts: any);

                pipe(dest: any, options: any): any;

                static Duplex: any;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static PassThrough: any;

                static Readable: any;

                static Stream: any;

                static Transform: any;

                static Writable: any;

                static addAbortSignal: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static compose: any;

                static defaultMaxListeners: any;

                static destroy: any;

                static errorMonitor: any;

                static finished: any;

                static getEventListeners: any;

                static init: any;

                static isDisturbed: any;

                static isErrored: any;

                static isReadable: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static pipeline: any;

                static promises: any;

                static setMaxListeners: any;

                static usingDomains: any;

            }

            class Writable {
                constructor(options: any);

                cork(): void;

                destroy(err: any, cb: any): any;

                end(chunk: any, encoding: any, cb: any): any;

                pipe(): void;

                setDefaultEncoding(encoding: any): any;

                uncork(): void;

                write(chunk: any, encoding: any, cb: any): any;

                static Duplex: any;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static PassThrough: any;

                static Readable: any;

                static Stream: any;

                static Transform: any;

                static Writable: any;

                static WritableState: any;

                static addAbortSignal: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static compose: any;

                static defaultMaxListeners: any;

                static destroy: any;

                static errorMonitor: any;

                static finished: any;

                static getEventListeners: any;

                static init: any;

                static isDisturbed: any;

                static isErrored: any;

                static isReadable: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static pipeline: any;

                static promises: any;

                static setMaxListeners: any;

                static usingDomains: any;

            }

            namespace promises {
                // Too-deep object hierarchy from fs.ReadStream.Transform.Readable.promises
                const finished: any;

                // Too-deep object hierarchy from fs.ReadStream.Transform.Readable.promises
                const pipeline: any;

            }

        }

        namespace Stream {
            class Duplex {
                constructor(options: any);

                cork(): void;

                end(chunk: any, encoding: any, cb: any): any;

                setDefaultEncoding(encoding: any): any;

                uncork(): void;

                write(chunk: any, encoding: any, cb: any): any;

                static Duplex: any;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static PassThrough: any;

                static Readable: any;

                static ReadableState: any;

                static Stream: any;

                static Transform: any;

                static Writable: any;

                static addAbortSignal: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static compose: any;

                static defaultMaxListeners: any;

                static destroy: any;

                static errorMonitor: any;

                static finished: any;

                static from: any;

                static getEventListeners: any;

                static init: any;

                static isDisturbed: any;

                static isErrored: any;

                static isReadable: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static pipeline: any;

                static promises: any;

                static setMaxListeners: any;

                static usingDomains: any;

                static wrap: any;

            }

            class EventEmitter {
                constructor(opts: any);

                addListener(type: any, listener: any): any;

                emit(type: any, args: any): any;

                eventNames(): any;

                getMaxListeners(): any;

                listenerCount(type: any): any;

                listeners(type: any): any;

                off(type: any, listener: any): any;

                on(type: any, listener: any): any;

                once(type: any, listener: any): any;

                prependListener(type: any, listener: any): any;

                prependOnceListener(type: any, listener: any): any;

                rawListeners(type: any): any;

                removeAllListeners(type: any, ...args: any[]): any;

                removeListener(type: any, listener: any): any;

                setMaxListeners(n: any): any;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static defaultMaxListeners: any;

                static errorMonitor: any;

                static getEventListeners: any;

                static init: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static setMaxListeners: any;

                static usingDomains: any;

            }

            class EventEmitterAsyncResource {
                constructor(...args: any[]);

                emit(...args: any[]): void;

                emitDestroy(...args: any[]): void;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static defaultMaxListeners: any;

                static errorMonitor: any;

                static getEventListeners: any;

                static init: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static setMaxListeners: any;

                static usingDomains: any;

            }

            class PassThrough {
                constructor(options: any);

                static Duplex: any;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static PassThrough: any;

                static Readable: any;

                static ReadableState: any;

                static Stream: any;

                static Transform: any;

                static Writable: any;

                static addAbortSignal: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static compose: any;

                static defaultMaxListeners: any;

                static destroy: any;

                static errorMonitor: any;

                static finished: any;

                static from: any;

                static getEventListeners: any;

                static init: any;

                static isDisturbed: any;

                static isErrored: any;

                static isReadable: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static pipeline: any;

                static promises: any;

                static setMaxListeners: any;

                static usingDomains: any;

                static wrap: any;

            }

            class Readable {
                constructor(options: any);

                addListener(ev: any, fn: any): any;

                destroy(err: any, cb: any): any;

                filter(args: any): any;

                isPaused(): any;

                iterator(options: any): any;

                map(args: any): any;

                off(ev: any, fn: any): any;

                on(ev: any, fn: any): any;

                pause(): any;

                pipe(dest: any, pipeOpts: any): any;

                push(chunk: any, encoding: any): any;

                read(n: any): any;

                removeAllListeners(ev: any, ...args: any[]): any;

                removeListener(ev: any, fn: any): any;

                resume(): any;

                setEncoding(enc: any): any;

                unpipe(dest: any): any;

                unshift(chunk: any, encoding: any): any;

                wrap(stream: any): any;

                static Duplex: any;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static PassThrough: any;

                static Readable: any;

                static ReadableState: any;

                static Stream: any;

                static Transform: any;

                static Writable: any;

                static addAbortSignal: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static compose: any;

                static defaultMaxListeners: any;

                static destroy: any;

                static errorMonitor: any;

                static finished: any;

                static from: any;

                static getEventListeners: any;

                static init: any;

                static isDisturbed: any;

                static isErrored: any;

                static isReadable: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static pipeline: any;

                static promises: any;

                static setMaxListeners: any;

                static usingDomains: any;

                static wrap: any;

            }

            class Writable {
                constructor(options: any);

                cork(): void;

                destroy(err: any, cb: any): any;

                end(chunk: any, encoding: any, cb: any): any;

                pipe(): void;

                setDefaultEncoding(encoding: any): any;

                uncork(): void;

                write(chunk: any, encoding: any, cb: any): any;

                static Duplex: any;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static PassThrough: any;

                static Readable: any;

                static Stream: any;

                static Transform: any;

                static Writable: any;

                static WritableState: any;

                static addAbortSignal: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static compose: any;

                static defaultMaxListeners: any;

                static destroy: any;

                static errorMonitor: any;

                static finished: any;

                static getEventListeners: any;

                static init: any;

                static isDisturbed: any;

                static isErrored: any;

                static isReadable: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static pipeline: any;

                static promises: any;

                static setMaxListeners: any;

                static usingDomains: any;

            }

            namespace promises {
                // Too-deep object hierarchy from fs.ReadStream.Transform.Stream.promises
                const finished: any;

                // Too-deep object hierarchy from fs.ReadStream.Transform.Stream.promises
                const pipeline: any;

            }

        }

        namespace Writable {
            class Duplex {
                constructor(options: any);

                cork(): void;

                end(chunk: any, encoding: any, cb: any): any;

                setDefaultEncoding(encoding: any): any;

                uncork(): void;

                write(chunk: any, encoding: any, cb: any): any;

                static Duplex: any;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static PassThrough: any;

                static Readable: any;

                static ReadableState: any;

                static Stream: any;

                static Transform: any;

                static Writable: any;

                static addAbortSignal: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static compose: any;

                static defaultMaxListeners: any;

                static destroy: any;

                static errorMonitor: any;

                static finished: any;

                static from: any;

                static getEventListeners: any;

                static init: any;

                static isDisturbed: any;

                static isErrored: any;

                static isReadable: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static pipeline: any;

                static promises: any;

                static setMaxListeners: any;

                static usingDomains: any;

                static wrap: any;

            }

            class EventEmitter {
                constructor(opts: any);

                addListener(type: any, listener: any): any;

                emit(type: any, args: any): any;

                eventNames(): any;

                getMaxListeners(): any;

                listenerCount(type: any): any;

                listeners(type: any): any;

                off(type: any, listener: any): any;

                on(type: any, listener: any): any;

                once(type: any, listener: any): any;

                prependListener(type: any, listener: any): any;

                prependOnceListener(type: any, listener: any): any;

                rawListeners(type: any): any;

                removeAllListeners(type: any, ...args: any[]): any;

                removeListener(type: any, listener: any): any;

                setMaxListeners(n: any): any;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static defaultMaxListeners: any;

                static errorMonitor: any;

                static getEventListeners: any;

                static init: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static setMaxListeners: any;

                static usingDomains: any;

            }

            class EventEmitterAsyncResource {
                constructor(...args: any[]);

                emit(...args: any[]): void;

                emitDestroy(...args: any[]): void;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static defaultMaxListeners: any;

                static errorMonitor: any;

                static getEventListeners: any;

                static init: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static setMaxListeners: any;

                static usingDomains: any;

            }

            class PassThrough {
                constructor(options: any);

                static Duplex: any;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static PassThrough: any;

                static Readable: any;

                static ReadableState: any;

                static Stream: any;

                static Transform: any;

                static Writable: any;

                static addAbortSignal: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static compose: any;

                static defaultMaxListeners: any;

                static destroy: any;

                static errorMonitor: any;

                static finished: any;

                static from: any;

                static getEventListeners: any;

                static init: any;

                static isDisturbed: any;

                static isErrored: any;

                static isReadable: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static pipeline: any;

                static promises: any;

                static setMaxListeners: any;

                static usingDomains: any;

                static wrap: any;

            }

            class Readable {
                constructor(options: any);

                addListener(ev: any, fn: any): any;

                destroy(err: any, cb: any): any;

                filter(args: any): any;

                isPaused(): any;

                iterator(options: any): any;

                map(args: any): any;

                off(ev: any, fn: any): any;

                on(ev: any, fn: any): any;

                pause(): any;

                pipe(dest: any, pipeOpts: any): any;

                push(chunk: any, encoding: any): any;

                read(n: any): any;

                removeAllListeners(ev: any, ...args: any[]): any;

                removeListener(ev: any, fn: any): any;

                resume(): any;

                setEncoding(enc: any): any;

                unpipe(dest: any): any;

                unshift(chunk: any, encoding: any): any;

                wrap(stream: any): any;

                static Duplex: any;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static PassThrough: any;

                static Readable: any;

                static ReadableState: any;

                static Stream: any;

                static Transform: any;

                static Writable: any;

                static addAbortSignal: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static compose: any;

                static defaultMaxListeners: any;

                static destroy: any;

                static errorMonitor: any;

                static finished: any;

                static from: any;

                static getEventListeners: any;

                static init: any;

                static isDisturbed: any;

                static isErrored: any;

                static isReadable: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static pipeline: any;

                static promises: any;

                static setMaxListeners: any;

                static usingDomains: any;

                static wrap: any;

            }

            class Stream {
                constructor(opts: any);

                pipe(dest: any, options: any): any;

                static Duplex: any;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static PassThrough: any;

                static Readable: any;

                static Stream: any;

                static Transform: any;

                static Writable: any;

                static addAbortSignal: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static compose: any;

                static defaultMaxListeners: any;

                static destroy: any;

                static errorMonitor: any;

                static finished: any;

                static getEventListeners: any;

                static init: any;

                static isDisturbed: any;

                static isErrored: any;

                static isReadable: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static pipeline: any;

                static promises: any;

                static setMaxListeners: any;

                static usingDomains: any;

            }

            class WritableState {
                constructor(options: any, stream: any, isDuplex: any);

                getBuffer(): any;

            }

            namespace promises {
                // Too-deep object hierarchy from fs.ReadStream.Transform.Writable.promises
                const finished: any;

                // Too-deep object hierarchy from fs.ReadStream.Transform.Writable.promises
                const pipeline: any;

            }

        }

        namespace promises {
            function finished(stream: any, opts: any): any;

            function pipeline(streams: any): any;

        }

    }

    namespace Writable {
        class Duplex {
            constructor(options: any);

            cork(): void;

            end(chunk: any, encoding: any, cb: any): any;

            setDefaultEncoding(encoding: any): any;

            uncork(): void;

            write(chunk: any, encoding: any, cb: any): any;

            static Duplex: any;

            static Writable: any;

            static addAbortSignal(signal: any, stream: any): any;

            static captureRejectionSymbol: any;

            static captureRejections: boolean;

            static compose(streams: any): any;

            static defaultMaxListeners: number;

            static destroy(stream: any, err: any): any;

            static errorMonitor: any;

            static finished(stream: any, options: any, callback: any, ...args: any[]): any;

            static from(body: any): any;

            static getEventListeners(emitterOrTarget: any, type: any): any;

            static init(opts: any): void;

            static isDisturbed(stream: any): any;

            static isErrored(stream: any): any;

            static isReadable(stream: any): any;

            static kMaxEventTargetListeners: any;

            static kMaxEventTargetListenersWarned: any;

            static listenerCount(emitter: any, type: any): any;

            static on(emitter: any, event: any, options: any): any;

            static once(emitter: any, name: any, options: any): any;

            static pipeline(streams: any): any;

            static setMaxListeners(n: any, eventTargets: any): void;

            static usingDomains: boolean;

            static wrap(src: any, options: any): any;

        }

        class EventEmitter {
            constructor(opts: any);

            addListener(type: any, listener: any): any;

            emit(type: any, args: any): any;

            eventNames(): any;

            getMaxListeners(): any;

            listenerCount(type: any): any;

            listeners(type: any): any;

            off(type: any, listener: any): any;

            on(type: any, listener: any): any;

            once(type: any, listener: any): any;

            prependListener(type: any, listener: any): any;

            prependOnceListener(type: any, listener: any): any;

            rawListeners(type: any): any;

            removeAllListeners(type: any, ...args: any[]): any;

            removeListener(type: any, listener: any): any;

            setMaxListeners(n: any): any;

            static EventEmitter: any;

            static captureRejectionSymbol: any;

            static captureRejections: boolean;

            static defaultMaxListeners: number;

            static errorMonitor: any;

            static getEventListeners(emitterOrTarget: any, type: any): any;

            static init(opts: any): void;

            static kMaxEventTargetListeners: any;

            static kMaxEventTargetListenersWarned: any;

            static listenerCount(emitter: any, type: any): any;

            static on(emitter: any, event: any, options: any): any;

            static once(emitter: any, name: any, options: any): any;

            static setMaxListeners(n: any, eventTargets: any): void;

            static usingDomains: boolean;

        }

        class EventEmitterAsyncResource {
            constructor(...args: any[]);

            emit(...args: any[]): void;

            emitDestroy(...args: any[]): void;

            static EventEmitterAsyncResource: any;

            static captureRejectionSymbol: any;

            static captureRejections: boolean;

            static defaultMaxListeners: number;

            static errorMonitor: any;

            static getEventListeners(emitterOrTarget: any, type: any): any;

            static init(opts: any): void;

            static kMaxEventTargetListeners: any;

            static kMaxEventTargetListenersWarned: any;

            static listenerCount(emitter: any, type: any): any;

            static on(emitter: any, event: any, options: any): any;

            static once(emitter: any, name: any, options: any): any;

            static setMaxListeners(n: any, eventTargets: any): void;

            static usingDomains: boolean;

        }

        class PassThrough {
            constructor(options: any);

            static PassThrough: any;

            static Writable: any;

            static addAbortSignal(signal: any, stream: any): any;

            static captureRejectionSymbol: any;

            static captureRejections: boolean;

            static compose(streams: any): any;

            static defaultMaxListeners: number;

            static destroy(stream: any, err: any): any;

            static errorMonitor: any;

            static finished(stream: any, options: any, callback: any, ...args: any[]): any;

            static from(body: any): any;

            static getEventListeners(emitterOrTarget: any, type: any): any;

            static init(opts: any): void;

            static isDisturbed(stream: any): any;

            static isErrored(stream: any): any;

            static isReadable(stream: any): any;

            static kMaxEventTargetListeners: any;

            static kMaxEventTargetListenersWarned: any;

            static listenerCount(emitter: any, type: any): any;

            static on(emitter: any, event: any, options: any): any;

            static once(emitter: any, name: any, options: any): any;

            static pipeline(streams: any): any;

            static setMaxListeners(n: any, eventTargets: any): void;

            static usingDomains: boolean;

            static wrap(src: any, options: any): any;

        }

        class Readable {
            constructor(options: any);

            addListener(ev: any, fn: any): any;

            destroy(err: any, cb: any): any;

            filter(args: any): any;

            isPaused(): any;

            iterator(options: any): any;

            map(args: any): any;

            off(ev: any, fn: any): any;

            on(ev: any, fn: any): any;

            pause(): any;

            pipe(dest: any, pipeOpts: any): any;

            push(chunk: any, encoding: any): any;

            read(n: any): any;

            removeAllListeners(ev: any, ...args: any[]): any;

            removeListener(ev: any, fn: any): any;

            resume(): any;

            setEncoding(enc: any): any;

            unpipe(dest: any): any;

            unshift(chunk: any, encoding: any): any;

            wrap(stream: any): any;

            static Readable: any;

            static Writable: any;

            static addAbortSignal(signal: any, stream: any): any;

            static captureRejectionSymbol: any;

            static captureRejections: boolean;

            static compose(streams: any): any;

            static defaultMaxListeners: number;

            static destroy(stream: any, err: any): any;

            static errorMonitor: any;

            static finished(stream: any, options: any, callback: any, ...args: any[]): any;

            static from(iterable: any, opts: any): any;

            static getEventListeners(emitterOrTarget: any, type: any): any;

            static init(opts: any): void;

            static isDisturbed(stream: any): any;

            static isErrored(stream: any): any;

            static isReadable(stream: any): any;

            static kMaxEventTargetListeners: any;

            static kMaxEventTargetListenersWarned: any;

            static listenerCount(emitter: any, type: any): any;

            static on(emitter: any, event: any, options: any): any;

            static once(emitter: any, name: any, options: any): any;

            static pipeline(streams: any): any;

            static setMaxListeners(n: any, eventTargets: any): void;

            static usingDomains: boolean;

            static wrap(src: any, options: any): any;

        }

        class Stream {
            constructor(opts: any);

            pipe(dest: any, options: any): any;

            static Stream: any;

            static Writable: any;

            static addAbortSignal(signal: any, stream: any): any;

            static captureRejectionSymbol: any;

            static captureRejections: boolean;

            static compose(streams: any): any;

            static defaultMaxListeners: number;

            static destroy(stream: any, err: any): any;

            static errorMonitor: any;

            static finished(stream: any, options: any, callback: any, ...args: any[]): any;

            static getEventListeners(emitterOrTarget: any, type: any): any;

            static init(opts: any): void;

            static isDisturbed(stream: any): any;

            static isErrored(stream: any): any;

            static isReadable(stream: any): any;

            static kMaxEventTargetListeners: any;

            static kMaxEventTargetListenersWarned: any;

            static listenerCount(emitter: any, type: any): any;

            static on(emitter: any, event: any, options: any): any;

            static once(emitter: any, name: any, options: any): any;

            static pipeline(streams: any): any;

            static setMaxListeners(n: any, eventTargets: any): void;

            static usingDomains: boolean;

        }

        class Transform {
            constructor(options: any);

            static Transform: any;

            static Writable: any;

            static addAbortSignal(signal: any, stream: any): any;

            static captureRejectionSymbol: any;

            static captureRejections: boolean;

            static compose(streams: any): any;

            static defaultMaxListeners: number;

            static destroy(stream: any, err: any): any;

            static errorMonitor: any;

            static finished(stream: any, options: any, callback: any, ...args: any[]): any;

            static from(body: any): any;

            static getEventListeners(emitterOrTarget: any, type: any): any;

            static init(opts: any): void;

            static isDisturbed(stream: any): any;

            static isErrored(stream: any): any;

            static isReadable(stream: any): any;

            static kMaxEventTargetListeners: any;

            static kMaxEventTargetListenersWarned: any;

            static listenerCount(emitter: any, type: any): any;

            static on(emitter: any, event: any, options: any): any;

            static once(emitter: any, name: any, options: any): any;

            static pipeline(streams: any): any;

            static setMaxListeners(n: any, eventTargets: any): void;

            static usingDomains: boolean;

            static wrap(src: any, options: any): any;

        }

        class WritableState {
            constructor(options: any, stream: any, isDuplex: any);

            getBuffer(): any;

        }

        namespace Duplex {
            class EventEmitter {
                constructor(opts: any);

                addListener(type: any, listener: any): any;

                emit(type: any, args: any): any;

                eventNames(): any;

                getMaxListeners(): any;

                listenerCount(type: any): any;

                listeners(type: any): any;

                off(type: any, listener: any): any;

                on(type: any, listener: any): any;

                once(type: any, listener: any): any;

                prependListener(type: any, listener: any): any;

                prependOnceListener(type: any, listener: any): any;

                rawListeners(type: any): any;

                removeAllListeners(type: any, ...args: any[]): any;

                removeListener(type: any, listener: any): any;

                setMaxListeners(n: any): any;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static defaultMaxListeners: any;

                static errorMonitor: any;

                static getEventListeners: any;

                static init: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static setMaxListeners: any;

                static usingDomains: any;

            }

            class EventEmitterAsyncResource {
                constructor(...args: any[]);

                emit(...args: any[]): void;

                emitDestroy(...args: any[]): void;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static defaultMaxListeners: any;

                static errorMonitor: any;

                static getEventListeners: any;

                static init: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static setMaxListeners: any;

                static usingDomains: any;

            }

            class PassThrough {
                constructor(options: any);

                static Duplex: any;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static PassThrough: any;

                static Readable: any;

                static ReadableState: any;

                static Stream: any;

                static Transform: any;

                static Writable: any;

                static addAbortSignal: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static compose: any;

                static defaultMaxListeners: any;

                static destroy: any;

                static errorMonitor: any;

                static finished: any;

                static from: any;

                static getEventListeners: any;

                static init: any;

                static isDisturbed: any;

                static isErrored: any;

                static isReadable: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static pipeline: any;

                static promises: any;

                static setMaxListeners: any;

                static usingDomains: any;

                static wrap: any;

            }

            class Readable {
                constructor(options: any);

                addListener(ev: any, fn: any): any;

                destroy(err: any, cb: any): any;

                filter(args: any): any;

                isPaused(): any;

                iterator(options: any): any;

                map(args: any): any;

                off(ev: any, fn: any): any;

                on(ev: any, fn: any): any;

                pause(): any;

                pipe(dest: any, pipeOpts: any): any;

                push(chunk: any, encoding: any): any;

                read(n: any): any;

                removeAllListeners(ev: any, ...args: any[]): any;

                removeListener(ev: any, fn: any): any;

                resume(): any;

                setEncoding(enc: any): any;

                unpipe(dest: any): any;

                unshift(chunk: any, encoding: any): any;

                wrap(stream: any): any;

                static Duplex: any;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static PassThrough: any;

                static Readable: any;

                static ReadableState: any;

                static Stream: any;

                static Transform: any;

                static Writable: any;

                static addAbortSignal: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static compose: any;

                static defaultMaxListeners: any;

                static destroy: any;

                static errorMonitor: any;

                static finished: any;

                static from: any;

                static getEventListeners: any;

                static init: any;

                static isDisturbed: any;

                static isErrored: any;

                static isReadable: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static pipeline: any;

                static promises: any;

                static setMaxListeners: any;

                static usingDomains: any;

                static wrap: any;

            }

            class ReadableState {
                constructor(options: any, stream: any, isDuplex: any);

            }

            class Stream {
                constructor(opts: any);

                pipe(dest: any, options: any): any;

                static Duplex: any;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static PassThrough: any;

                static Readable: any;

                static Stream: any;

                static Transform: any;

                static Writable: any;

                static addAbortSignal: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static compose: any;

                static defaultMaxListeners: any;

                static destroy: any;

                static errorMonitor: any;

                static finished: any;

                static getEventListeners: any;

                static init: any;

                static isDisturbed: any;

                static isErrored: any;

                static isReadable: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static pipeline: any;

                static promises: any;

                static setMaxListeners: any;

                static usingDomains: any;

            }

            class Transform {
                constructor(options: any);

                static Duplex: any;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static PassThrough: any;

                static Readable: any;

                static ReadableState: any;

                static Stream: any;

                static Transform: any;

                static Writable: any;

                static addAbortSignal: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static compose: any;

                static defaultMaxListeners: any;

                static destroy: any;

                static errorMonitor: any;

                static finished: any;

                static from: any;

                static getEventListeners: any;

                static init: any;

                static isDisturbed: any;

                static isErrored: any;

                static isReadable: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static pipeline: any;

                static promises: any;

                static setMaxListeners: any;

                static usingDomains: any;

                static wrap: any;

            }

            namespace promises {
                // Too-deep object hierarchy from fs.ReadStream.Writable.Duplex.promises
                const finished: any;

                // Too-deep object hierarchy from fs.ReadStream.Writable.Duplex.promises
                const pipeline: any;

            }

        }

        namespace EventEmitter {
            class EventEmitterAsyncResource {
                constructor(...args: any[]);

                emit(...args: any[]): void;

                emitDestroy(...args: any[]): void;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static defaultMaxListeners: any;

                static errorMonitor: any;

                static getEventListeners: any;

                static init: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static setMaxListeners: any;

                static usingDomains: any;

            }

        }

        namespace EventEmitterAsyncResource {
            class EventEmitter {
                constructor(opts: any);

                addListener(type: any, listener: any): any;

                emit(type: any, args: any): any;

                eventNames(): any;

                getMaxListeners(): any;

                listenerCount(type: any): any;

                listeners(type: any): any;

                off(type: any, listener: any): any;

                on(type: any, listener: any): any;

                once(type: any, listener: any): any;

                prependListener(type: any, listener: any): any;

                prependOnceListener(type: any, listener: any): any;

                rawListeners(type: any): any;

                removeAllListeners(type: any, ...args: any[]): any;

                removeListener(type: any, listener: any): any;

                setMaxListeners(n: any): any;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static defaultMaxListeners: any;

                static errorMonitor: any;

                static getEventListeners: any;

                static init: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static setMaxListeners: any;

                static usingDomains: any;

            }

        }

        namespace PassThrough {
            class Duplex {
                constructor(options: any);

                cork(): void;

                end(chunk: any, encoding: any, cb: any): any;

                setDefaultEncoding(encoding: any): any;

                uncork(): void;

                write(chunk: any, encoding: any, cb: any): any;

                static Duplex: any;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static PassThrough: any;

                static Readable: any;

                static ReadableState: any;

                static Stream: any;

                static Transform: any;

                static Writable: any;

                static addAbortSignal: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static compose: any;

                static defaultMaxListeners: any;

                static destroy: any;

                static errorMonitor: any;

                static finished: any;

                static from: any;

                static getEventListeners: any;

                static init: any;

                static isDisturbed: any;

                static isErrored: any;

                static isReadable: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static pipeline: any;

                static promises: any;

                static setMaxListeners: any;

                static usingDomains: any;

                static wrap: any;

            }

            class EventEmitter {
                constructor(opts: any);

                addListener(type: any, listener: any): any;

                emit(type: any, args: any): any;

                eventNames(): any;

                getMaxListeners(): any;

                listenerCount(type: any): any;

                listeners(type: any): any;

                off(type: any, listener: any): any;

                on(type: any, listener: any): any;

                once(type: any, listener: any): any;

                prependListener(type: any, listener: any): any;

                prependOnceListener(type: any, listener: any): any;

                rawListeners(type: any): any;

                removeAllListeners(type: any, ...args: any[]): any;

                removeListener(type: any, listener: any): any;

                setMaxListeners(n: any): any;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static defaultMaxListeners: any;

                static errorMonitor: any;

                static getEventListeners: any;

                static init: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static setMaxListeners: any;

                static usingDomains: any;

            }

            class EventEmitterAsyncResource {
                constructor(...args: any[]);

                emit(...args: any[]): void;

                emitDestroy(...args: any[]): void;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static defaultMaxListeners: any;

                static errorMonitor: any;

                static getEventListeners: any;

                static init: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static setMaxListeners: any;

                static usingDomains: any;

            }

            class Readable {
                constructor(options: any);

                addListener(ev: any, fn: any): any;

                destroy(err: any, cb: any): any;

                filter(args: any): any;

                isPaused(): any;

                iterator(options: any): any;

                map(args: any): any;

                off(ev: any, fn: any): any;

                on(ev: any, fn: any): any;

                pause(): any;

                pipe(dest: any, pipeOpts: any): any;

                push(chunk: any, encoding: any): any;

                read(n: any): any;

                removeAllListeners(ev: any, ...args: any[]): any;

                removeListener(ev: any, fn: any): any;

                resume(): any;

                setEncoding(enc: any): any;

                unpipe(dest: any): any;

                unshift(chunk: any, encoding: any): any;

                wrap(stream: any): any;

                static Duplex: any;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static PassThrough: any;

                static Readable: any;

                static ReadableState: any;

                static Stream: any;

                static Transform: any;

                static Writable: any;

                static addAbortSignal: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static compose: any;

                static defaultMaxListeners: any;

                static destroy: any;

                static errorMonitor: any;

                static finished: any;

                static from: any;

                static getEventListeners: any;

                static init: any;

                static isDisturbed: any;

                static isErrored: any;

                static isReadable: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static pipeline: any;

                static promises: any;

                static setMaxListeners: any;

                static usingDomains: any;

                static wrap: any;

            }

            class ReadableState {
                constructor(options: any, stream: any, isDuplex: any);

            }

            class Stream {
                constructor(opts: any);

                pipe(dest: any, options: any): any;

                static Duplex: any;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static PassThrough: any;

                static Readable: any;

                static Stream: any;

                static Transform: any;

                static Writable: any;

                static addAbortSignal: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static compose: any;

                static defaultMaxListeners: any;

                static destroy: any;

                static errorMonitor: any;

                static finished: any;

                static getEventListeners: any;

                static init: any;

                static isDisturbed: any;

                static isErrored: any;

                static isReadable: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static pipeline: any;

                static promises: any;

                static setMaxListeners: any;

                static usingDomains: any;

            }

            class Transform {
                constructor(options: any);

                static Duplex: any;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static PassThrough: any;

                static Readable: any;

                static ReadableState: any;

                static Stream: any;

                static Transform: any;

                static Writable: any;

                static addAbortSignal: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static compose: any;

                static defaultMaxListeners: any;

                static destroy: any;

                static errorMonitor: any;

                static finished: any;

                static from: any;

                static getEventListeners: any;

                static init: any;

                static isDisturbed: any;

                static isErrored: any;

                static isReadable: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static pipeline: any;

                static promises: any;

                static setMaxListeners: any;

                static usingDomains: any;

                static wrap: any;

            }

            namespace promises {
                // Too-deep object hierarchy from fs.ReadStream.Writable.PassThrough.promises
                const finished: any;

                // Too-deep object hierarchy from fs.ReadStream.Writable.PassThrough.promises
                const pipeline: any;

            }

        }

        namespace Readable {
            class Duplex {
                constructor(options: any);

                cork(): void;

                end(chunk: any, encoding: any, cb: any): any;

                setDefaultEncoding(encoding: any): any;

                uncork(): void;

                write(chunk: any, encoding: any, cb: any): any;

                static Duplex: any;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static PassThrough: any;

                static Readable: any;

                static ReadableState: any;

                static Stream: any;

                static Transform: any;

                static Writable: any;

                static addAbortSignal: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static compose: any;

                static defaultMaxListeners: any;

                static destroy: any;

                static errorMonitor: any;

                static finished: any;

                static from: any;

                static getEventListeners: any;

                static init: any;

                static isDisturbed: any;

                static isErrored: any;

                static isReadable: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static pipeline: any;

                static promises: any;

                static setMaxListeners: any;

                static usingDomains: any;

                static wrap: any;

            }

            class EventEmitter {
                constructor(opts: any);

                addListener(type: any, listener: any): any;

                emit(type: any, args: any): any;

                eventNames(): any;

                getMaxListeners(): any;

                listenerCount(type: any): any;

                listeners(type: any): any;

                off(type: any, listener: any): any;

                on(type: any, listener: any): any;

                once(type: any, listener: any): any;

                prependListener(type: any, listener: any): any;

                prependOnceListener(type: any, listener: any): any;

                rawListeners(type: any): any;

                removeAllListeners(type: any, ...args: any[]): any;

                removeListener(type: any, listener: any): any;

                setMaxListeners(n: any): any;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static defaultMaxListeners: any;

                static errorMonitor: any;

                static getEventListeners: any;

                static init: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static setMaxListeners: any;

                static usingDomains: any;

            }

            class EventEmitterAsyncResource {
                constructor(...args: any[]);

                emit(...args: any[]): void;

                emitDestroy(...args: any[]): void;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static defaultMaxListeners: any;

                static errorMonitor: any;

                static getEventListeners: any;

                static init: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static setMaxListeners: any;

                static usingDomains: any;

            }

            class PassThrough {
                constructor(options: any);

                static Duplex: any;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static PassThrough: any;

                static Readable: any;

                static ReadableState: any;

                static Stream: any;

                static Transform: any;

                static Writable: any;

                static addAbortSignal: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static compose: any;

                static defaultMaxListeners: any;

                static destroy: any;

                static errorMonitor: any;

                static finished: any;

                static from: any;

                static getEventListeners: any;

                static init: any;

                static isDisturbed: any;

                static isErrored: any;

                static isReadable: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static pipeline: any;

                static promises: any;

                static setMaxListeners: any;

                static usingDomains: any;

                static wrap: any;

            }

            class ReadableState {
                constructor(options: any, stream: any, isDuplex: any);

            }

            class Stream {
                constructor(opts: any);

                pipe(dest: any, options: any): any;

                static Duplex: any;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static PassThrough: any;

                static Readable: any;

                static Stream: any;

                static Transform: any;

                static Writable: any;

                static addAbortSignal: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static compose: any;

                static defaultMaxListeners: any;

                static destroy: any;

                static errorMonitor: any;

                static finished: any;

                static getEventListeners: any;

                static init: any;

                static isDisturbed: any;

                static isErrored: any;

                static isReadable: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static pipeline: any;

                static promises: any;

                static setMaxListeners: any;

                static usingDomains: any;

            }

            class Transform {
                constructor(options: any);

                static Duplex: any;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static PassThrough: any;

                static Readable: any;

                static ReadableState: any;

                static Stream: any;

                static Transform: any;

                static Writable: any;

                static addAbortSignal: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static compose: any;

                static defaultMaxListeners: any;

                static destroy: any;

                static errorMonitor: any;

                static finished: any;

                static from: any;

                static getEventListeners: any;

                static init: any;

                static isDisturbed: any;

                static isErrored: any;

                static isReadable: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static pipeline: any;

                static promises: any;

                static setMaxListeners: any;

                static usingDomains: any;

                static wrap: any;

            }

            namespace promises {
                // Too-deep object hierarchy from fs.ReadStream.Writable.Readable.promises
                const finished: any;

                // Too-deep object hierarchy from fs.ReadStream.Writable.Readable.promises
                const pipeline: any;

            }

        }

        namespace Stream {
            class Duplex {
                constructor(options: any);

                cork(): void;

                end(chunk: any, encoding: any, cb: any): any;

                setDefaultEncoding(encoding: any): any;

                uncork(): void;

                write(chunk: any, encoding: any, cb: any): any;

                static Duplex: any;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static PassThrough: any;

                static Readable: any;

                static ReadableState: any;

                static Stream: any;

                static Transform: any;

                static Writable: any;

                static addAbortSignal: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static compose: any;

                static defaultMaxListeners: any;

                static destroy: any;

                static errorMonitor: any;

                static finished: any;

                static from: any;

                static getEventListeners: any;

                static init: any;

                static isDisturbed: any;

                static isErrored: any;

                static isReadable: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static pipeline: any;

                static promises: any;

                static setMaxListeners: any;

                static usingDomains: any;

                static wrap: any;

            }

            class EventEmitter {
                constructor(opts: any);

                addListener(type: any, listener: any): any;

                emit(type: any, args: any): any;

                eventNames(): any;

                getMaxListeners(): any;

                listenerCount(type: any): any;

                listeners(type: any): any;

                off(type: any, listener: any): any;

                on(type: any, listener: any): any;

                once(type: any, listener: any): any;

                prependListener(type: any, listener: any): any;

                prependOnceListener(type: any, listener: any): any;

                rawListeners(type: any): any;

                removeAllListeners(type: any, ...args: any[]): any;

                removeListener(type: any, listener: any): any;

                setMaxListeners(n: any): any;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static defaultMaxListeners: any;

                static errorMonitor: any;

                static getEventListeners: any;

                static init: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static setMaxListeners: any;

                static usingDomains: any;

            }

            class EventEmitterAsyncResource {
                constructor(...args: any[]);

                emit(...args: any[]): void;

                emitDestroy(...args: any[]): void;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static defaultMaxListeners: any;

                static errorMonitor: any;

                static getEventListeners: any;

                static init: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static setMaxListeners: any;

                static usingDomains: any;

            }

            class PassThrough {
                constructor(options: any);

                static Duplex: any;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static PassThrough: any;

                static Readable: any;

                static ReadableState: any;

                static Stream: any;

                static Transform: any;

                static Writable: any;

                static addAbortSignal: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static compose: any;

                static defaultMaxListeners: any;

                static destroy: any;

                static errorMonitor: any;

                static finished: any;

                static from: any;

                static getEventListeners: any;

                static init: any;

                static isDisturbed: any;

                static isErrored: any;

                static isReadable: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static pipeline: any;

                static promises: any;

                static setMaxListeners: any;

                static usingDomains: any;

                static wrap: any;

            }

            class Readable {
                constructor(options: any);

                addListener(ev: any, fn: any): any;

                destroy(err: any, cb: any): any;

                filter(args: any): any;

                isPaused(): any;

                iterator(options: any): any;

                map(args: any): any;

                off(ev: any, fn: any): any;

                on(ev: any, fn: any): any;

                pause(): any;

                pipe(dest: any, pipeOpts: any): any;

                push(chunk: any, encoding: any): any;

                read(n: any): any;

                removeAllListeners(ev: any, ...args: any[]): any;

                removeListener(ev: any, fn: any): any;

                resume(): any;

                setEncoding(enc: any): any;

                unpipe(dest: any): any;

                unshift(chunk: any, encoding: any): any;

                wrap(stream: any): any;

                static Duplex: any;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static PassThrough: any;

                static Readable: any;

                static ReadableState: any;

                static Stream: any;

                static Transform: any;

                static Writable: any;

                static addAbortSignal: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static compose: any;

                static defaultMaxListeners: any;

                static destroy: any;

                static errorMonitor: any;

                static finished: any;

                static from: any;

                static getEventListeners: any;

                static init: any;

                static isDisturbed: any;

                static isErrored: any;

                static isReadable: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static pipeline: any;

                static promises: any;

                static setMaxListeners: any;

                static usingDomains: any;

                static wrap: any;

            }

            class Transform {
                constructor(options: any);

                static Duplex: any;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static PassThrough: any;

                static Readable: any;

                static ReadableState: any;

                static Stream: any;

                static Transform: any;

                static Writable: any;

                static addAbortSignal: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static compose: any;

                static defaultMaxListeners: any;

                static destroy: any;

                static errorMonitor: any;

                static finished: any;

                static from: any;

                static getEventListeners: any;

                static init: any;

                static isDisturbed: any;

                static isErrored: any;

                static isReadable: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static pipeline: any;

                static promises: any;

                static setMaxListeners: any;

                static usingDomains: any;

                static wrap: any;

            }

            namespace promises {
                // Too-deep object hierarchy from fs.ReadStream.Writable.Stream.promises
                const finished: any;

                // Too-deep object hierarchy from fs.ReadStream.Writable.Stream.promises
                const pipeline: any;

            }

        }

        namespace Transform {
            class Duplex {
                constructor(options: any);

                cork(): void;

                end(chunk: any, encoding: any, cb: any): any;

                setDefaultEncoding(encoding: any): any;

                uncork(): void;

                write(chunk: any, encoding: any, cb: any): any;

                static Duplex: any;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static PassThrough: any;

                static Readable: any;

                static ReadableState: any;

                static Stream: any;

                static Transform: any;

                static Writable: any;

                static addAbortSignal: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static compose: any;

                static defaultMaxListeners: any;

                static destroy: any;

                static errorMonitor: any;

                static finished: any;

                static from: any;

                static getEventListeners: any;

                static init: any;

                static isDisturbed: any;

                static isErrored: any;

                static isReadable: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static pipeline: any;

                static promises: any;

                static setMaxListeners: any;

                static usingDomains: any;

                static wrap: any;

            }

            class EventEmitter {
                constructor(opts: any);

                addListener(type: any, listener: any): any;

                emit(type: any, args: any): any;

                eventNames(): any;

                getMaxListeners(): any;

                listenerCount(type: any): any;

                listeners(type: any): any;

                off(type: any, listener: any): any;

                on(type: any, listener: any): any;

                once(type: any, listener: any): any;

                prependListener(type: any, listener: any): any;

                prependOnceListener(type: any, listener: any): any;

                rawListeners(type: any): any;

                removeAllListeners(type: any, ...args: any[]): any;

                removeListener(type: any, listener: any): any;

                setMaxListeners(n: any): any;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static defaultMaxListeners: any;

                static errorMonitor: any;

                static getEventListeners: any;

                static init: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static setMaxListeners: any;

                static usingDomains: any;

            }

            class EventEmitterAsyncResource {
                constructor(...args: any[]);

                emit(...args: any[]): void;

                emitDestroy(...args: any[]): void;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static defaultMaxListeners: any;

                static errorMonitor: any;

                static getEventListeners: any;

                static init: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static setMaxListeners: any;

                static usingDomains: any;

            }

            class PassThrough {
                constructor(options: any);

                static Duplex: any;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static PassThrough: any;

                static Readable: any;

                static ReadableState: any;

                static Stream: any;

                static Transform: any;

                static Writable: any;

                static addAbortSignal: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static compose: any;

                static defaultMaxListeners: any;

                static destroy: any;

                static errorMonitor: any;

                static finished: any;

                static from: any;

                static getEventListeners: any;

                static init: any;

                static isDisturbed: any;

                static isErrored: any;

                static isReadable: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static pipeline: any;

                static promises: any;

                static setMaxListeners: any;

                static usingDomains: any;

                static wrap: any;

            }

            class Readable {
                constructor(options: any);

                addListener(ev: any, fn: any): any;

                destroy(err: any, cb: any): any;

                filter(args: any): any;

                isPaused(): any;

                iterator(options: any): any;

                map(args: any): any;

                off(ev: any, fn: any): any;

                on(ev: any, fn: any): any;

                pause(): any;

                pipe(dest: any, pipeOpts: any): any;

                push(chunk: any, encoding: any): any;

                read(n: any): any;

                removeAllListeners(ev: any, ...args: any[]): any;

                removeListener(ev: any, fn: any): any;

                resume(): any;

                setEncoding(enc: any): any;

                unpipe(dest: any): any;

                unshift(chunk: any, encoding: any): any;

                wrap(stream: any): any;

                static Duplex: any;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static PassThrough: any;

                static Readable: any;

                static ReadableState: any;

                static Stream: any;

                static Transform: any;

                static Writable: any;

                static addAbortSignal: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static compose: any;

                static defaultMaxListeners: any;

                static destroy: any;

                static errorMonitor: any;

                static finished: any;

                static from: any;

                static getEventListeners: any;

                static init: any;

                static isDisturbed: any;

                static isErrored: any;

                static isReadable: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static pipeline: any;

                static promises: any;

                static setMaxListeners: any;

                static usingDomains: any;

                static wrap: any;

            }

            class ReadableState {
                constructor(options: any, stream: any, isDuplex: any);

            }

            class Stream {
                constructor(opts: any);

                pipe(dest: any, options: any): any;

                static Duplex: any;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static PassThrough: any;

                static Readable: any;

                static Stream: any;

                static Transform: any;

                static Writable: any;

                static addAbortSignal: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static compose: any;

                static defaultMaxListeners: any;

                static destroy: any;

                static errorMonitor: any;

                static finished: any;

                static getEventListeners: any;

                static init: any;

                static isDisturbed: any;

                static isErrored: any;

                static isReadable: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static pipeline: any;

                static promises: any;

                static setMaxListeners: any;

                static usingDomains: any;

            }

            namespace promises {
                // Too-deep object hierarchy from fs.ReadStream.Writable.Transform.promises
                const finished: any;

                // Too-deep object hierarchy from fs.ReadStream.Writable.Transform.promises
                const pipeline: any;

            }

        }

        namespace promises {
            function finished(stream: any, opts: any): any;

            function pipeline(streams: any): any;

        }

    }

    namespace promises {
        function finished(stream: any, opts: any): any;

        function pipeline(streams: any): any;

    }

}

export namespace WriteStream {
    class Duplex {
        constructor(options: any);

        cork(): void;

        end(chunk: any, encoding: any, cb: any): any;

        setDefaultEncoding(encoding: any): any;

        uncork(): void;

        write(chunk: any, encoding: any, cb: any): any;

        static Duplex: any;

        static addAbortSignal(signal: any, stream: any): any;

        static captureRejectionSymbol: any;

        static captureRejections: boolean;

        static compose(streams: any): any;

        static defaultMaxListeners: number;

        static destroy(stream: any, err: any): any;

        static errorMonitor: any;

        static finished(stream: any, options: any, callback: any, ...args: any[]): any;

        static from(body: any): any;

        static getEventListeners(emitterOrTarget: any, type: any): any;

        static init(opts: any): void;

        static isDisturbed(stream: any): any;

        static isErrored(stream: any): any;

        static isReadable(stream: any): any;

        static kMaxEventTargetListeners: any;

        static kMaxEventTargetListenersWarned: any;

        static listenerCount(emitter: any, type: any): any;

        static on(emitter: any, event: any, options: any): any;

        static once(emitter: any, name: any, options: any): any;

        static pipeline(streams: any): any;

        static setMaxListeners(n: any, eventTargets: any): void;

        static usingDomains: boolean;

        static wrap(src: any, options: any): any;

    }

    class EventEmitter {
        constructor(opts: any);

        addListener(type: any, listener: any): any;

        emit(type: any, args: any): any;

        eventNames(): any;

        getMaxListeners(): any;

        listenerCount(type: any): any;

        listeners(type: any): any;

        off(type: any, listener: any): any;

        on(type: any, listener: any): any;

        once(type: any, listener: any): any;

        prependListener(type: any, listener: any): any;

        prependOnceListener(type: any, listener: any): any;

        rawListeners(type: any): any;

        removeAllListeners(type: any, ...args: any[]): any;

        removeListener(type: any, listener: any): any;

        setMaxListeners(n: any): any;

        static EventEmitter: any;

        static captureRejectionSymbol: any;

        static captureRejections: boolean;

        static defaultMaxListeners: number;

        static errorMonitor: any;

        static getEventListeners(emitterOrTarget: any, type: any): any;

        static init(opts: any): void;

        static kMaxEventTargetListeners: any;

        static kMaxEventTargetListenersWarned: any;

        static listenerCount(emitter: any, type: any): any;

        static on(emitter: any, event: any, options: any): any;

        static once(emitter: any, name: any, options: any): any;

        static setMaxListeners(n: any, eventTargets: any): void;

        static usingDomains: boolean;

    }

    class EventEmitterAsyncResource {
        constructor(...args: any[]);

        emit(...args: any[]): void;

        emitDestroy(...args: any[]): void;

        static EventEmitterAsyncResource: any;

        static captureRejectionSymbol: any;

        static captureRejections: boolean;

        static defaultMaxListeners: number;

        static errorMonitor: any;

        static getEventListeners(emitterOrTarget: any, type: any): any;

        static init(opts: any): void;

        static kMaxEventTargetListeners: any;

        static kMaxEventTargetListenersWarned: any;

        static listenerCount(emitter: any, type: any): any;

        static on(emitter: any, event: any, options: any): any;

        static once(emitter: any, name: any, options: any): any;

        static setMaxListeners(n: any, eventTargets: any): void;

        static usingDomains: boolean;

    }

    class PassThrough {
        constructor(options: any);

        static PassThrough: any;

        static addAbortSignal(signal: any, stream: any): any;

        static captureRejectionSymbol: any;

        static captureRejections: boolean;

        static compose(streams: any): any;

        static defaultMaxListeners: number;

        static destroy(stream: any, err: any): any;

        static errorMonitor: any;

        static finished(stream: any, options: any, callback: any, ...args: any[]): any;

        static from(body: any): any;

        static getEventListeners(emitterOrTarget: any, type: any): any;

        static init(opts: any): void;

        static isDisturbed(stream: any): any;

        static isErrored(stream: any): any;

        static isReadable(stream: any): any;

        static kMaxEventTargetListeners: any;

        static kMaxEventTargetListenersWarned: any;

        static listenerCount(emitter: any, type: any): any;

        static on(emitter: any, event: any, options: any): any;

        static once(emitter: any, name: any, options: any): any;

        static pipeline(streams: any): any;

        static setMaxListeners(n: any, eventTargets: any): void;

        static usingDomains: boolean;

        static wrap(src: any, options: any): any;

    }

    class Readable {
        constructor(options: any);

        addListener(ev: any, fn: any): any;

        destroy(err: any, cb: any): any;

        filter(args: any): any;

        isPaused(): any;

        iterator(options: any): any;

        map(args: any): any;

        off(ev: any, fn: any): any;

        on(ev: any, fn: any): any;

        pause(): any;

        pipe(dest: any, pipeOpts: any): any;

        push(chunk: any, encoding: any): any;

        read(n: any): any;

        removeAllListeners(ev: any, ...args: any[]): any;

        removeListener(ev: any, fn: any): any;

        resume(): any;

        setEncoding(enc: any): any;

        unpipe(dest: any): any;

        unshift(chunk: any, encoding: any): any;

        wrap(stream: any): any;

        static Readable: any;

        static addAbortSignal(signal: any, stream: any): any;

        static captureRejectionSymbol: any;

        static captureRejections: boolean;

        static compose(streams: any): any;

        static defaultMaxListeners: number;

        static destroy(stream: any, err: any): any;

        static errorMonitor: any;

        static finished(stream: any, options: any, callback: any, ...args: any[]): any;

        static from(iterable: any, opts: any): any;

        static getEventListeners(emitterOrTarget: any, type: any): any;

        static init(opts: any): void;

        static isDisturbed(stream: any): any;

        static isErrored(stream: any): any;

        static isReadable(stream: any): any;

        static kMaxEventTargetListeners: any;

        static kMaxEventTargetListenersWarned: any;

        static listenerCount(emitter: any, type: any): any;

        static on(emitter: any, event: any, options: any): any;

        static once(emitter: any, name: any, options: any): any;

        static pipeline(streams: any): any;

        static setMaxListeners(n: any, eventTargets: any): void;

        static usingDomains: boolean;

        static wrap(src: any, options: any): any;

    }

    class Stream {
        constructor(opts: any);

        pipe(dest: any, options: any): any;

        static Stream: any;

        static addAbortSignal(signal: any, stream: any): any;

        static captureRejectionSymbol: any;

        static captureRejections: boolean;

        static compose(streams: any): any;

        static defaultMaxListeners: number;

        static destroy(stream: any, err: any): any;

        static errorMonitor: any;

        static finished(stream: any, options: any, callback: any, ...args: any[]): any;

        static getEventListeners(emitterOrTarget: any, type: any): any;

        static init(opts: any): void;

        static isDisturbed(stream: any): any;

        static isErrored(stream: any): any;

        static isReadable(stream: any): any;

        static kMaxEventTargetListeners: any;

        static kMaxEventTargetListenersWarned: any;

        static listenerCount(emitter: any, type: any): any;

        static on(emitter: any, event: any, options: any): any;

        static once(emitter: any, name: any, options: any): any;

        static pipeline(streams: any): any;

        static setMaxListeners(n: any, eventTargets: any): void;

        static usingDomains: boolean;

    }

    class Transform {
        constructor(options: any);

        static Transform: any;

        static addAbortSignal(signal: any, stream: any): any;

        static captureRejectionSymbol: any;

        static captureRejections: boolean;

        static compose(streams: any): any;

        static defaultMaxListeners: number;

        static destroy(stream: any, err: any): any;

        static errorMonitor: any;

        static finished(stream: any, options: any, callback: any, ...args: any[]): any;

        static from(body: any): any;

        static getEventListeners(emitterOrTarget: any, type: any): any;

        static init(opts: any): void;

        static isDisturbed(stream: any): any;

        static isErrored(stream: any): any;

        static isReadable(stream: any): any;

        static kMaxEventTargetListeners: any;

        static kMaxEventTargetListenersWarned: any;

        static listenerCount(emitter: any, type: any): any;

        static on(emitter: any, event: any, options: any): any;

        static once(emitter: any, name: any, options: any): any;

        static pipeline(streams: any): any;

        static setMaxListeners(n: any, eventTargets: any): void;

        static usingDomains: boolean;

        static wrap(src: any, options: any): any;

    }

    class Writable {
        constructor(options: any);

        cork(): void;

        destroy(err: any, cb: any): any;

        end(chunk: any, encoding: any, cb: any): any;

        pipe(): void;

        setDefaultEncoding(encoding: any): any;

        uncork(): void;

        write(chunk: any, encoding: any, cb: any): any;

        static Writable: any;

        static addAbortSignal(signal: any, stream: any): any;

        static captureRejectionSymbol: any;

        static captureRejections: boolean;

        static compose(streams: any): any;

        static defaultMaxListeners: number;

        static destroy(stream: any, err: any): any;

        static errorMonitor: any;

        static finished(stream: any, options: any, callback: any, ...args: any[]): any;

        static getEventListeners(emitterOrTarget: any, type: any): any;

        static init(opts: any): void;

        static isDisturbed(stream: any): any;

        static isErrored(stream: any): any;

        static isReadable(stream: any): any;

        static kMaxEventTargetListeners: any;

        static kMaxEventTargetListenersWarned: any;

        static listenerCount(emitter: any, type: any): any;

        static on(emitter: any, event: any, options: any): any;

        static once(emitter: any, name: any, options: any): any;

        static pipeline(streams: any): any;

        static setMaxListeners(n: any, eventTargets: any): void;

        static usingDomains: boolean;

    }

    class WritableState {
        constructor(options: any, stream: any, isDuplex: any);

        getBuffer(): any;

    }

    namespace Duplex {
        class EventEmitter {
            constructor(opts: any);

            addListener(type: any, listener: any): any;

            emit(type: any, args: any): any;

            eventNames(): any;

            getMaxListeners(): any;

            listenerCount(type: any): any;

            listeners(type: any): any;

            off(type: any, listener: any): any;

            on(type: any, listener: any): any;

            once(type: any, listener: any): any;

            prependListener(type: any, listener: any): any;

            prependOnceListener(type: any, listener: any): any;

            rawListeners(type: any): any;

            removeAllListeners(type: any, ...args: any[]): any;

            removeListener(type: any, listener: any): any;

            setMaxListeners(n: any): any;

            static EventEmitter: any;

            static captureRejectionSymbol: any;

            static captureRejections: boolean;

            static defaultMaxListeners: number;

            static errorMonitor: any;

            static getEventListeners(emitterOrTarget: any, type: any): any;

            static init(opts: any): void;

            static kMaxEventTargetListeners: any;

            static kMaxEventTargetListenersWarned: any;

            static listenerCount(emitter: any, type: any): any;

            static on(emitter: any, event: any, options: any): any;

            static once(emitter: any, name: any, options: any): any;

            static setMaxListeners(n: any, eventTargets: any): void;

            static usingDomains: boolean;

        }

        class EventEmitterAsyncResource {
            constructor(...args: any[]);

            emit(...args: any[]): void;

            emitDestroy(...args: any[]): void;

            static EventEmitterAsyncResource: any;

            static captureRejectionSymbol: any;

            static captureRejections: boolean;

            static defaultMaxListeners: number;

            static errorMonitor: any;

            static getEventListeners(emitterOrTarget: any, type: any): any;

            static init(opts: any): void;

            static kMaxEventTargetListeners: any;

            static kMaxEventTargetListenersWarned: any;

            static listenerCount(emitter: any, type: any): any;

            static on(emitter: any, event: any, options: any): any;

            static once(emitter: any, name: any, options: any): any;

            static setMaxListeners(n: any, eventTargets: any): void;

            static usingDomains: boolean;

        }

        class PassThrough {
            constructor(options: any);

            static Duplex: any;

            static PassThrough: any;

            static addAbortSignal(signal: any, stream: any): any;

            static captureRejectionSymbol: any;

            static captureRejections: boolean;

            static compose(streams: any): any;

            static defaultMaxListeners: number;

            static destroy(stream: any, err: any): any;

            static errorMonitor: any;

            static finished(stream: any, options: any, callback: any, ...args: any[]): any;

            static from(body: any): any;

            static getEventListeners(emitterOrTarget: any, type: any): any;

            static init(opts: any): void;

            static isDisturbed(stream: any): any;

            static isErrored(stream: any): any;

            static isReadable(stream: any): any;

            static kMaxEventTargetListeners: any;

            static kMaxEventTargetListenersWarned: any;

            static listenerCount(emitter: any, type: any): any;

            static on(emitter: any, event: any, options: any): any;

            static once(emitter: any, name: any, options: any): any;

            static pipeline(streams: any): any;

            static setMaxListeners(n: any, eventTargets: any): void;

            static usingDomains: boolean;

            static wrap(src: any, options: any): any;

        }

        class Readable {
            constructor(options: any);

            addListener(ev: any, fn: any): any;

            destroy(err: any, cb: any): any;

            filter(args: any): any;

            isPaused(): any;

            iterator(options: any): any;

            map(args: any): any;

            off(ev: any, fn: any): any;

            on(ev: any, fn: any): any;

            pause(): any;

            pipe(dest: any, pipeOpts: any): any;

            push(chunk: any, encoding: any): any;

            read(n: any): any;

            removeAllListeners(ev: any, ...args: any[]): any;

            removeListener(ev: any, fn: any): any;

            resume(): any;

            setEncoding(enc: any): any;

            unpipe(dest: any): any;

            unshift(chunk: any, encoding: any): any;

            wrap(stream: any): any;

            static Duplex: any;

            static Readable: any;

            static addAbortSignal(signal: any, stream: any): any;

            static captureRejectionSymbol: any;

            static captureRejections: boolean;

            static compose(streams: any): any;

            static defaultMaxListeners: number;

            static destroy(stream: any, err: any): any;

            static errorMonitor: any;

            static finished(stream: any, options: any, callback: any, ...args: any[]): any;

            static from(iterable: any, opts: any): any;

            static getEventListeners(emitterOrTarget: any, type: any): any;

            static init(opts: any): void;

            static isDisturbed(stream: any): any;

            static isErrored(stream: any): any;

            static isReadable(stream: any): any;

            static kMaxEventTargetListeners: any;

            static kMaxEventTargetListenersWarned: any;

            static listenerCount(emitter: any, type: any): any;

            static on(emitter: any, event: any, options: any): any;

            static once(emitter: any, name: any, options: any): any;

            static pipeline(streams: any): any;

            static setMaxListeners(n: any, eventTargets: any): void;

            static usingDomains: boolean;

            static wrap(src: any, options: any): any;

        }

        class ReadableState {
            constructor(options: any, stream: any, isDuplex: any);

        }

        class Stream {
            constructor(opts: any);

            pipe(dest: any, options: any): any;

            static Duplex: any;

            static Stream: any;

            static addAbortSignal(signal: any, stream: any): any;

            static captureRejectionSymbol: any;

            static captureRejections: boolean;

            static compose(streams: any): any;

            static defaultMaxListeners: number;

            static destroy(stream: any, err: any): any;

            static errorMonitor: any;

            static finished(stream: any, options: any, callback: any, ...args: any[]): any;

            static getEventListeners(emitterOrTarget: any, type: any): any;

            static init(opts: any): void;

            static isDisturbed(stream: any): any;

            static isErrored(stream: any): any;

            static isReadable(stream: any): any;

            static kMaxEventTargetListeners: any;

            static kMaxEventTargetListenersWarned: any;

            static listenerCount(emitter: any, type: any): any;

            static on(emitter: any, event: any, options: any): any;

            static once(emitter: any, name: any, options: any): any;

            static pipeline(streams: any): any;

            static setMaxListeners(n: any, eventTargets: any): void;

            static usingDomains: boolean;

        }

        class Transform {
            constructor(options: any);

            static Duplex: any;

            static Transform: any;

            static addAbortSignal(signal: any, stream: any): any;

            static captureRejectionSymbol: any;

            static captureRejections: boolean;

            static compose(streams: any): any;

            static defaultMaxListeners: number;

            static destroy(stream: any, err: any): any;

            static errorMonitor: any;

            static finished(stream: any, options: any, callback: any, ...args: any[]): any;

            static from(body: any): any;

            static getEventListeners(emitterOrTarget: any, type: any): any;

            static init(opts: any): void;

            static isDisturbed(stream: any): any;

            static isErrored(stream: any): any;

            static isReadable(stream: any): any;

            static kMaxEventTargetListeners: any;

            static kMaxEventTargetListenersWarned: any;

            static listenerCount(emitter: any, type: any): any;

            static on(emitter: any, event: any, options: any): any;

            static once(emitter: any, name: any, options: any): any;

            static pipeline(streams: any): any;

            static setMaxListeners(n: any, eventTargets: any): void;

            static usingDomains: boolean;

            static wrap(src: any, options: any): any;

        }

        class Writable {
            constructor(options: any);

            cork(): void;

            destroy(err: any, cb: any): any;

            end(chunk: any, encoding: any, cb: any): any;

            pipe(): void;

            setDefaultEncoding(encoding: any): any;

            uncork(): void;

            write(chunk: any, encoding: any, cb: any): any;

            static Duplex: any;

            static Writable: any;

            static addAbortSignal(signal: any, stream: any): any;

            static captureRejectionSymbol: any;

            static captureRejections: boolean;

            static compose(streams: any): any;

            static defaultMaxListeners: number;

            static destroy(stream: any, err: any): any;

            static errorMonitor: any;

            static finished(stream: any, options: any, callback: any, ...args: any[]): any;

            static getEventListeners(emitterOrTarget: any, type: any): any;

            static init(opts: any): void;

            static isDisturbed(stream: any): any;

            static isErrored(stream: any): any;

            static isReadable(stream: any): any;

            static kMaxEventTargetListeners: any;

            static kMaxEventTargetListenersWarned: any;

            static listenerCount(emitter: any, type: any): any;

            static on(emitter: any, event: any, options: any): any;

            static once(emitter: any, name: any, options: any): any;

            static pipeline(streams: any): any;

            static setMaxListeners(n: any, eventTargets: any): void;

            static usingDomains: boolean;

        }

        namespace EventEmitter {
            class EventEmitterAsyncResource {
                constructor(...args: any[]);

                emit(...args: any[]): void;

                emitDestroy(...args: any[]): void;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static defaultMaxListeners: any;

                static errorMonitor: any;

                static getEventListeners: any;

                static init: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static setMaxListeners: any;

                static usingDomains: any;

            }

        }

        namespace EventEmitterAsyncResource {
            class EventEmitter {
                constructor(opts: any);

                addListener(type: any, listener: any): any;

                emit(type: any, args: any): any;

                eventNames(): any;

                getMaxListeners(): any;

                listenerCount(type: any): any;

                listeners(type: any): any;

                off(type: any, listener: any): any;

                on(type: any, listener: any): any;

                once(type: any, listener: any): any;

                prependListener(type: any, listener: any): any;

                prependOnceListener(type: any, listener: any): any;

                rawListeners(type: any): any;

                removeAllListeners(type: any, ...args: any[]): any;

                removeListener(type: any, listener: any): any;

                setMaxListeners(n: any): any;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static defaultMaxListeners: any;

                static errorMonitor: any;

                static getEventListeners: any;

                static init: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static setMaxListeners: any;

                static usingDomains: any;

            }

        }

        namespace PassThrough {
            class EventEmitter {
                constructor(opts: any);

                addListener(type: any, listener: any): any;

                emit(type: any, args: any): any;

                eventNames(): any;

                getMaxListeners(): any;

                listenerCount(type: any): any;

                listeners(type: any): any;

                off(type: any, listener: any): any;

                on(type: any, listener: any): any;

                once(type: any, listener: any): any;

                prependListener(type: any, listener: any): any;

                prependOnceListener(type: any, listener: any): any;

                rawListeners(type: any): any;

                removeAllListeners(type: any, ...args: any[]): any;

                removeListener(type: any, listener: any): any;

                setMaxListeners(n: any): any;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static defaultMaxListeners: any;

                static errorMonitor: any;

                static getEventListeners: any;

                static init: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static setMaxListeners: any;

                static usingDomains: any;

            }

            class EventEmitterAsyncResource {
                constructor(...args: any[]);

                emit(...args: any[]): void;

                emitDestroy(...args: any[]): void;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static defaultMaxListeners: any;

                static errorMonitor: any;

                static getEventListeners: any;

                static init: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static setMaxListeners: any;

                static usingDomains: any;

            }

            class Readable {
                constructor(options: any);

                addListener(ev: any, fn: any): any;

                destroy(err: any, cb: any): any;

                filter(args: any): any;

                isPaused(): any;

                iterator(options: any): any;

                map(args: any): any;

                off(ev: any, fn: any): any;

                on(ev: any, fn: any): any;

                pause(): any;

                pipe(dest: any, pipeOpts: any): any;

                push(chunk: any, encoding: any): any;

                read(n: any): any;

                removeAllListeners(ev: any, ...args: any[]): any;

                removeListener(ev: any, fn: any): any;

                resume(): any;

                setEncoding(enc: any): any;

                unpipe(dest: any): any;

                unshift(chunk: any, encoding: any): any;

                wrap(stream: any): any;

                static Duplex: any;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static PassThrough: any;

                static Readable: any;

                static ReadableState: any;

                static Stream: any;

                static Transform: any;

                static Writable: any;

                static addAbortSignal: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static compose: any;

                static defaultMaxListeners: any;

                static destroy: any;

                static errorMonitor: any;

                static finished: any;

                static from: any;

                static getEventListeners: any;

                static init: any;

                static isDisturbed: any;

                static isErrored: any;

                static isReadable: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static pipeline: any;

                static promises: any;

                static setMaxListeners: any;

                static usingDomains: any;

                static wrap: any;

            }

            class ReadableState {
                constructor(options: any, stream: any, isDuplex: any);

            }

            class Stream {
                constructor(opts: any);

                pipe(dest: any, options: any): any;

                static Duplex: any;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static PassThrough: any;

                static Readable: any;

                static Stream: any;

                static Transform: any;

                static Writable: any;

                static addAbortSignal: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static compose: any;

                static defaultMaxListeners: any;

                static destroy: any;

                static errorMonitor: any;

                static finished: any;

                static getEventListeners: any;

                static init: any;

                static isDisturbed: any;

                static isErrored: any;

                static isReadable: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static pipeline: any;

                static promises: any;

                static setMaxListeners: any;

                static usingDomains: any;

            }

            class Transform {
                constructor(options: any);

                static Duplex: any;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static PassThrough: any;

                static Readable: any;

                static ReadableState: any;

                static Stream: any;

                static Transform: any;

                static Writable: any;

                static addAbortSignal: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static compose: any;

                static defaultMaxListeners: any;

                static destroy: any;

                static errorMonitor: any;

                static finished: any;

                static from: any;

                static getEventListeners: any;

                static init: any;

                static isDisturbed: any;

                static isErrored: any;

                static isReadable: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static pipeline: any;

                static promises: any;

                static setMaxListeners: any;

                static usingDomains: any;

                static wrap: any;

            }

            class Writable {
                constructor(options: any);

                cork(): void;

                destroy(err: any, cb: any): any;

                end(chunk: any, encoding: any, cb: any): any;

                pipe(): void;

                setDefaultEncoding(encoding: any): any;

                uncork(): void;

                write(chunk: any, encoding: any, cb: any): any;

                static Duplex: any;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static PassThrough: any;

                static Readable: any;

                static Stream: any;

                static Transform: any;

                static Writable: any;

                static WritableState: any;

                static addAbortSignal: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static compose: any;

                static defaultMaxListeners: any;

                static destroy: any;

                static errorMonitor: any;

                static finished: any;

                static getEventListeners: any;

                static init: any;

                static isDisturbed: any;

                static isErrored: any;

                static isReadable: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static pipeline: any;

                static promises: any;

                static setMaxListeners: any;

                static usingDomains: any;

            }

            namespace promises {
                // Too-deep object hierarchy from fs.WriteStream.Duplex.PassThrough.promises
                const finished: any;

                // Too-deep object hierarchy from fs.WriteStream.Duplex.PassThrough.promises
                const pipeline: any;

            }

        }

        namespace Readable {
            class EventEmitter {
                constructor(opts: any);

                addListener(type: any, listener: any): any;

                emit(type: any, args: any): any;

                eventNames(): any;

                getMaxListeners(): any;

                listenerCount(type: any): any;

                listeners(type: any): any;

                off(type: any, listener: any): any;

                on(type: any, listener: any): any;

                once(type: any, listener: any): any;

                prependListener(type: any, listener: any): any;

                prependOnceListener(type: any, listener: any): any;

                rawListeners(type: any): any;

                removeAllListeners(type: any, ...args: any[]): any;

                removeListener(type: any, listener: any): any;

                setMaxListeners(n: any): any;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static defaultMaxListeners: any;

                static errorMonitor: any;

                static getEventListeners: any;

                static init: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static setMaxListeners: any;

                static usingDomains: any;

            }

            class EventEmitterAsyncResource {
                constructor(...args: any[]);

                emit(...args: any[]): void;

                emitDestroy(...args: any[]): void;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static defaultMaxListeners: any;

                static errorMonitor: any;

                static getEventListeners: any;

                static init: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static setMaxListeners: any;

                static usingDomains: any;

            }

            class PassThrough {
                constructor(options: any);

                static Duplex: any;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static PassThrough: any;

                static Readable: any;

                static ReadableState: any;

                static Stream: any;

                static Transform: any;

                static Writable: any;

                static addAbortSignal: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static compose: any;

                static defaultMaxListeners: any;

                static destroy: any;

                static errorMonitor: any;

                static finished: any;

                static from: any;

                static getEventListeners: any;

                static init: any;

                static isDisturbed: any;

                static isErrored: any;

                static isReadable: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static pipeline: any;

                static promises: any;

                static setMaxListeners: any;

                static usingDomains: any;

                static wrap: any;

            }

            class ReadableState {
                constructor(options: any, stream: any, isDuplex: any);

            }

            class Stream {
                constructor(opts: any);

                pipe(dest: any, options: any): any;

                static Duplex: any;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static PassThrough: any;

                static Readable: any;

                static Stream: any;

                static Transform: any;

                static Writable: any;

                static addAbortSignal: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static compose: any;

                static defaultMaxListeners: any;

                static destroy: any;

                static errorMonitor: any;

                static finished: any;

                static getEventListeners: any;

                static init: any;

                static isDisturbed: any;

                static isErrored: any;

                static isReadable: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static pipeline: any;

                static promises: any;

                static setMaxListeners: any;

                static usingDomains: any;

            }

            class Transform {
                constructor(options: any);

                static Duplex: any;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static PassThrough: any;

                static Readable: any;

                static ReadableState: any;

                static Stream: any;

                static Transform: any;

                static Writable: any;

                static addAbortSignal: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static compose: any;

                static defaultMaxListeners: any;

                static destroy: any;

                static errorMonitor: any;

                static finished: any;

                static from: any;

                static getEventListeners: any;

                static init: any;

                static isDisturbed: any;

                static isErrored: any;

                static isReadable: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static pipeline: any;

                static promises: any;

                static setMaxListeners: any;

                static usingDomains: any;

                static wrap: any;

            }

            class Writable {
                constructor(options: any);

                cork(): void;

                destroy(err: any, cb: any): any;

                end(chunk: any, encoding: any, cb: any): any;

                pipe(): void;

                setDefaultEncoding(encoding: any): any;

                uncork(): void;

                write(chunk: any, encoding: any, cb: any): any;

                static Duplex: any;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static PassThrough: any;

                static Readable: any;

                static Stream: any;

                static Transform: any;

                static Writable: any;

                static WritableState: any;

                static addAbortSignal: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static compose: any;

                static defaultMaxListeners: any;

                static destroy: any;

                static errorMonitor: any;

                static finished: any;

                static getEventListeners: any;

                static init: any;

                static isDisturbed: any;

                static isErrored: any;

                static isReadable: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static pipeline: any;

                static promises: any;

                static setMaxListeners: any;

                static usingDomains: any;

            }

            namespace promises {
                // Too-deep object hierarchy from fs.WriteStream.Duplex.Readable.promises
                const finished: any;

                // Too-deep object hierarchy from fs.WriteStream.Duplex.Readable.promises
                const pipeline: any;

            }

        }

        namespace Stream {
            class EventEmitter {
                constructor(opts: any);

                addListener(type: any, listener: any): any;

                emit(type: any, args: any): any;

                eventNames(): any;

                getMaxListeners(): any;

                listenerCount(type: any): any;

                listeners(type: any): any;

                off(type: any, listener: any): any;

                on(type: any, listener: any): any;

                once(type: any, listener: any): any;

                prependListener(type: any, listener: any): any;

                prependOnceListener(type: any, listener: any): any;

                rawListeners(type: any): any;

                removeAllListeners(type: any, ...args: any[]): any;

                removeListener(type: any, listener: any): any;

                setMaxListeners(n: any): any;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static defaultMaxListeners: any;

                static errorMonitor: any;

                static getEventListeners: any;

                static init: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static setMaxListeners: any;

                static usingDomains: any;

            }

            class EventEmitterAsyncResource {
                constructor(...args: any[]);

                emit(...args: any[]): void;

                emitDestroy(...args: any[]): void;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static defaultMaxListeners: any;

                static errorMonitor: any;

                static getEventListeners: any;

                static init: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static setMaxListeners: any;

                static usingDomains: any;

            }

            class PassThrough {
                constructor(options: any);

                static Duplex: any;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static PassThrough: any;

                static Readable: any;

                static ReadableState: any;

                static Stream: any;

                static Transform: any;

                static Writable: any;

                static addAbortSignal: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static compose: any;

                static defaultMaxListeners: any;

                static destroy: any;

                static errorMonitor: any;

                static finished: any;

                static from: any;

                static getEventListeners: any;

                static init: any;

                static isDisturbed: any;

                static isErrored: any;

                static isReadable: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static pipeline: any;

                static promises: any;

                static setMaxListeners: any;

                static usingDomains: any;

                static wrap: any;

            }

            class Readable {
                constructor(options: any);

                addListener(ev: any, fn: any): any;

                destroy(err: any, cb: any): any;

                filter(args: any): any;

                isPaused(): any;

                iterator(options: any): any;

                map(args: any): any;

                off(ev: any, fn: any): any;

                on(ev: any, fn: any): any;

                pause(): any;

                pipe(dest: any, pipeOpts: any): any;

                push(chunk: any, encoding: any): any;

                read(n: any): any;

                removeAllListeners(ev: any, ...args: any[]): any;

                removeListener(ev: any, fn: any): any;

                resume(): any;

                setEncoding(enc: any): any;

                unpipe(dest: any): any;

                unshift(chunk: any, encoding: any): any;

                wrap(stream: any): any;

                static Duplex: any;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static PassThrough: any;

                static Readable: any;

                static ReadableState: any;

                static Stream: any;

                static Transform: any;

                static Writable: any;

                static addAbortSignal: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static compose: any;

                static defaultMaxListeners: any;

                static destroy: any;

                static errorMonitor: any;

                static finished: any;

                static from: any;

                static getEventListeners: any;

                static init: any;

                static isDisturbed: any;

                static isErrored: any;

                static isReadable: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static pipeline: any;

                static promises: any;

                static setMaxListeners: any;

                static usingDomains: any;

                static wrap: any;

            }

            class Transform {
                constructor(options: any);

                static Duplex: any;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static PassThrough: any;

                static Readable: any;

                static ReadableState: any;

                static Stream: any;

                static Transform: any;

                static Writable: any;

                static addAbortSignal: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static compose: any;

                static defaultMaxListeners: any;

                static destroy: any;

                static errorMonitor: any;

                static finished: any;

                static from: any;

                static getEventListeners: any;

                static init: any;

                static isDisturbed: any;

                static isErrored: any;

                static isReadable: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static pipeline: any;

                static promises: any;

                static setMaxListeners: any;

                static usingDomains: any;

                static wrap: any;

            }

            class Writable {
                constructor(options: any);

                cork(): void;

                destroy(err: any, cb: any): any;

                end(chunk: any, encoding: any, cb: any): any;

                pipe(): void;

                setDefaultEncoding(encoding: any): any;

                uncork(): void;

                write(chunk: any, encoding: any, cb: any): any;

                static Duplex: any;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static PassThrough: any;

                static Readable: any;

                static Stream: any;

                static Transform: any;

                static Writable: any;

                static WritableState: any;

                static addAbortSignal: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static compose: any;

                static defaultMaxListeners: any;

                static destroy: any;

                static errorMonitor: any;

                static finished: any;

                static getEventListeners: any;

                static init: any;

                static isDisturbed: any;

                static isErrored: any;

                static isReadable: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static pipeline: any;

                static promises: any;

                static setMaxListeners: any;

                static usingDomains: any;

            }

            namespace promises {
                // Too-deep object hierarchy from fs.WriteStream.Duplex.Stream.promises
                const finished: any;

                // Too-deep object hierarchy from fs.WriteStream.Duplex.Stream.promises
                const pipeline: any;

            }

        }

        namespace Transform {
            class EventEmitter {
                constructor(opts: any);

                addListener(type: any, listener: any): any;

                emit(type: any, args: any): any;

                eventNames(): any;

                getMaxListeners(): any;

                listenerCount(type: any): any;

                listeners(type: any): any;

                off(type: any, listener: any): any;

                on(type: any, listener: any): any;

                once(type: any, listener: any): any;

                prependListener(type: any, listener: any): any;

                prependOnceListener(type: any, listener: any): any;

                rawListeners(type: any): any;

                removeAllListeners(type: any, ...args: any[]): any;

                removeListener(type: any, listener: any): any;

                setMaxListeners(n: any): any;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static defaultMaxListeners: any;

                static errorMonitor: any;

                static getEventListeners: any;

                static init: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static setMaxListeners: any;

                static usingDomains: any;

            }

            class EventEmitterAsyncResource {
                constructor(...args: any[]);

                emit(...args: any[]): void;

                emitDestroy(...args: any[]): void;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static defaultMaxListeners: any;

                static errorMonitor: any;

                static getEventListeners: any;

                static init: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static setMaxListeners: any;

                static usingDomains: any;

            }

            class PassThrough {
                constructor(options: any);

                static Duplex: any;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static PassThrough: any;

                static Readable: any;

                static ReadableState: any;

                static Stream: any;

                static Transform: any;

                static Writable: any;

                static addAbortSignal: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static compose: any;

                static defaultMaxListeners: any;

                static destroy: any;

                static errorMonitor: any;

                static finished: any;

                static from: any;

                static getEventListeners: any;

                static init: any;

                static isDisturbed: any;

                static isErrored: any;

                static isReadable: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static pipeline: any;

                static promises: any;

                static setMaxListeners: any;

                static usingDomains: any;

                static wrap: any;

            }

            class Readable {
                constructor(options: any);

                addListener(ev: any, fn: any): any;

                destroy(err: any, cb: any): any;

                filter(args: any): any;

                isPaused(): any;

                iterator(options: any): any;

                map(args: any): any;

                off(ev: any, fn: any): any;

                on(ev: any, fn: any): any;

                pause(): any;

                pipe(dest: any, pipeOpts: any): any;

                push(chunk: any, encoding: any): any;

                read(n: any): any;

                removeAllListeners(ev: any, ...args: any[]): any;

                removeListener(ev: any, fn: any): any;

                resume(): any;

                setEncoding(enc: any): any;

                unpipe(dest: any): any;

                unshift(chunk: any, encoding: any): any;

                wrap(stream: any): any;

                static Duplex: any;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static PassThrough: any;

                static Readable: any;

                static ReadableState: any;

                static Stream: any;

                static Transform: any;

                static Writable: any;

                static addAbortSignal: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static compose: any;

                static defaultMaxListeners: any;

                static destroy: any;

                static errorMonitor: any;

                static finished: any;

                static from: any;

                static getEventListeners: any;

                static init: any;

                static isDisturbed: any;

                static isErrored: any;

                static isReadable: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static pipeline: any;

                static promises: any;

                static setMaxListeners: any;

                static usingDomains: any;

                static wrap: any;

            }

            class ReadableState {
                constructor(options: any, stream: any, isDuplex: any);

            }

            class Stream {
                constructor(opts: any);

                pipe(dest: any, options: any): any;

                static Duplex: any;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static PassThrough: any;

                static Readable: any;

                static Stream: any;

                static Transform: any;

                static Writable: any;

                static addAbortSignal: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static compose: any;

                static defaultMaxListeners: any;

                static destroy: any;

                static errorMonitor: any;

                static finished: any;

                static getEventListeners: any;

                static init: any;

                static isDisturbed: any;

                static isErrored: any;

                static isReadable: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static pipeline: any;

                static promises: any;

                static setMaxListeners: any;

                static usingDomains: any;

            }

            class Writable {
                constructor(options: any);

                cork(): void;

                destroy(err: any, cb: any): any;

                end(chunk: any, encoding: any, cb: any): any;

                pipe(): void;

                setDefaultEncoding(encoding: any): any;

                uncork(): void;

                write(chunk: any, encoding: any, cb: any): any;

                static Duplex: any;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static PassThrough: any;

                static Readable: any;

                static Stream: any;

                static Transform: any;

                static Writable: any;

                static WritableState: any;

                static addAbortSignal: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static compose: any;

                static defaultMaxListeners: any;

                static destroy: any;

                static errorMonitor: any;

                static finished: any;

                static getEventListeners: any;

                static init: any;

                static isDisturbed: any;

                static isErrored: any;

                static isReadable: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static pipeline: any;

                static promises: any;

                static setMaxListeners: any;

                static usingDomains: any;

            }

            namespace promises {
                // Too-deep object hierarchy from fs.WriteStream.Duplex.Transform.promises
                const finished: any;

                // Too-deep object hierarchy from fs.WriteStream.Duplex.Transform.promises
                const pipeline: any;

            }

        }

        namespace Writable {
            class EventEmitter {
                constructor(opts: any);

                addListener(type: any, listener: any): any;

                emit(type: any, args: any): any;

                eventNames(): any;

                getMaxListeners(): any;

                listenerCount(type: any): any;

                listeners(type: any): any;

                off(type: any, listener: any): any;

                on(type: any, listener: any): any;

                once(type: any, listener: any): any;

                prependListener(type: any, listener: any): any;

                prependOnceListener(type: any, listener: any): any;

                rawListeners(type: any): any;

                removeAllListeners(type: any, ...args: any[]): any;

                removeListener(type: any, listener: any): any;

                setMaxListeners(n: any): any;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static defaultMaxListeners: any;

                static errorMonitor: any;

                static getEventListeners: any;

                static init: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static setMaxListeners: any;

                static usingDomains: any;

            }

            class EventEmitterAsyncResource {
                constructor(...args: any[]);

                emit(...args: any[]): void;

                emitDestroy(...args: any[]): void;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static defaultMaxListeners: any;

                static errorMonitor: any;

                static getEventListeners: any;

                static init: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static setMaxListeners: any;

                static usingDomains: any;

            }

            class PassThrough {
                constructor(options: any);

                static Duplex: any;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static PassThrough: any;

                static Readable: any;

                static ReadableState: any;

                static Stream: any;

                static Transform: any;

                static Writable: any;

                static addAbortSignal: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static compose: any;

                static defaultMaxListeners: any;

                static destroy: any;

                static errorMonitor: any;

                static finished: any;

                static from: any;

                static getEventListeners: any;

                static init: any;

                static isDisturbed: any;

                static isErrored: any;

                static isReadable: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static pipeline: any;

                static promises: any;

                static setMaxListeners: any;

                static usingDomains: any;

                static wrap: any;

            }

            class Readable {
                constructor(options: any);

                addListener(ev: any, fn: any): any;

                destroy(err: any, cb: any): any;

                filter(args: any): any;

                isPaused(): any;

                iterator(options: any): any;

                map(args: any): any;

                off(ev: any, fn: any): any;

                on(ev: any, fn: any): any;

                pause(): any;

                pipe(dest: any, pipeOpts: any): any;

                push(chunk: any, encoding: any): any;

                read(n: any): any;

                removeAllListeners(ev: any, ...args: any[]): any;

                removeListener(ev: any, fn: any): any;

                resume(): any;

                setEncoding(enc: any): any;

                unpipe(dest: any): any;

                unshift(chunk: any, encoding: any): any;

                wrap(stream: any): any;

                static Duplex: any;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static PassThrough: any;

                static Readable: any;

                static ReadableState: any;

                static Stream: any;

                static Transform: any;

                static Writable: any;

                static addAbortSignal: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static compose: any;

                static defaultMaxListeners: any;

                static destroy: any;

                static errorMonitor: any;

                static finished: any;

                static from: any;

                static getEventListeners: any;

                static init: any;

                static isDisturbed: any;

                static isErrored: any;

                static isReadable: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static pipeline: any;

                static promises: any;

                static setMaxListeners: any;

                static usingDomains: any;

                static wrap: any;

            }

            class Stream {
                constructor(opts: any);

                pipe(dest: any, options: any): any;

                static Duplex: any;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static PassThrough: any;

                static Readable: any;

                static Stream: any;

                static Transform: any;

                static Writable: any;

                static addAbortSignal: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static compose: any;

                static defaultMaxListeners: any;

                static destroy: any;

                static errorMonitor: any;

                static finished: any;

                static getEventListeners: any;

                static init: any;

                static isDisturbed: any;

                static isErrored: any;

                static isReadable: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static pipeline: any;

                static promises: any;

                static setMaxListeners: any;

                static usingDomains: any;

            }

            class Transform {
                constructor(options: any);

                static Duplex: any;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static PassThrough: any;

                static Readable: any;

                static ReadableState: any;

                static Stream: any;

                static Transform: any;

                static Writable: any;

                static addAbortSignal: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static compose: any;

                static defaultMaxListeners: any;

                static destroy: any;

                static errorMonitor: any;

                static finished: any;

                static from: any;

                static getEventListeners: any;

                static init: any;

                static isDisturbed: any;

                static isErrored: any;

                static isReadable: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static pipeline: any;

                static promises: any;

                static setMaxListeners: any;

                static usingDomains: any;

                static wrap: any;

            }

            class WritableState {
                constructor(options: any, stream: any, isDuplex: any);

                getBuffer(): any;

            }

            namespace promises {
                // Too-deep object hierarchy from fs.WriteStream.Duplex.Writable.promises
                const finished: any;

                // Too-deep object hierarchy from fs.WriteStream.Duplex.Writable.promises
                const pipeline: any;

            }

        }

        namespace promises {
            function finished(stream: any, opts: any): any;

            function pipeline(streams: any): any;

        }

    }

    namespace EventEmitter {
        class EventEmitterAsyncResource {
            constructor(...args: any[]);

            emit(...args: any[]): void;

            emitDestroy(...args: any[]): void;

            static EventEmitter: any;

            static EventEmitterAsyncResource: any;

            static captureRejectionSymbol: any;

            static captureRejections: boolean;

            static defaultMaxListeners: number;

            static errorMonitor: any;

            static getEventListeners(emitterOrTarget: any, type: any): any;

            static init(opts: any): void;

            static kMaxEventTargetListeners: any;

            static kMaxEventTargetListenersWarned: any;

            static listenerCount(emitter: any, type: any): any;

            static on(emitter: any, event: any, options: any): any;

            static once(emitter: any, name: any, options: any): any;

            static setMaxListeners(n: any, eventTargets: any): void;

            static usingDomains: boolean;

        }

    }

    namespace EventEmitterAsyncResource {
        class EventEmitter {
            constructor(opts: any);

            addListener(type: any, listener: any): any;

            emit(type: any, args: any): any;

            eventNames(): any;

            getMaxListeners(): any;

            listenerCount(type: any): any;

            listeners(type: any): any;

            off(type: any, listener: any): any;

            on(type: any, listener: any): any;

            once(type: any, listener: any): any;

            prependListener(type: any, listener: any): any;

            prependOnceListener(type: any, listener: any): any;

            rawListeners(type: any): any;

            removeAllListeners(type: any, ...args: any[]): any;

            removeListener(type: any, listener: any): any;

            setMaxListeners(n: any): any;

            static EventEmitter: any;

            static EventEmitterAsyncResource: any;

            static captureRejectionSymbol: any;

            static captureRejections: boolean;

            static defaultMaxListeners: number;

            static errorMonitor: any;

            static getEventListeners(emitterOrTarget: any, type: any): any;

            static init(opts: any): void;

            static kMaxEventTargetListeners: any;

            static kMaxEventTargetListenersWarned: any;

            static listenerCount(emitter: any, type: any): any;

            static on(emitter: any, event: any, options: any): any;

            static once(emitter: any, name: any, options: any): any;

            static setMaxListeners(n: any, eventTargets: any): void;

            static usingDomains: boolean;

        }

    }

    namespace PassThrough {
        class Duplex {
            constructor(options: any);

            cork(): void;

            end(chunk: any, encoding: any, cb: any): any;

            setDefaultEncoding(encoding: any): any;

            uncork(): void;

            write(chunk: any, encoding: any, cb: any): any;

            static Duplex: any;

            static PassThrough: any;

            static addAbortSignal(signal: any, stream: any): any;

            static captureRejectionSymbol: any;

            static captureRejections: boolean;

            static compose(streams: any): any;

            static defaultMaxListeners: number;

            static destroy(stream: any, err: any): any;

            static errorMonitor: any;

            static finished(stream: any, options: any, callback: any, ...args: any[]): any;

            static from(body: any): any;

            static getEventListeners(emitterOrTarget: any, type: any): any;

            static init(opts: any): void;

            static isDisturbed(stream: any): any;

            static isErrored(stream: any): any;

            static isReadable(stream: any): any;

            static kMaxEventTargetListeners: any;

            static kMaxEventTargetListenersWarned: any;

            static listenerCount(emitter: any, type: any): any;

            static on(emitter: any, event: any, options: any): any;

            static once(emitter: any, name: any, options: any): any;

            static pipeline(streams: any): any;

            static setMaxListeners(n: any, eventTargets: any): void;

            static usingDomains: boolean;

            static wrap(src: any, options: any): any;

        }

        class EventEmitter {
            constructor(opts: any);

            addListener(type: any, listener: any): any;

            emit(type: any, args: any): any;

            eventNames(): any;

            getMaxListeners(): any;

            listenerCount(type: any): any;

            listeners(type: any): any;

            off(type: any, listener: any): any;

            on(type: any, listener: any): any;

            once(type: any, listener: any): any;

            prependListener(type: any, listener: any): any;

            prependOnceListener(type: any, listener: any): any;

            rawListeners(type: any): any;

            removeAllListeners(type: any, ...args: any[]): any;

            removeListener(type: any, listener: any): any;

            setMaxListeners(n: any): any;

            static EventEmitter: any;

            static captureRejectionSymbol: any;

            static captureRejections: boolean;

            static defaultMaxListeners: number;

            static errorMonitor: any;

            static getEventListeners(emitterOrTarget: any, type: any): any;

            static init(opts: any): void;

            static kMaxEventTargetListeners: any;

            static kMaxEventTargetListenersWarned: any;

            static listenerCount(emitter: any, type: any): any;

            static on(emitter: any, event: any, options: any): any;

            static once(emitter: any, name: any, options: any): any;

            static setMaxListeners(n: any, eventTargets: any): void;

            static usingDomains: boolean;

        }

        class EventEmitterAsyncResource {
            constructor(...args: any[]);

            emit(...args: any[]): void;

            emitDestroy(...args: any[]): void;

            static EventEmitterAsyncResource: any;

            static captureRejectionSymbol: any;

            static captureRejections: boolean;

            static defaultMaxListeners: number;

            static errorMonitor: any;

            static getEventListeners(emitterOrTarget: any, type: any): any;

            static init(opts: any): void;

            static kMaxEventTargetListeners: any;

            static kMaxEventTargetListenersWarned: any;

            static listenerCount(emitter: any, type: any): any;

            static on(emitter: any, event: any, options: any): any;

            static once(emitter: any, name: any, options: any): any;

            static setMaxListeners(n: any, eventTargets: any): void;

            static usingDomains: boolean;

        }

        class Readable {
            constructor(options: any);

            addListener(ev: any, fn: any): any;

            destroy(err: any, cb: any): any;

            filter(args: any): any;

            isPaused(): any;

            iterator(options: any): any;

            map(args: any): any;

            off(ev: any, fn: any): any;

            on(ev: any, fn: any): any;

            pause(): any;

            pipe(dest: any, pipeOpts: any): any;

            push(chunk: any, encoding: any): any;

            read(n: any): any;

            removeAllListeners(ev: any, ...args: any[]): any;

            removeListener(ev: any, fn: any): any;

            resume(): any;

            setEncoding(enc: any): any;

            unpipe(dest: any): any;

            unshift(chunk: any, encoding: any): any;

            wrap(stream: any): any;

            static PassThrough: any;

            static Readable: any;

            static addAbortSignal(signal: any, stream: any): any;

            static captureRejectionSymbol: any;

            static captureRejections: boolean;

            static compose(streams: any): any;

            static defaultMaxListeners: number;

            static destroy(stream: any, err: any): any;

            static errorMonitor: any;

            static finished(stream: any, options: any, callback: any, ...args: any[]): any;

            static from(iterable: any, opts: any): any;

            static getEventListeners(emitterOrTarget: any, type: any): any;

            static init(opts: any): void;

            static isDisturbed(stream: any): any;

            static isErrored(stream: any): any;

            static isReadable(stream: any): any;

            static kMaxEventTargetListeners: any;

            static kMaxEventTargetListenersWarned: any;

            static listenerCount(emitter: any, type: any): any;

            static on(emitter: any, event: any, options: any): any;

            static once(emitter: any, name: any, options: any): any;

            static pipeline(streams: any): any;

            static setMaxListeners(n: any, eventTargets: any): void;

            static usingDomains: boolean;

            static wrap(src: any, options: any): any;

        }

        class ReadableState {
            constructor(options: any, stream: any, isDuplex: any);

        }

        class Stream {
            constructor(opts: any);

            pipe(dest: any, options: any): any;

            static PassThrough: any;

            static Stream: any;

            static addAbortSignal(signal: any, stream: any): any;

            static captureRejectionSymbol: any;

            static captureRejections: boolean;

            static compose(streams: any): any;

            static defaultMaxListeners: number;

            static destroy(stream: any, err: any): any;

            static errorMonitor: any;

            static finished(stream: any, options: any, callback: any, ...args: any[]): any;

            static getEventListeners(emitterOrTarget: any, type: any): any;

            static init(opts: any): void;

            static isDisturbed(stream: any): any;

            static isErrored(stream: any): any;

            static isReadable(stream: any): any;

            static kMaxEventTargetListeners: any;

            static kMaxEventTargetListenersWarned: any;

            static listenerCount(emitter: any, type: any): any;

            static on(emitter: any, event: any, options: any): any;

            static once(emitter: any, name: any, options: any): any;

            static pipeline(streams: any): any;

            static setMaxListeners(n: any, eventTargets: any): void;

            static usingDomains: boolean;

        }

        class Transform {
            constructor(options: any);

            static PassThrough: any;

            static Transform: any;

            static addAbortSignal(signal: any, stream: any): any;

            static captureRejectionSymbol: any;

            static captureRejections: boolean;

            static compose(streams: any): any;

            static defaultMaxListeners: number;

            static destroy(stream: any, err: any): any;

            static errorMonitor: any;

            static finished(stream: any, options: any, callback: any, ...args: any[]): any;

            static from(body: any): any;

            static getEventListeners(emitterOrTarget: any, type: any): any;

            static init(opts: any): void;

            static isDisturbed(stream: any): any;

            static isErrored(stream: any): any;

            static isReadable(stream: any): any;

            static kMaxEventTargetListeners: any;

            static kMaxEventTargetListenersWarned: any;

            static listenerCount(emitter: any, type: any): any;

            static on(emitter: any, event: any, options: any): any;

            static once(emitter: any, name: any, options: any): any;

            static pipeline(streams: any): any;

            static setMaxListeners(n: any, eventTargets: any): void;

            static usingDomains: boolean;

            static wrap(src: any, options: any): any;

        }

        class Writable {
            constructor(options: any);

            cork(): void;

            destroy(err: any, cb: any): any;

            end(chunk: any, encoding: any, cb: any): any;

            pipe(): void;

            setDefaultEncoding(encoding: any): any;

            uncork(): void;

            write(chunk: any, encoding: any, cb: any): any;

            static PassThrough: any;

            static Writable: any;

            static addAbortSignal(signal: any, stream: any): any;

            static captureRejectionSymbol: any;

            static captureRejections: boolean;

            static compose(streams: any): any;

            static defaultMaxListeners: number;

            static destroy(stream: any, err: any): any;

            static errorMonitor: any;

            static finished(stream: any, options: any, callback: any, ...args: any[]): any;

            static getEventListeners(emitterOrTarget: any, type: any): any;

            static init(opts: any): void;

            static isDisturbed(stream: any): any;

            static isErrored(stream: any): any;

            static isReadable(stream: any): any;

            static kMaxEventTargetListeners: any;

            static kMaxEventTargetListenersWarned: any;

            static listenerCount(emitter: any, type: any): any;

            static on(emitter: any, event: any, options: any): any;

            static once(emitter: any, name: any, options: any): any;

            static pipeline(streams: any): any;

            static setMaxListeners(n: any, eventTargets: any): void;

            static usingDomains: boolean;

        }

        namespace Duplex {
            class EventEmitter {
                constructor(opts: any);

                addListener(type: any, listener: any): any;

                emit(type: any, args: any): any;

                eventNames(): any;

                getMaxListeners(): any;

                listenerCount(type: any): any;

                listeners(type: any): any;

                off(type: any, listener: any): any;

                on(type: any, listener: any): any;

                once(type: any, listener: any): any;

                prependListener(type: any, listener: any): any;

                prependOnceListener(type: any, listener: any): any;

                rawListeners(type: any): any;

                removeAllListeners(type: any, ...args: any[]): any;

                removeListener(type: any, listener: any): any;

                setMaxListeners(n: any): any;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static defaultMaxListeners: any;

                static errorMonitor: any;

                static getEventListeners: any;

                static init: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static setMaxListeners: any;

                static usingDomains: any;

            }

            class EventEmitterAsyncResource {
                constructor(...args: any[]);

                emit(...args: any[]): void;

                emitDestroy(...args: any[]): void;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static defaultMaxListeners: any;

                static errorMonitor: any;

                static getEventListeners: any;

                static init: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static setMaxListeners: any;

                static usingDomains: any;

            }

            class Readable {
                constructor(options: any);

                addListener(ev: any, fn: any): any;

                destroy(err: any, cb: any): any;

                filter(args: any): any;

                isPaused(): any;

                iterator(options: any): any;

                map(args: any): any;

                off(ev: any, fn: any): any;

                on(ev: any, fn: any): any;

                pause(): any;

                pipe(dest: any, pipeOpts: any): any;

                push(chunk: any, encoding: any): any;

                read(n: any): any;

                removeAllListeners(ev: any, ...args: any[]): any;

                removeListener(ev: any, fn: any): any;

                resume(): any;

                setEncoding(enc: any): any;

                unpipe(dest: any): any;

                unshift(chunk: any, encoding: any): any;

                wrap(stream: any): any;

                static Duplex: any;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static PassThrough: any;

                static Readable: any;

                static ReadableState: any;

                static Stream: any;

                static Transform: any;

                static Writable: any;

                static addAbortSignal: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static compose: any;

                static defaultMaxListeners: any;

                static destroy: any;

                static errorMonitor: any;

                static finished: any;

                static from: any;

                static getEventListeners: any;

                static init: any;

                static isDisturbed: any;

                static isErrored: any;

                static isReadable: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static pipeline: any;

                static promises: any;

                static setMaxListeners: any;

                static usingDomains: any;

                static wrap: any;

            }

            class ReadableState {
                constructor(options: any, stream: any, isDuplex: any);

            }

            class Stream {
                constructor(opts: any);

                pipe(dest: any, options: any): any;

                static Duplex: any;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static PassThrough: any;

                static Readable: any;

                static Stream: any;

                static Transform: any;

                static Writable: any;

                static addAbortSignal: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static compose: any;

                static defaultMaxListeners: any;

                static destroy: any;

                static errorMonitor: any;

                static finished: any;

                static getEventListeners: any;

                static init: any;

                static isDisturbed: any;

                static isErrored: any;

                static isReadable: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static pipeline: any;

                static promises: any;

                static setMaxListeners: any;

                static usingDomains: any;

            }

            class Transform {
                constructor(options: any);

                static Duplex: any;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static PassThrough: any;

                static Readable: any;

                static ReadableState: any;

                static Stream: any;

                static Transform: any;

                static Writable: any;

                static addAbortSignal: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static compose: any;

                static defaultMaxListeners: any;

                static destroy: any;

                static errorMonitor: any;

                static finished: any;

                static from: any;

                static getEventListeners: any;

                static init: any;

                static isDisturbed: any;

                static isErrored: any;

                static isReadable: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static pipeline: any;

                static promises: any;

                static setMaxListeners: any;

                static usingDomains: any;

                static wrap: any;

            }

            class Writable {
                constructor(options: any);

                cork(): void;

                destroy(err: any, cb: any): any;

                end(chunk: any, encoding: any, cb: any): any;

                pipe(): void;

                setDefaultEncoding(encoding: any): any;

                uncork(): void;

                write(chunk: any, encoding: any, cb: any): any;

                static Duplex: any;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static PassThrough: any;

                static Readable: any;

                static Stream: any;

                static Transform: any;

                static Writable: any;

                static WritableState: any;

                static addAbortSignal: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static compose: any;

                static defaultMaxListeners: any;

                static destroy: any;

                static errorMonitor: any;

                static finished: any;

                static getEventListeners: any;

                static init: any;

                static isDisturbed: any;

                static isErrored: any;

                static isReadable: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static pipeline: any;

                static promises: any;

                static setMaxListeners: any;

                static usingDomains: any;

            }

            namespace promises {
                // Too-deep object hierarchy from fs.WriteStream.PassThrough.Duplex.promises
                const finished: any;

                // Too-deep object hierarchy from fs.WriteStream.PassThrough.Duplex.promises
                const pipeline: any;

            }

        }

        namespace EventEmitter {
            class EventEmitterAsyncResource {
                constructor(...args: any[]);

                emit(...args: any[]): void;

                emitDestroy(...args: any[]): void;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static defaultMaxListeners: any;

                static errorMonitor: any;

                static getEventListeners: any;

                static init: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static setMaxListeners: any;

                static usingDomains: any;

            }

        }

        namespace EventEmitterAsyncResource {
            class EventEmitter {
                constructor(opts: any);

                addListener(type: any, listener: any): any;

                emit(type: any, args: any): any;

                eventNames(): any;

                getMaxListeners(): any;

                listenerCount(type: any): any;

                listeners(type: any): any;

                off(type: any, listener: any): any;

                on(type: any, listener: any): any;

                once(type: any, listener: any): any;

                prependListener(type: any, listener: any): any;

                prependOnceListener(type: any, listener: any): any;

                rawListeners(type: any): any;

                removeAllListeners(type: any, ...args: any[]): any;

                removeListener(type: any, listener: any): any;

                setMaxListeners(n: any): any;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static defaultMaxListeners: any;

                static errorMonitor: any;

                static getEventListeners: any;

                static init: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static setMaxListeners: any;

                static usingDomains: any;

            }

        }

        namespace Readable {
            class Duplex {
                constructor(options: any);

                cork(): void;

                end(chunk: any, encoding: any, cb: any): any;

                setDefaultEncoding(encoding: any): any;

                uncork(): void;

                write(chunk: any, encoding: any, cb: any): any;

                static Duplex: any;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static PassThrough: any;

                static Readable: any;

                static ReadableState: any;

                static Stream: any;

                static Transform: any;

                static Writable: any;

                static addAbortSignal: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static compose: any;

                static defaultMaxListeners: any;

                static destroy: any;

                static errorMonitor: any;

                static finished: any;

                static from: any;

                static getEventListeners: any;

                static init: any;

                static isDisturbed: any;

                static isErrored: any;

                static isReadable: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static pipeline: any;

                static promises: any;

                static setMaxListeners: any;

                static usingDomains: any;

                static wrap: any;

            }

            class EventEmitter {
                constructor(opts: any);

                addListener(type: any, listener: any): any;

                emit(type: any, args: any): any;

                eventNames(): any;

                getMaxListeners(): any;

                listenerCount(type: any): any;

                listeners(type: any): any;

                off(type: any, listener: any): any;

                on(type: any, listener: any): any;

                once(type: any, listener: any): any;

                prependListener(type: any, listener: any): any;

                prependOnceListener(type: any, listener: any): any;

                rawListeners(type: any): any;

                removeAllListeners(type: any, ...args: any[]): any;

                removeListener(type: any, listener: any): any;

                setMaxListeners(n: any): any;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static defaultMaxListeners: any;

                static errorMonitor: any;

                static getEventListeners: any;

                static init: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static setMaxListeners: any;

                static usingDomains: any;

            }

            class EventEmitterAsyncResource {
                constructor(...args: any[]);

                emit(...args: any[]): void;

                emitDestroy(...args: any[]): void;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static defaultMaxListeners: any;

                static errorMonitor: any;

                static getEventListeners: any;

                static init: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static setMaxListeners: any;

                static usingDomains: any;

            }

            class ReadableState {
                constructor(options: any, stream: any, isDuplex: any);

            }

            class Stream {
                constructor(opts: any);

                pipe(dest: any, options: any): any;

                static Duplex: any;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static PassThrough: any;

                static Readable: any;

                static Stream: any;

                static Transform: any;

                static Writable: any;

                static addAbortSignal: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static compose: any;

                static defaultMaxListeners: any;

                static destroy: any;

                static errorMonitor: any;

                static finished: any;

                static getEventListeners: any;

                static init: any;

                static isDisturbed: any;

                static isErrored: any;

                static isReadable: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static pipeline: any;

                static promises: any;

                static setMaxListeners: any;

                static usingDomains: any;

            }

            class Transform {
                constructor(options: any);

                static Duplex: any;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static PassThrough: any;

                static Readable: any;

                static ReadableState: any;

                static Stream: any;

                static Transform: any;

                static Writable: any;

                static addAbortSignal: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static compose: any;

                static defaultMaxListeners: any;

                static destroy: any;

                static errorMonitor: any;

                static finished: any;

                static from: any;

                static getEventListeners: any;

                static init: any;

                static isDisturbed: any;

                static isErrored: any;

                static isReadable: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static pipeline: any;

                static promises: any;

                static setMaxListeners: any;

                static usingDomains: any;

                static wrap: any;

            }

            class Writable {
                constructor(options: any);

                cork(): void;

                destroy(err: any, cb: any): any;

                end(chunk: any, encoding: any, cb: any): any;

                pipe(): void;

                setDefaultEncoding(encoding: any): any;

                uncork(): void;

                write(chunk: any, encoding: any, cb: any): any;

                static Duplex: any;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static PassThrough: any;

                static Readable: any;

                static Stream: any;

                static Transform: any;

                static Writable: any;

                static WritableState: any;

                static addAbortSignal: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static compose: any;

                static defaultMaxListeners: any;

                static destroy: any;

                static errorMonitor: any;

                static finished: any;

                static getEventListeners: any;

                static init: any;

                static isDisturbed: any;

                static isErrored: any;

                static isReadable: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static pipeline: any;

                static promises: any;

                static setMaxListeners: any;

                static usingDomains: any;

            }

            namespace promises {
                // Too-deep object hierarchy from fs.WriteStream.PassThrough.Readable.promises
                const finished: any;

                // Too-deep object hierarchy from fs.WriteStream.PassThrough.Readable.promises
                const pipeline: any;

            }

        }

        namespace Stream {
            class Duplex {
                constructor(options: any);

                cork(): void;

                end(chunk: any, encoding: any, cb: any): any;

                setDefaultEncoding(encoding: any): any;

                uncork(): void;

                write(chunk: any, encoding: any, cb: any): any;

                static Duplex: any;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static PassThrough: any;

                static Readable: any;

                static ReadableState: any;

                static Stream: any;

                static Transform: any;

                static Writable: any;

                static addAbortSignal: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static compose: any;

                static defaultMaxListeners: any;

                static destroy: any;

                static errorMonitor: any;

                static finished: any;

                static from: any;

                static getEventListeners: any;

                static init: any;

                static isDisturbed: any;

                static isErrored: any;

                static isReadable: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static pipeline: any;

                static promises: any;

                static setMaxListeners: any;

                static usingDomains: any;

                static wrap: any;

            }

            class EventEmitter {
                constructor(opts: any);

                addListener(type: any, listener: any): any;

                emit(type: any, args: any): any;

                eventNames(): any;

                getMaxListeners(): any;

                listenerCount(type: any): any;

                listeners(type: any): any;

                off(type: any, listener: any): any;

                on(type: any, listener: any): any;

                once(type: any, listener: any): any;

                prependListener(type: any, listener: any): any;

                prependOnceListener(type: any, listener: any): any;

                rawListeners(type: any): any;

                removeAllListeners(type: any, ...args: any[]): any;

                removeListener(type: any, listener: any): any;

                setMaxListeners(n: any): any;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static defaultMaxListeners: any;

                static errorMonitor: any;

                static getEventListeners: any;

                static init: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static setMaxListeners: any;

                static usingDomains: any;

            }

            class EventEmitterAsyncResource {
                constructor(...args: any[]);

                emit(...args: any[]): void;

                emitDestroy(...args: any[]): void;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static defaultMaxListeners: any;

                static errorMonitor: any;

                static getEventListeners: any;

                static init: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static setMaxListeners: any;

                static usingDomains: any;

            }

            class Readable {
                constructor(options: any);

                addListener(ev: any, fn: any): any;

                destroy(err: any, cb: any): any;

                filter(args: any): any;

                isPaused(): any;

                iterator(options: any): any;

                map(args: any): any;

                off(ev: any, fn: any): any;

                on(ev: any, fn: any): any;

                pause(): any;

                pipe(dest: any, pipeOpts: any): any;

                push(chunk: any, encoding: any): any;

                read(n: any): any;

                removeAllListeners(ev: any, ...args: any[]): any;

                removeListener(ev: any, fn: any): any;

                resume(): any;

                setEncoding(enc: any): any;

                unpipe(dest: any): any;

                unshift(chunk: any, encoding: any): any;

                wrap(stream: any): any;

                static Duplex: any;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static PassThrough: any;

                static Readable: any;

                static ReadableState: any;

                static Stream: any;

                static Transform: any;

                static Writable: any;

                static addAbortSignal: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static compose: any;

                static defaultMaxListeners: any;

                static destroy: any;

                static errorMonitor: any;

                static finished: any;

                static from: any;

                static getEventListeners: any;

                static init: any;

                static isDisturbed: any;

                static isErrored: any;

                static isReadable: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static pipeline: any;

                static promises: any;

                static setMaxListeners: any;

                static usingDomains: any;

                static wrap: any;

            }

            class Transform {
                constructor(options: any);

                static Duplex: any;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static PassThrough: any;

                static Readable: any;

                static ReadableState: any;

                static Stream: any;

                static Transform: any;

                static Writable: any;

                static addAbortSignal: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static compose: any;

                static defaultMaxListeners: any;

                static destroy: any;

                static errorMonitor: any;

                static finished: any;

                static from: any;

                static getEventListeners: any;

                static init: any;

                static isDisturbed: any;

                static isErrored: any;

                static isReadable: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static pipeline: any;

                static promises: any;

                static setMaxListeners: any;

                static usingDomains: any;

                static wrap: any;

            }

            class Writable {
                constructor(options: any);

                cork(): void;

                destroy(err: any, cb: any): any;

                end(chunk: any, encoding: any, cb: any): any;

                pipe(): void;

                setDefaultEncoding(encoding: any): any;

                uncork(): void;

                write(chunk: any, encoding: any, cb: any): any;

                static Duplex: any;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static PassThrough: any;

                static Readable: any;

                static Stream: any;

                static Transform: any;

                static Writable: any;

                static WritableState: any;

                static addAbortSignal: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static compose: any;

                static defaultMaxListeners: any;

                static destroy: any;

                static errorMonitor: any;

                static finished: any;

                static getEventListeners: any;

                static init: any;

                static isDisturbed: any;

                static isErrored: any;

                static isReadable: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static pipeline: any;

                static promises: any;

                static setMaxListeners: any;

                static usingDomains: any;

            }

            namespace promises {
                // Too-deep object hierarchy from fs.WriteStream.PassThrough.Stream.promises
                const finished: any;

                // Too-deep object hierarchy from fs.WriteStream.PassThrough.Stream.promises
                const pipeline: any;

            }

        }

        namespace Transform {
            class Duplex {
                constructor(options: any);

                cork(): void;

                end(chunk: any, encoding: any, cb: any): any;

                setDefaultEncoding(encoding: any): any;

                uncork(): void;

                write(chunk: any, encoding: any, cb: any): any;

                static Duplex: any;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static PassThrough: any;

                static Readable: any;

                static ReadableState: any;

                static Stream: any;

                static Transform: any;

                static Writable: any;

                static addAbortSignal: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static compose: any;

                static defaultMaxListeners: any;

                static destroy: any;

                static errorMonitor: any;

                static finished: any;

                static from: any;

                static getEventListeners: any;

                static init: any;

                static isDisturbed: any;

                static isErrored: any;

                static isReadable: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static pipeline: any;

                static promises: any;

                static setMaxListeners: any;

                static usingDomains: any;

                static wrap: any;

            }

            class EventEmitter {
                constructor(opts: any);

                addListener(type: any, listener: any): any;

                emit(type: any, args: any): any;

                eventNames(): any;

                getMaxListeners(): any;

                listenerCount(type: any): any;

                listeners(type: any): any;

                off(type: any, listener: any): any;

                on(type: any, listener: any): any;

                once(type: any, listener: any): any;

                prependListener(type: any, listener: any): any;

                prependOnceListener(type: any, listener: any): any;

                rawListeners(type: any): any;

                removeAllListeners(type: any, ...args: any[]): any;

                removeListener(type: any, listener: any): any;

                setMaxListeners(n: any): any;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static defaultMaxListeners: any;

                static errorMonitor: any;

                static getEventListeners: any;

                static init: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static setMaxListeners: any;

                static usingDomains: any;

            }

            class EventEmitterAsyncResource {
                constructor(...args: any[]);

                emit(...args: any[]): void;

                emitDestroy(...args: any[]): void;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static defaultMaxListeners: any;

                static errorMonitor: any;

                static getEventListeners: any;

                static init: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static setMaxListeners: any;

                static usingDomains: any;

            }

            class Readable {
                constructor(options: any);

                addListener(ev: any, fn: any): any;

                destroy(err: any, cb: any): any;

                filter(args: any): any;

                isPaused(): any;

                iterator(options: any): any;

                map(args: any): any;

                off(ev: any, fn: any): any;

                on(ev: any, fn: any): any;

                pause(): any;

                pipe(dest: any, pipeOpts: any): any;

                push(chunk: any, encoding: any): any;

                read(n: any): any;

                removeAllListeners(ev: any, ...args: any[]): any;

                removeListener(ev: any, fn: any): any;

                resume(): any;

                setEncoding(enc: any): any;

                unpipe(dest: any): any;

                unshift(chunk: any, encoding: any): any;

                wrap(stream: any): any;

                static Duplex: any;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static PassThrough: any;

                static Readable: any;

                static ReadableState: any;

                static Stream: any;

                static Transform: any;

                static Writable: any;

                static addAbortSignal: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static compose: any;

                static defaultMaxListeners: any;

                static destroy: any;

                static errorMonitor: any;

                static finished: any;

                static from: any;

                static getEventListeners: any;

                static init: any;

                static isDisturbed: any;

                static isErrored: any;

                static isReadable: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static pipeline: any;

                static promises: any;

                static setMaxListeners: any;

                static usingDomains: any;

                static wrap: any;

            }

            class ReadableState {
                constructor(options: any, stream: any, isDuplex: any);

            }

            class Stream {
                constructor(opts: any);

                pipe(dest: any, options: any): any;

                static Duplex: any;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static PassThrough: any;

                static Readable: any;

                static Stream: any;

                static Transform: any;

                static Writable: any;

                static addAbortSignal: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static compose: any;

                static defaultMaxListeners: any;

                static destroy: any;

                static errorMonitor: any;

                static finished: any;

                static getEventListeners: any;

                static init: any;

                static isDisturbed: any;

                static isErrored: any;

                static isReadable: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static pipeline: any;

                static promises: any;

                static setMaxListeners: any;

                static usingDomains: any;

            }

            class Writable {
                constructor(options: any);

                cork(): void;

                destroy(err: any, cb: any): any;

                end(chunk: any, encoding: any, cb: any): any;

                pipe(): void;

                setDefaultEncoding(encoding: any): any;

                uncork(): void;

                write(chunk: any, encoding: any, cb: any): any;

                static Duplex: any;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static PassThrough: any;

                static Readable: any;

                static Stream: any;

                static Transform: any;

                static Writable: any;

                static WritableState: any;

                static addAbortSignal: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static compose: any;

                static defaultMaxListeners: any;

                static destroy: any;

                static errorMonitor: any;

                static finished: any;

                static getEventListeners: any;

                static init: any;

                static isDisturbed: any;

                static isErrored: any;

                static isReadable: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static pipeline: any;

                static promises: any;

                static setMaxListeners: any;

                static usingDomains: any;

            }

            namespace promises {
                // Too-deep object hierarchy from fs.WriteStream.PassThrough.Transform.promises
                const finished: any;

                // Too-deep object hierarchy from fs.WriteStream.PassThrough.Transform.promises
                const pipeline: any;

            }

        }

        namespace Writable {
            class Duplex {
                constructor(options: any);

                cork(): void;

                end(chunk: any, encoding: any, cb: any): any;

                setDefaultEncoding(encoding: any): any;

                uncork(): void;

                write(chunk: any, encoding: any, cb: any): any;

                static Duplex: any;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static PassThrough: any;

                static Readable: any;

                static ReadableState: any;

                static Stream: any;

                static Transform: any;

                static Writable: any;

                static addAbortSignal: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static compose: any;

                static defaultMaxListeners: any;

                static destroy: any;

                static errorMonitor: any;

                static finished: any;

                static from: any;

                static getEventListeners: any;

                static init: any;

                static isDisturbed: any;

                static isErrored: any;

                static isReadable: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static pipeline: any;

                static promises: any;

                static setMaxListeners: any;

                static usingDomains: any;

                static wrap: any;

            }

            class EventEmitter {
                constructor(opts: any);

                addListener(type: any, listener: any): any;

                emit(type: any, args: any): any;

                eventNames(): any;

                getMaxListeners(): any;

                listenerCount(type: any): any;

                listeners(type: any): any;

                off(type: any, listener: any): any;

                on(type: any, listener: any): any;

                once(type: any, listener: any): any;

                prependListener(type: any, listener: any): any;

                prependOnceListener(type: any, listener: any): any;

                rawListeners(type: any): any;

                removeAllListeners(type: any, ...args: any[]): any;

                removeListener(type: any, listener: any): any;

                setMaxListeners(n: any): any;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static defaultMaxListeners: any;

                static errorMonitor: any;

                static getEventListeners: any;

                static init: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static setMaxListeners: any;

                static usingDomains: any;

            }

            class EventEmitterAsyncResource {
                constructor(...args: any[]);

                emit(...args: any[]): void;

                emitDestroy(...args: any[]): void;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static defaultMaxListeners: any;

                static errorMonitor: any;

                static getEventListeners: any;

                static init: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static setMaxListeners: any;

                static usingDomains: any;

            }

            class Readable {
                constructor(options: any);

                addListener(ev: any, fn: any): any;

                destroy(err: any, cb: any): any;

                filter(args: any): any;

                isPaused(): any;

                iterator(options: any): any;

                map(args: any): any;

                off(ev: any, fn: any): any;

                on(ev: any, fn: any): any;

                pause(): any;

                pipe(dest: any, pipeOpts: any): any;

                push(chunk: any, encoding: any): any;

                read(n: any): any;

                removeAllListeners(ev: any, ...args: any[]): any;

                removeListener(ev: any, fn: any): any;

                resume(): any;

                setEncoding(enc: any): any;

                unpipe(dest: any): any;

                unshift(chunk: any, encoding: any): any;

                wrap(stream: any): any;

                static Duplex: any;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static PassThrough: any;

                static Readable: any;

                static ReadableState: any;

                static Stream: any;

                static Transform: any;

                static Writable: any;

                static addAbortSignal: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static compose: any;

                static defaultMaxListeners: any;

                static destroy: any;

                static errorMonitor: any;

                static finished: any;

                static from: any;

                static getEventListeners: any;

                static init: any;

                static isDisturbed: any;

                static isErrored: any;

                static isReadable: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static pipeline: any;

                static promises: any;

                static setMaxListeners: any;

                static usingDomains: any;

                static wrap: any;

            }

            class Stream {
                constructor(opts: any);

                pipe(dest: any, options: any): any;

                static Duplex: any;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static PassThrough: any;

                static Readable: any;

                static Stream: any;

                static Transform: any;

                static Writable: any;

                static addAbortSignal: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static compose: any;

                static defaultMaxListeners: any;

                static destroy: any;

                static errorMonitor: any;

                static finished: any;

                static getEventListeners: any;

                static init: any;

                static isDisturbed: any;

                static isErrored: any;

                static isReadable: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static pipeline: any;

                static promises: any;

                static setMaxListeners: any;

                static usingDomains: any;

            }

            class Transform {
                constructor(options: any);

                static Duplex: any;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static PassThrough: any;

                static Readable: any;

                static ReadableState: any;

                static Stream: any;

                static Transform: any;

                static Writable: any;

                static addAbortSignal: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static compose: any;

                static defaultMaxListeners: any;

                static destroy: any;

                static errorMonitor: any;

                static finished: any;

                static from: any;

                static getEventListeners: any;

                static init: any;

                static isDisturbed: any;

                static isErrored: any;

                static isReadable: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static pipeline: any;

                static promises: any;

                static setMaxListeners: any;

                static usingDomains: any;

                static wrap: any;

            }

            class WritableState {
                constructor(options: any, stream: any, isDuplex: any);

                getBuffer(): any;

            }

            namespace promises {
                // Too-deep object hierarchy from fs.WriteStream.PassThrough.Writable.promises
                const finished: any;

                // Too-deep object hierarchy from fs.WriteStream.PassThrough.Writable.promises
                const pipeline: any;

            }

        }

        namespace promises {
            function finished(stream: any, opts: any): any;

            function pipeline(streams: any): any;

        }

    }

    namespace Readable {
        class Duplex {
            constructor(options: any);

            cork(): void;

            end(chunk: any, encoding: any, cb: any): any;

            setDefaultEncoding(encoding: any): any;

            uncork(): void;

            write(chunk: any, encoding: any, cb: any): any;

            static Duplex: any;

            static Readable: any;

            static addAbortSignal(signal: any, stream: any): any;

            static captureRejectionSymbol: any;

            static captureRejections: boolean;

            static compose(streams: any): any;

            static defaultMaxListeners: number;

            static destroy(stream: any, err: any): any;

            static errorMonitor: any;

            static finished(stream: any, options: any, callback: any, ...args: any[]): any;

            static from(body: any): any;

            static getEventListeners(emitterOrTarget: any, type: any): any;

            static init(opts: any): void;

            static isDisturbed(stream: any): any;

            static isErrored(stream: any): any;

            static isReadable(stream: any): any;

            static kMaxEventTargetListeners: any;

            static kMaxEventTargetListenersWarned: any;

            static listenerCount(emitter: any, type: any): any;

            static on(emitter: any, event: any, options: any): any;

            static once(emitter: any, name: any, options: any): any;

            static pipeline(streams: any): any;

            static setMaxListeners(n: any, eventTargets: any): void;

            static usingDomains: boolean;

            static wrap(src: any, options: any): any;

        }

        class EventEmitter {
            constructor(opts: any);

            addListener(type: any, listener: any): any;

            emit(type: any, args: any): any;

            eventNames(): any;

            getMaxListeners(): any;

            listenerCount(type: any): any;

            listeners(type: any): any;

            off(type: any, listener: any): any;

            on(type: any, listener: any): any;

            once(type: any, listener: any): any;

            prependListener(type: any, listener: any): any;

            prependOnceListener(type: any, listener: any): any;

            rawListeners(type: any): any;

            removeAllListeners(type: any, ...args: any[]): any;

            removeListener(type: any, listener: any): any;

            setMaxListeners(n: any): any;

            static EventEmitter: any;

            static captureRejectionSymbol: any;

            static captureRejections: boolean;

            static defaultMaxListeners: number;

            static errorMonitor: any;

            static getEventListeners(emitterOrTarget: any, type: any): any;

            static init(opts: any): void;

            static kMaxEventTargetListeners: any;

            static kMaxEventTargetListenersWarned: any;

            static listenerCount(emitter: any, type: any): any;

            static on(emitter: any, event: any, options: any): any;

            static once(emitter: any, name: any, options: any): any;

            static setMaxListeners(n: any, eventTargets: any): void;

            static usingDomains: boolean;

        }

        class EventEmitterAsyncResource {
            constructor(...args: any[]);

            emit(...args: any[]): void;

            emitDestroy(...args: any[]): void;

            static EventEmitterAsyncResource: any;

            static captureRejectionSymbol: any;

            static captureRejections: boolean;

            static defaultMaxListeners: number;

            static errorMonitor: any;

            static getEventListeners(emitterOrTarget: any, type: any): any;

            static init(opts: any): void;

            static kMaxEventTargetListeners: any;

            static kMaxEventTargetListenersWarned: any;

            static listenerCount(emitter: any, type: any): any;

            static on(emitter: any, event: any, options: any): any;

            static once(emitter: any, name: any, options: any): any;

            static setMaxListeners(n: any, eventTargets: any): void;

            static usingDomains: boolean;

        }

        class PassThrough {
            constructor(options: any);

            static PassThrough: any;

            static Readable: any;

            static addAbortSignal(signal: any, stream: any): any;

            static captureRejectionSymbol: any;

            static captureRejections: boolean;

            static compose(streams: any): any;

            static defaultMaxListeners: number;

            static destroy(stream: any, err: any): any;

            static errorMonitor: any;

            static finished(stream: any, options: any, callback: any, ...args: any[]): any;

            static from(body: any): any;

            static getEventListeners(emitterOrTarget: any, type: any): any;

            static init(opts: any): void;

            static isDisturbed(stream: any): any;

            static isErrored(stream: any): any;

            static isReadable(stream: any): any;

            static kMaxEventTargetListeners: any;

            static kMaxEventTargetListenersWarned: any;

            static listenerCount(emitter: any, type: any): any;

            static on(emitter: any, event: any, options: any): any;

            static once(emitter: any, name: any, options: any): any;

            static pipeline(streams: any): any;

            static setMaxListeners(n: any, eventTargets: any): void;

            static usingDomains: boolean;

            static wrap(src: any, options: any): any;

        }

        class ReadableState {
            constructor(options: any, stream: any, isDuplex: any);

        }

        class Stream {
            constructor(opts: any);

            pipe(dest: any, options: any): any;

            static Readable: any;

            static Stream: any;

            static addAbortSignal(signal: any, stream: any): any;

            static captureRejectionSymbol: any;

            static captureRejections: boolean;

            static compose(streams: any): any;

            static defaultMaxListeners: number;

            static destroy(stream: any, err: any): any;

            static errorMonitor: any;

            static finished(stream: any, options: any, callback: any, ...args: any[]): any;

            static getEventListeners(emitterOrTarget: any, type: any): any;

            static init(opts: any): void;

            static isDisturbed(stream: any): any;

            static isErrored(stream: any): any;

            static isReadable(stream: any): any;

            static kMaxEventTargetListeners: any;

            static kMaxEventTargetListenersWarned: any;

            static listenerCount(emitter: any, type: any): any;

            static on(emitter: any, event: any, options: any): any;

            static once(emitter: any, name: any, options: any): any;

            static pipeline(streams: any): any;

            static setMaxListeners(n: any, eventTargets: any): void;

            static usingDomains: boolean;

        }

        class Transform {
            constructor(options: any);

            static Readable: any;

            static Transform: any;

            static addAbortSignal(signal: any, stream: any): any;

            static captureRejectionSymbol: any;

            static captureRejections: boolean;

            static compose(streams: any): any;

            static defaultMaxListeners: number;

            static destroy(stream: any, err: any): any;

            static errorMonitor: any;

            static finished(stream: any, options: any, callback: any, ...args: any[]): any;

            static from(body: any): any;

            static getEventListeners(emitterOrTarget: any, type: any): any;

            static init(opts: any): void;

            static isDisturbed(stream: any): any;

            static isErrored(stream: any): any;

            static isReadable(stream: any): any;

            static kMaxEventTargetListeners: any;

            static kMaxEventTargetListenersWarned: any;

            static listenerCount(emitter: any, type: any): any;

            static on(emitter: any, event: any, options: any): any;

            static once(emitter: any, name: any, options: any): any;

            static pipeline(streams: any): any;

            static setMaxListeners(n: any, eventTargets: any): void;

            static usingDomains: boolean;

            static wrap(src: any, options: any): any;

        }

        class Writable {
            constructor(options: any);

            cork(): void;

            destroy(err: any, cb: any): any;

            end(chunk: any, encoding: any, cb: any): any;

            pipe(): void;

            setDefaultEncoding(encoding: any): any;

            uncork(): void;

            write(chunk: any, encoding: any, cb: any): any;

            static Readable: any;

            static Writable: any;

            static addAbortSignal(signal: any, stream: any): any;

            static captureRejectionSymbol: any;

            static captureRejections: boolean;

            static compose(streams: any): any;

            static defaultMaxListeners: number;

            static destroy(stream: any, err: any): any;

            static errorMonitor: any;

            static finished(stream: any, options: any, callback: any, ...args: any[]): any;

            static getEventListeners(emitterOrTarget: any, type: any): any;

            static init(opts: any): void;

            static isDisturbed(stream: any): any;

            static isErrored(stream: any): any;

            static isReadable(stream: any): any;

            static kMaxEventTargetListeners: any;

            static kMaxEventTargetListenersWarned: any;

            static listenerCount(emitter: any, type: any): any;

            static on(emitter: any, event: any, options: any): any;

            static once(emitter: any, name: any, options: any): any;

            static pipeline(streams: any): any;

            static setMaxListeners(n: any, eventTargets: any): void;

            static usingDomains: boolean;

        }

        namespace Duplex {
            class EventEmitter {
                constructor(opts: any);

                addListener(type: any, listener: any): any;

                emit(type: any, args: any): any;

                eventNames(): any;

                getMaxListeners(): any;

                listenerCount(type: any): any;

                listeners(type: any): any;

                off(type: any, listener: any): any;

                on(type: any, listener: any): any;

                once(type: any, listener: any): any;

                prependListener(type: any, listener: any): any;

                prependOnceListener(type: any, listener: any): any;

                rawListeners(type: any): any;

                removeAllListeners(type: any, ...args: any[]): any;

                removeListener(type: any, listener: any): any;

                setMaxListeners(n: any): any;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static defaultMaxListeners: any;

                static errorMonitor: any;

                static getEventListeners: any;

                static init: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static setMaxListeners: any;

                static usingDomains: any;

            }

            class EventEmitterAsyncResource {
                constructor(...args: any[]);

                emit(...args: any[]): void;

                emitDestroy(...args: any[]): void;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static defaultMaxListeners: any;

                static errorMonitor: any;

                static getEventListeners: any;

                static init: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static setMaxListeners: any;

                static usingDomains: any;

            }

            class PassThrough {
                constructor(options: any);

                static Duplex: any;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static PassThrough: any;

                static Readable: any;

                static ReadableState: any;

                static Stream: any;

                static Transform: any;

                static Writable: any;

                static addAbortSignal: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static compose: any;

                static defaultMaxListeners: any;

                static destroy: any;

                static errorMonitor: any;

                static finished: any;

                static from: any;

                static getEventListeners: any;

                static init: any;

                static isDisturbed: any;

                static isErrored: any;

                static isReadable: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static pipeline: any;

                static promises: any;

                static setMaxListeners: any;

                static usingDomains: any;

                static wrap: any;

            }

            class ReadableState {
                constructor(options: any, stream: any, isDuplex: any);

            }

            class Stream {
                constructor(opts: any);

                pipe(dest: any, options: any): any;

                static Duplex: any;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static PassThrough: any;

                static Readable: any;

                static Stream: any;

                static Transform: any;

                static Writable: any;

                static addAbortSignal: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static compose: any;

                static defaultMaxListeners: any;

                static destroy: any;

                static errorMonitor: any;

                static finished: any;

                static getEventListeners: any;

                static init: any;

                static isDisturbed: any;

                static isErrored: any;

                static isReadable: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static pipeline: any;

                static promises: any;

                static setMaxListeners: any;

                static usingDomains: any;

            }

            class Transform {
                constructor(options: any);

                static Duplex: any;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static PassThrough: any;

                static Readable: any;

                static ReadableState: any;

                static Stream: any;

                static Transform: any;

                static Writable: any;

                static addAbortSignal: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static compose: any;

                static defaultMaxListeners: any;

                static destroy: any;

                static errorMonitor: any;

                static finished: any;

                static from: any;

                static getEventListeners: any;

                static init: any;

                static isDisturbed: any;

                static isErrored: any;

                static isReadable: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static pipeline: any;

                static promises: any;

                static setMaxListeners: any;

                static usingDomains: any;

                static wrap: any;

            }

            class Writable {
                constructor(options: any);

                cork(): void;

                destroy(err: any, cb: any): any;

                end(chunk: any, encoding: any, cb: any): any;

                pipe(): void;

                setDefaultEncoding(encoding: any): any;

                uncork(): void;

                write(chunk: any, encoding: any, cb: any): any;

                static Duplex: any;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static PassThrough: any;

                static Readable: any;

                static Stream: any;

                static Transform: any;

                static Writable: any;

                static WritableState: any;

                static addAbortSignal: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static compose: any;

                static defaultMaxListeners: any;

                static destroy: any;

                static errorMonitor: any;

                static finished: any;

                static getEventListeners: any;

                static init: any;

                static isDisturbed: any;

                static isErrored: any;

                static isReadable: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static pipeline: any;

                static promises: any;

                static setMaxListeners: any;

                static usingDomains: any;

            }

            namespace promises {
                // Too-deep object hierarchy from fs.WriteStream.Readable.Duplex.promises
                const finished: any;

                // Too-deep object hierarchy from fs.WriteStream.Readable.Duplex.promises
                const pipeline: any;

            }

        }

        namespace EventEmitter {
            class EventEmitterAsyncResource {
                constructor(...args: any[]);

                emit(...args: any[]): void;

                emitDestroy(...args: any[]): void;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static defaultMaxListeners: any;

                static errorMonitor: any;

                static getEventListeners: any;

                static init: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static setMaxListeners: any;

                static usingDomains: any;

            }

        }

        namespace EventEmitterAsyncResource {
            class EventEmitter {
                constructor(opts: any);

                addListener(type: any, listener: any): any;

                emit(type: any, args: any): any;

                eventNames(): any;

                getMaxListeners(): any;

                listenerCount(type: any): any;

                listeners(type: any): any;

                off(type: any, listener: any): any;

                on(type: any, listener: any): any;

                once(type: any, listener: any): any;

                prependListener(type: any, listener: any): any;

                prependOnceListener(type: any, listener: any): any;

                rawListeners(type: any): any;

                removeAllListeners(type: any, ...args: any[]): any;

                removeListener(type: any, listener: any): any;

                setMaxListeners(n: any): any;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static defaultMaxListeners: any;

                static errorMonitor: any;

                static getEventListeners: any;

                static init: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static setMaxListeners: any;

                static usingDomains: any;

            }

        }

        namespace PassThrough {
            class Duplex {
                constructor(options: any);

                cork(): void;

                end(chunk: any, encoding: any, cb: any): any;

                setDefaultEncoding(encoding: any): any;

                uncork(): void;

                write(chunk: any, encoding: any, cb: any): any;

                static Duplex: any;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static PassThrough: any;

                static Readable: any;

                static ReadableState: any;

                static Stream: any;

                static Transform: any;

                static Writable: any;

                static addAbortSignal: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static compose: any;

                static defaultMaxListeners: any;

                static destroy: any;

                static errorMonitor: any;

                static finished: any;

                static from: any;

                static getEventListeners: any;

                static init: any;

                static isDisturbed: any;

                static isErrored: any;

                static isReadable: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static pipeline: any;

                static promises: any;

                static setMaxListeners: any;

                static usingDomains: any;

                static wrap: any;

            }

            class EventEmitter {
                constructor(opts: any);

                addListener(type: any, listener: any): any;

                emit(type: any, args: any): any;

                eventNames(): any;

                getMaxListeners(): any;

                listenerCount(type: any): any;

                listeners(type: any): any;

                off(type: any, listener: any): any;

                on(type: any, listener: any): any;

                once(type: any, listener: any): any;

                prependListener(type: any, listener: any): any;

                prependOnceListener(type: any, listener: any): any;

                rawListeners(type: any): any;

                removeAllListeners(type: any, ...args: any[]): any;

                removeListener(type: any, listener: any): any;

                setMaxListeners(n: any): any;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static defaultMaxListeners: any;

                static errorMonitor: any;

                static getEventListeners: any;

                static init: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static setMaxListeners: any;

                static usingDomains: any;

            }

            class EventEmitterAsyncResource {
                constructor(...args: any[]);

                emit(...args: any[]): void;

                emitDestroy(...args: any[]): void;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static defaultMaxListeners: any;

                static errorMonitor: any;

                static getEventListeners: any;

                static init: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static setMaxListeners: any;

                static usingDomains: any;

            }

            class ReadableState {
                constructor(options: any, stream: any, isDuplex: any);

            }

            class Stream {
                constructor(opts: any);

                pipe(dest: any, options: any): any;

                static Duplex: any;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static PassThrough: any;

                static Readable: any;

                static Stream: any;

                static Transform: any;

                static Writable: any;

                static addAbortSignal: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static compose: any;

                static defaultMaxListeners: any;

                static destroy: any;

                static errorMonitor: any;

                static finished: any;

                static getEventListeners: any;

                static init: any;

                static isDisturbed: any;

                static isErrored: any;

                static isReadable: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static pipeline: any;

                static promises: any;

                static setMaxListeners: any;

                static usingDomains: any;

            }

            class Transform {
                constructor(options: any);

                static Duplex: any;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static PassThrough: any;

                static Readable: any;

                static ReadableState: any;

                static Stream: any;

                static Transform: any;

                static Writable: any;

                static addAbortSignal: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static compose: any;

                static defaultMaxListeners: any;

                static destroy: any;

                static errorMonitor: any;

                static finished: any;

                static from: any;

                static getEventListeners: any;

                static init: any;

                static isDisturbed: any;

                static isErrored: any;

                static isReadable: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static pipeline: any;

                static promises: any;

                static setMaxListeners: any;

                static usingDomains: any;

                static wrap: any;

            }

            class Writable {
                constructor(options: any);

                cork(): void;

                destroy(err: any, cb: any): any;

                end(chunk: any, encoding: any, cb: any): any;

                pipe(): void;

                setDefaultEncoding(encoding: any): any;

                uncork(): void;

                write(chunk: any, encoding: any, cb: any): any;

                static Duplex: any;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static PassThrough: any;

                static Readable: any;

                static Stream: any;

                static Transform: any;

                static Writable: any;

                static WritableState: any;

                static addAbortSignal: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static compose: any;

                static defaultMaxListeners: any;

                static destroy: any;

                static errorMonitor: any;

                static finished: any;

                static getEventListeners: any;

                static init: any;

                static isDisturbed: any;

                static isErrored: any;

                static isReadable: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static pipeline: any;

                static promises: any;

                static setMaxListeners: any;

                static usingDomains: any;

            }

            namespace promises {
                // Too-deep object hierarchy from fs.WriteStream.Readable.PassThrough.promises
                const finished: any;

                // Too-deep object hierarchy from fs.WriteStream.Readable.PassThrough.promises
                const pipeline: any;

            }

        }

        namespace Stream {
            class Duplex {
                constructor(options: any);

                cork(): void;

                end(chunk: any, encoding: any, cb: any): any;

                setDefaultEncoding(encoding: any): any;

                uncork(): void;

                write(chunk: any, encoding: any, cb: any): any;

                static Duplex: any;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static PassThrough: any;

                static Readable: any;

                static ReadableState: any;

                static Stream: any;

                static Transform: any;

                static Writable: any;

                static addAbortSignal: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static compose: any;

                static defaultMaxListeners: any;

                static destroy: any;

                static errorMonitor: any;

                static finished: any;

                static from: any;

                static getEventListeners: any;

                static init: any;

                static isDisturbed: any;

                static isErrored: any;

                static isReadable: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static pipeline: any;

                static promises: any;

                static setMaxListeners: any;

                static usingDomains: any;

                static wrap: any;

            }

            class EventEmitter {
                constructor(opts: any);

                addListener(type: any, listener: any): any;

                emit(type: any, args: any): any;

                eventNames(): any;

                getMaxListeners(): any;

                listenerCount(type: any): any;

                listeners(type: any): any;

                off(type: any, listener: any): any;

                on(type: any, listener: any): any;

                once(type: any, listener: any): any;

                prependListener(type: any, listener: any): any;

                prependOnceListener(type: any, listener: any): any;

                rawListeners(type: any): any;

                removeAllListeners(type: any, ...args: any[]): any;

                removeListener(type: any, listener: any): any;

                setMaxListeners(n: any): any;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static defaultMaxListeners: any;

                static errorMonitor: any;

                static getEventListeners: any;

                static init: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static setMaxListeners: any;

                static usingDomains: any;

            }

            class EventEmitterAsyncResource {
                constructor(...args: any[]);

                emit(...args: any[]): void;

                emitDestroy(...args: any[]): void;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static defaultMaxListeners: any;

                static errorMonitor: any;

                static getEventListeners: any;

                static init: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static setMaxListeners: any;

                static usingDomains: any;

            }

            class PassThrough {
                constructor(options: any);

                static Duplex: any;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static PassThrough: any;

                static Readable: any;

                static ReadableState: any;

                static Stream: any;

                static Transform: any;

                static Writable: any;

                static addAbortSignal: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static compose: any;

                static defaultMaxListeners: any;

                static destroy: any;

                static errorMonitor: any;

                static finished: any;

                static from: any;

                static getEventListeners: any;

                static init: any;

                static isDisturbed: any;

                static isErrored: any;

                static isReadable: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static pipeline: any;

                static promises: any;

                static setMaxListeners: any;

                static usingDomains: any;

                static wrap: any;

            }

            class Transform {
                constructor(options: any);

                static Duplex: any;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static PassThrough: any;

                static Readable: any;

                static ReadableState: any;

                static Stream: any;

                static Transform: any;

                static Writable: any;

                static addAbortSignal: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static compose: any;

                static defaultMaxListeners: any;

                static destroy: any;

                static errorMonitor: any;

                static finished: any;

                static from: any;

                static getEventListeners: any;

                static init: any;

                static isDisturbed: any;

                static isErrored: any;

                static isReadable: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static pipeline: any;

                static promises: any;

                static setMaxListeners: any;

                static usingDomains: any;

                static wrap: any;

            }

            class Writable {
                constructor(options: any);

                cork(): void;

                destroy(err: any, cb: any): any;

                end(chunk: any, encoding: any, cb: any): any;

                pipe(): void;

                setDefaultEncoding(encoding: any): any;

                uncork(): void;

                write(chunk: any, encoding: any, cb: any): any;

                static Duplex: any;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static PassThrough: any;

                static Readable: any;

                static Stream: any;

                static Transform: any;

                static Writable: any;

                static WritableState: any;

                static addAbortSignal: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static compose: any;

                static defaultMaxListeners: any;

                static destroy: any;

                static errorMonitor: any;

                static finished: any;

                static getEventListeners: any;

                static init: any;

                static isDisturbed: any;

                static isErrored: any;

                static isReadable: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static pipeline: any;

                static promises: any;

                static setMaxListeners: any;

                static usingDomains: any;

            }

            namespace promises {
                // Too-deep object hierarchy from fs.WriteStream.Readable.Stream.promises
                const finished: any;

                // Too-deep object hierarchy from fs.WriteStream.Readable.Stream.promises
                const pipeline: any;

            }

        }

        namespace Transform {
            class Duplex {
                constructor(options: any);

                cork(): void;

                end(chunk: any, encoding: any, cb: any): any;

                setDefaultEncoding(encoding: any): any;

                uncork(): void;

                write(chunk: any, encoding: any, cb: any): any;

                static Duplex: any;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static PassThrough: any;

                static Readable: any;

                static ReadableState: any;

                static Stream: any;

                static Transform: any;

                static Writable: any;

                static addAbortSignal: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static compose: any;

                static defaultMaxListeners: any;

                static destroy: any;

                static errorMonitor: any;

                static finished: any;

                static from: any;

                static getEventListeners: any;

                static init: any;

                static isDisturbed: any;

                static isErrored: any;

                static isReadable: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static pipeline: any;

                static promises: any;

                static setMaxListeners: any;

                static usingDomains: any;

                static wrap: any;

            }

            class EventEmitter {
                constructor(opts: any);

                addListener(type: any, listener: any): any;

                emit(type: any, args: any): any;

                eventNames(): any;

                getMaxListeners(): any;

                listenerCount(type: any): any;

                listeners(type: any): any;

                off(type: any, listener: any): any;

                on(type: any, listener: any): any;

                once(type: any, listener: any): any;

                prependListener(type: any, listener: any): any;

                prependOnceListener(type: any, listener: any): any;

                rawListeners(type: any): any;

                removeAllListeners(type: any, ...args: any[]): any;

                removeListener(type: any, listener: any): any;

                setMaxListeners(n: any): any;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static defaultMaxListeners: any;

                static errorMonitor: any;

                static getEventListeners: any;

                static init: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static setMaxListeners: any;

                static usingDomains: any;

            }

            class EventEmitterAsyncResource {
                constructor(...args: any[]);

                emit(...args: any[]): void;

                emitDestroy(...args: any[]): void;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static defaultMaxListeners: any;

                static errorMonitor: any;

                static getEventListeners: any;

                static init: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static setMaxListeners: any;

                static usingDomains: any;

            }

            class PassThrough {
                constructor(options: any);

                static Duplex: any;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static PassThrough: any;

                static Readable: any;

                static ReadableState: any;

                static Stream: any;

                static Transform: any;

                static Writable: any;

                static addAbortSignal: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static compose: any;

                static defaultMaxListeners: any;

                static destroy: any;

                static errorMonitor: any;

                static finished: any;

                static from: any;

                static getEventListeners: any;

                static init: any;

                static isDisturbed: any;

                static isErrored: any;

                static isReadable: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static pipeline: any;

                static promises: any;

                static setMaxListeners: any;

                static usingDomains: any;

                static wrap: any;

            }

            class ReadableState {
                constructor(options: any, stream: any, isDuplex: any);

            }

            class Stream {
                constructor(opts: any);

                pipe(dest: any, options: any): any;

                static Duplex: any;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static PassThrough: any;

                static Readable: any;

                static Stream: any;

                static Transform: any;

                static Writable: any;

                static addAbortSignal: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static compose: any;

                static defaultMaxListeners: any;

                static destroy: any;

                static errorMonitor: any;

                static finished: any;

                static getEventListeners: any;

                static init: any;

                static isDisturbed: any;

                static isErrored: any;

                static isReadable: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static pipeline: any;

                static promises: any;

                static setMaxListeners: any;

                static usingDomains: any;

            }

            class Writable {
                constructor(options: any);

                cork(): void;

                destroy(err: any, cb: any): any;

                end(chunk: any, encoding: any, cb: any): any;

                pipe(): void;

                setDefaultEncoding(encoding: any): any;

                uncork(): void;

                write(chunk: any, encoding: any, cb: any): any;

                static Duplex: any;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static PassThrough: any;

                static Readable: any;

                static Stream: any;

                static Transform: any;

                static Writable: any;

                static WritableState: any;

                static addAbortSignal: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static compose: any;

                static defaultMaxListeners: any;

                static destroy: any;

                static errorMonitor: any;

                static finished: any;

                static getEventListeners: any;

                static init: any;

                static isDisturbed: any;

                static isErrored: any;

                static isReadable: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static pipeline: any;

                static promises: any;

                static setMaxListeners: any;

                static usingDomains: any;

            }

            namespace promises {
                // Too-deep object hierarchy from fs.WriteStream.Readable.Transform.promises
                const finished: any;

                // Too-deep object hierarchy from fs.WriteStream.Readable.Transform.promises
                const pipeline: any;

            }

        }

        namespace Writable {
            class Duplex {
                constructor(options: any);

                cork(): void;

                end(chunk: any, encoding: any, cb: any): any;

                setDefaultEncoding(encoding: any): any;

                uncork(): void;

                write(chunk: any, encoding: any, cb: any): any;

                static Duplex: any;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static PassThrough: any;

                static Readable: any;

                static ReadableState: any;

                static Stream: any;

                static Transform: any;

                static Writable: any;

                static addAbortSignal: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static compose: any;

                static defaultMaxListeners: any;

                static destroy: any;

                static errorMonitor: any;

                static finished: any;

                static from: any;

                static getEventListeners: any;

                static init: any;

                static isDisturbed: any;

                static isErrored: any;

                static isReadable: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static pipeline: any;

                static promises: any;

                static setMaxListeners: any;

                static usingDomains: any;

                static wrap: any;

            }

            class EventEmitter {
                constructor(opts: any);

                addListener(type: any, listener: any): any;

                emit(type: any, args: any): any;

                eventNames(): any;

                getMaxListeners(): any;

                listenerCount(type: any): any;

                listeners(type: any): any;

                off(type: any, listener: any): any;

                on(type: any, listener: any): any;

                once(type: any, listener: any): any;

                prependListener(type: any, listener: any): any;

                prependOnceListener(type: any, listener: any): any;

                rawListeners(type: any): any;

                removeAllListeners(type: any, ...args: any[]): any;

                removeListener(type: any, listener: any): any;

                setMaxListeners(n: any): any;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static defaultMaxListeners: any;

                static errorMonitor: any;

                static getEventListeners: any;

                static init: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static setMaxListeners: any;

                static usingDomains: any;

            }

            class EventEmitterAsyncResource {
                constructor(...args: any[]);

                emit(...args: any[]): void;

                emitDestroy(...args: any[]): void;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static defaultMaxListeners: any;

                static errorMonitor: any;

                static getEventListeners: any;

                static init: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static setMaxListeners: any;

                static usingDomains: any;

            }

            class PassThrough {
                constructor(options: any);

                static Duplex: any;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static PassThrough: any;

                static Readable: any;

                static ReadableState: any;

                static Stream: any;

                static Transform: any;

                static Writable: any;

                static addAbortSignal: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static compose: any;

                static defaultMaxListeners: any;

                static destroy: any;

                static errorMonitor: any;

                static finished: any;

                static from: any;

                static getEventListeners: any;

                static init: any;

                static isDisturbed: any;

                static isErrored: any;

                static isReadable: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static pipeline: any;

                static promises: any;

                static setMaxListeners: any;

                static usingDomains: any;

                static wrap: any;

            }

            class Stream {
                constructor(opts: any);

                pipe(dest: any, options: any): any;

                static Duplex: any;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static PassThrough: any;

                static Readable: any;

                static Stream: any;

                static Transform: any;

                static Writable: any;

                static addAbortSignal: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static compose: any;

                static defaultMaxListeners: any;

                static destroy: any;

                static errorMonitor: any;

                static finished: any;

                static getEventListeners: any;

                static init: any;

                static isDisturbed: any;

                static isErrored: any;

                static isReadable: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static pipeline: any;

                static promises: any;

                static setMaxListeners: any;

                static usingDomains: any;

            }

            class Transform {
                constructor(options: any);

                static Duplex: any;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static PassThrough: any;

                static Readable: any;

                static ReadableState: any;

                static Stream: any;

                static Transform: any;

                static Writable: any;

                static addAbortSignal: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static compose: any;

                static defaultMaxListeners: any;

                static destroy: any;

                static errorMonitor: any;

                static finished: any;

                static from: any;

                static getEventListeners: any;

                static init: any;

                static isDisturbed: any;

                static isErrored: any;

                static isReadable: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static pipeline: any;

                static promises: any;

                static setMaxListeners: any;

                static usingDomains: any;

                static wrap: any;

            }

            class WritableState {
                constructor(options: any, stream: any, isDuplex: any);

                getBuffer(): any;

            }

            namespace promises {
                // Too-deep object hierarchy from fs.WriteStream.Readable.Writable.promises
                const finished: any;

                // Too-deep object hierarchy from fs.WriteStream.Readable.Writable.promises
                const pipeline: any;

            }

        }

        namespace promises {
            function finished(stream: any, opts: any): any;

            function pipeline(streams: any): any;

        }

    }

    namespace Stream {
        class Duplex {
            constructor(options: any);

            cork(): void;

            end(chunk: any, encoding: any, cb: any): any;

            setDefaultEncoding(encoding: any): any;

            uncork(): void;

            write(chunk: any, encoding: any, cb: any): any;

            static Duplex: any;

            static Stream: any;

            static addAbortSignal(signal: any, stream: any): any;

            static captureRejectionSymbol: any;

            static captureRejections: boolean;

            static compose(streams: any): any;

            static defaultMaxListeners: number;

            static destroy(stream: any, err: any): any;

            static errorMonitor: any;

            static finished(stream: any, options: any, callback: any, ...args: any[]): any;

            static from(body: any): any;

            static getEventListeners(emitterOrTarget: any, type: any): any;

            static init(opts: any): void;

            static isDisturbed(stream: any): any;

            static isErrored(stream: any): any;

            static isReadable(stream: any): any;

            static kMaxEventTargetListeners: any;

            static kMaxEventTargetListenersWarned: any;

            static listenerCount(emitter: any, type: any): any;

            static on(emitter: any, event: any, options: any): any;

            static once(emitter: any, name: any, options: any): any;

            static pipeline(streams: any): any;

            static setMaxListeners(n: any, eventTargets: any): void;

            static usingDomains: boolean;

            static wrap(src: any, options: any): any;

        }

        class EventEmitter {
            constructor(opts: any);

            addListener(type: any, listener: any): any;

            emit(type: any, args: any): any;

            eventNames(): any;

            getMaxListeners(): any;

            listenerCount(type: any): any;

            listeners(type: any): any;

            off(type: any, listener: any): any;

            on(type: any, listener: any): any;

            once(type: any, listener: any): any;

            prependListener(type: any, listener: any): any;

            prependOnceListener(type: any, listener: any): any;

            rawListeners(type: any): any;

            removeAllListeners(type: any, ...args: any[]): any;

            removeListener(type: any, listener: any): any;

            setMaxListeners(n: any): any;

            static EventEmitter: any;

            static captureRejectionSymbol: any;

            static captureRejections: boolean;

            static defaultMaxListeners: number;

            static errorMonitor: any;

            static getEventListeners(emitterOrTarget: any, type: any): any;

            static init(opts: any): void;

            static kMaxEventTargetListeners: any;

            static kMaxEventTargetListenersWarned: any;

            static listenerCount(emitter: any, type: any): any;

            static on(emitter: any, event: any, options: any): any;

            static once(emitter: any, name: any, options: any): any;

            static setMaxListeners(n: any, eventTargets: any): void;

            static usingDomains: boolean;

        }

        class EventEmitterAsyncResource {
            constructor(...args: any[]);

            emit(...args: any[]): void;

            emitDestroy(...args: any[]): void;

            static EventEmitterAsyncResource: any;

            static captureRejectionSymbol: any;

            static captureRejections: boolean;

            static defaultMaxListeners: number;

            static errorMonitor: any;

            static getEventListeners(emitterOrTarget: any, type: any): any;

            static init(opts: any): void;

            static kMaxEventTargetListeners: any;

            static kMaxEventTargetListenersWarned: any;

            static listenerCount(emitter: any, type: any): any;

            static on(emitter: any, event: any, options: any): any;

            static once(emitter: any, name: any, options: any): any;

            static setMaxListeners(n: any, eventTargets: any): void;

            static usingDomains: boolean;

        }

        class PassThrough {
            constructor(options: any);

            static PassThrough: any;

            static Stream: any;

            static addAbortSignal(signal: any, stream: any): any;

            static captureRejectionSymbol: any;

            static captureRejections: boolean;

            static compose(streams: any): any;

            static defaultMaxListeners: number;

            static destroy(stream: any, err: any): any;

            static errorMonitor: any;

            static finished(stream: any, options: any, callback: any, ...args: any[]): any;

            static from(body: any): any;

            static getEventListeners(emitterOrTarget: any, type: any): any;

            static init(opts: any): void;

            static isDisturbed(stream: any): any;

            static isErrored(stream: any): any;

            static isReadable(stream: any): any;

            static kMaxEventTargetListeners: any;

            static kMaxEventTargetListenersWarned: any;

            static listenerCount(emitter: any, type: any): any;

            static on(emitter: any, event: any, options: any): any;

            static once(emitter: any, name: any, options: any): any;

            static pipeline(streams: any): any;

            static setMaxListeners(n: any, eventTargets: any): void;

            static usingDomains: boolean;

            static wrap(src: any, options: any): any;

        }

        class Readable {
            constructor(options: any);

            addListener(ev: any, fn: any): any;

            destroy(err: any, cb: any): any;

            filter(args: any): any;

            isPaused(): any;

            iterator(options: any): any;

            map(args: any): any;

            off(ev: any, fn: any): any;

            on(ev: any, fn: any): any;

            pause(): any;

            pipe(dest: any, pipeOpts: any): any;

            push(chunk: any, encoding: any): any;

            read(n: any): any;

            removeAllListeners(ev: any, ...args: any[]): any;

            removeListener(ev: any, fn: any): any;

            resume(): any;

            setEncoding(enc: any): any;

            unpipe(dest: any): any;

            unshift(chunk: any, encoding: any): any;

            wrap(stream: any): any;

            static Readable: any;

            static Stream: any;

            static addAbortSignal(signal: any, stream: any): any;

            static captureRejectionSymbol: any;

            static captureRejections: boolean;

            static compose(streams: any): any;

            static defaultMaxListeners: number;

            static destroy(stream: any, err: any): any;

            static errorMonitor: any;

            static finished(stream: any, options: any, callback: any, ...args: any[]): any;

            static from(iterable: any, opts: any): any;

            static getEventListeners(emitterOrTarget: any, type: any): any;

            static init(opts: any): void;

            static isDisturbed(stream: any): any;

            static isErrored(stream: any): any;

            static isReadable(stream: any): any;

            static kMaxEventTargetListeners: any;

            static kMaxEventTargetListenersWarned: any;

            static listenerCount(emitter: any, type: any): any;

            static on(emitter: any, event: any, options: any): any;

            static once(emitter: any, name: any, options: any): any;

            static pipeline(streams: any): any;

            static setMaxListeners(n: any, eventTargets: any): void;

            static usingDomains: boolean;

            static wrap(src: any, options: any): any;

        }

        class Transform {
            constructor(options: any);

            static Stream: any;

            static Transform: any;

            static addAbortSignal(signal: any, stream: any): any;

            static captureRejectionSymbol: any;

            static captureRejections: boolean;

            static compose(streams: any): any;

            static defaultMaxListeners: number;

            static destroy(stream: any, err: any): any;

            static errorMonitor: any;

            static finished(stream: any, options: any, callback: any, ...args: any[]): any;

            static from(body: any): any;

            static getEventListeners(emitterOrTarget: any, type: any): any;

            static init(opts: any): void;

            static isDisturbed(stream: any): any;

            static isErrored(stream: any): any;

            static isReadable(stream: any): any;

            static kMaxEventTargetListeners: any;

            static kMaxEventTargetListenersWarned: any;

            static listenerCount(emitter: any, type: any): any;

            static on(emitter: any, event: any, options: any): any;

            static once(emitter: any, name: any, options: any): any;

            static pipeline(streams: any): any;

            static setMaxListeners(n: any, eventTargets: any): void;

            static usingDomains: boolean;

            static wrap(src: any, options: any): any;

        }

        class Writable {
            constructor(options: any);

            cork(): void;

            destroy(err: any, cb: any): any;

            end(chunk: any, encoding: any, cb: any): any;

            pipe(): void;

            setDefaultEncoding(encoding: any): any;

            uncork(): void;

            write(chunk: any, encoding: any, cb: any): any;

            static Stream: any;

            static Writable: any;

            static addAbortSignal(signal: any, stream: any): any;

            static captureRejectionSymbol: any;

            static captureRejections: boolean;

            static compose(streams: any): any;

            static defaultMaxListeners: number;

            static destroy(stream: any, err: any): any;

            static errorMonitor: any;

            static finished(stream: any, options: any, callback: any, ...args: any[]): any;

            static getEventListeners(emitterOrTarget: any, type: any): any;

            static init(opts: any): void;

            static isDisturbed(stream: any): any;

            static isErrored(stream: any): any;

            static isReadable(stream: any): any;

            static kMaxEventTargetListeners: any;

            static kMaxEventTargetListenersWarned: any;

            static listenerCount(emitter: any, type: any): any;

            static on(emitter: any, event: any, options: any): any;

            static once(emitter: any, name: any, options: any): any;

            static pipeline(streams: any): any;

            static setMaxListeners(n: any, eventTargets: any): void;

            static usingDomains: boolean;

        }

        namespace Duplex {
            class EventEmitter {
                constructor(opts: any);

                addListener(type: any, listener: any): any;

                emit(type: any, args: any): any;

                eventNames(): any;

                getMaxListeners(): any;

                listenerCount(type: any): any;

                listeners(type: any): any;

                off(type: any, listener: any): any;

                on(type: any, listener: any): any;

                once(type: any, listener: any): any;

                prependListener(type: any, listener: any): any;

                prependOnceListener(type: any, listener: any): any;

                rawListeners(type: any): any;

                removeAllListeners(type: any, ...args: any[]): any;

                removeListener(type: any, listener: any): any;

                setMaxListeners(n: any): any;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static defaultMaxListeners: any;

                static errorMonitor: any;

                static getEventListeners: any;

                static init: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static setMaxListeners: any;

                static usingDomains: any;

            }

            class EventEmitterAsyncResource {
                constructor(...args: any[]);

                emit(...args: any[]): void;

                emitDestroy(...args: any[]): void;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static defaultMaxListeners: any;

                static errorMonitor: any;

                static getEventListeners: any;

                static init: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static setMaxListeners: any;

                static usingDomains: any;

            }

            class PassThrough {
                constructor(options: any);

                static Duplex: any;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static PassThrough: any;

                static Readable: any;

                static ReadableState: any;

                static Stream: any;

                static Transform: any;

                static Writable: any;

                static addAbortSignal: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static compose: any;

                static defaultMaxListeners: any;

                static destroy: any;

                static errorMonitor: any;

                static finished: any;

                static from: any;

                static getEventListeners: any;

                static init: any;

                static isDisturbed: any;

                static isErrored: any;

                static isReadable: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static pipeline: any;

                static promises: any;

                static setMaxListeners: any;

                static usingDomains: any;

                static wrap: any;

            }

            class Readable {
                constructor(options: any);

                addListener(ev: any, fn: any): any;

                destroy(err: any, cb: any): any;

                filter(args: any): any;

                isPaused(): any;

                iterator(options: any): any;

                map(args: any): any;

                off(ev: any, fn: any): any;

                on(ev: any, fn: any): any;

                pause(): any;

                pipe(dest: any, pipeOpts: any): any;

                push(chunk: any, encoding: any): any;

                read(n: any): any;

                removeAllListeners(ev: any, ...args: any[]): any;

                removeListener(ev: any, fn: any): any;

                resume(): any;

                setEncoding(enc: any): any;

                unpipe(dest: any): any;

                unshift(chunk: any, encoding: any): any;

                wrap(stream: any): any;

                static Duplex: any;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static PassThrough: any;

                static Readable: any;

                static ReadableState: any;

                static Stream: any;

                static Transform: any;

                static Writable: any;

                static addAbortSignal: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static compose: any;

                static defaultMaxListeners: any;

                static destroy: any;

                static errorMonitor: any;

                static finished: any;

                static from: any;

                static getEventListeners: any;

                static init: any;

                static isDisturbed: any;

                static isErrored: any;

                static isReadable: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static pipeline: any;

                static promises: any;

                static setMaxListeners: any;

                static usingDomains: any;

                static wrap: any;

            }

            class ReadableState {
                constructor(options: any, stream: any, isDuplex: any);

            }

            class Transform {
                constructor(options: any);

                static Duplex: any;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static PassThrough: any;

                static Readable: any;

                static ReadableState: any;

                static Stream: any;

                static Transform: any;

                static Writable: any;

                static addAbortSignal: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static compose: any;

                static defaultMaxListeners: any;

                static destroy: any;

                static errorMonitor: any;

                static finished: any;

                static from: any;

                static getEventListeners: any;

                static init: any;

                static isDisturbed: any;

                static isErrored: any;

                static isReadable: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static pipeline: any;

                static promises: any;

                static setMaxListeners: any;

                static usingDomains: any;

                static wrap: any;

            }

            class Writable {
                constructor(options: any);

                cork(): void;

                destroy(err: any, cb: any): any;

                end(chunk: any, encoding: any, cb: any): any;

                pipe(): void;

                setDefaultEncoding(encoding: any): any;

                uncork(): void;

                write(chunk: any, encoding: any, cb: any): any;

                static Duplex: any;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static PassThrough: any;

                static Readable: any;

                static Stream: any;

                static Transform: any;

                static Writable: any;

                static WritableState: any;

                static addAbortSignal: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static compose: any;

                static defaultMaxListeners: any;

                static destroy: any;

                static errorMonitor: any;

                static finished: any;

                static getEventListeners: any;

                static init: any;

                static isDisturbed: any;

                static isErrored: any;

                static isReadable: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static pipeline: any;

                static promises: any;

                static setMaxListeners: any;

                static usingDomains: any;

            }

            namespace promises {
                // Too-deep object hierarchy from fs.WriteStream.Stream.Duplex.promises
                const finished: any;

                // Too-deep object hierarchy from fs.WriteStream.Stream.Duplex.promises
                const pipeline: any;

            }

        }

        namespace EventEmitter {
            class EventEmitterAsyncResource {
                constructor(...args: any[]);

                emit(...args: any[]): void;

                emitDestroy(...args: any[]): void;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static defaultMaxListeners: any;

                static errorMonitor: any;

                static getEventListeners: any;

                static init: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static setMaxListeners: any;

                static usingDomains: any;

            }

        }

        namespace EventEmitterAsyncResource {
            class EventEmitter {
                constructor(opts: any);

                addListener(type: any, listener: any): any;

                emit(type: any, args: any): any;

                eventNames(): any;

                getMaxListeners(): any;

                listenerCount(type: any): any;

                listeners(type: any): any;

                off(type: any, listener: any): any;

                on(type: any, listener: any): any;

                once(type: any, listener: any): any;

                prependListener(type: any, listener: any): any;

                prependOnceListener(type: any, listener: any): any;

                rawListeners(type: any): any;

                removeAllListeners(type: any, ...args: any[]): any;

                removeListener(type: any, listener: any): any;

                setMaxListeners(n: any): any;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static defaultMaxListeners: any;

                static errorMonitor: any;

                static getEventListeners: any;

                static init: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static setMaxListeners: any;

                static usingDomains: any;

            }

        }

        namespace PassThrough {
            class Duplex {
                constructor(options: any);

                cork(): void;

                end(chunk: any, encoding: any, cb: any): any;

                setDefaultEncoding(encoding: any): any;

                uncork(): void;

                write(chunk: any, encoding: any, cb: any): any;

                static Duplex: any;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static PassThrough: any;

                static Readable: any;

                static ReadableState: any;

                static Stream: any;

                static Transform: any;

                static Writable: any;

                static addAbortSignal: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static compose: any;

                static defaultMaxListeners: any;

                static destroy: any;

                static errorMonitor: any;

                static finished: any;

                static from: any;

                static getEventListeners: any;

                static init: any;

                static isDisturbed: any;

                static isErrored: any;

                static isReadable: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static pipeline: any;

                static promises: any;

                static setMaxListeners: any;

                static usingDomains: any;

                static wrap: any;

            }

            class EventEmitter {
                constructor(opts: any);

                addListener(type: any, listener: any): any;

                emit(type: any, args: any): any;

                eventNames(): any;

                getMaxListeners(): any;

                listenerCount(type: any): any;

                listeners(type: any): any;

                off(type: any, listener: any): any;

                on(type: any, listener: any): any;

                once(type: any, listener: any): any;

                prependListener(type: any, listener: any): any;

                prependOnceListener(type: any, listener: any): any;

                rawListeners(type: any): any;

                removeAllListeners(type: any, ...args: any[]): any;

                removeListener(type: any, listener: any): any;

                setMaxListeners(n: any): any;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static defaultMaxListeners: any;

                static errorMonitor: any;

                static getEventListeners: any;

                static init: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static setMaxListeners: any;

                static usingDomains: any;

            }

            class EventEmitterAsyncResource {
                constructor(...args: any[]);

                emit(...args: any[]): void;

                emitDestroy(...args: any[]): void;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static defaultMaxListeners: any;

                static errorMonitor: any;

                static getEventListeners: any;

                static init: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static setMaxListeners: any;

                static usingDomains: any;

            }

            class Readable {
                constructor(options: any);

                addListener(ev: any, fn: any): any;

                destroy(err: any, cb: any): any;

                filter(args: any): any;

                isPaused(): any;

                iterator(options: any): any;

                map(args: any): any;

                off(ev: any, fn: any): any;

                on(ev: any, fn: any): any;

                pause(): any;

                pipe(dest: any, pipeOpts: any): any;

                push(chunk: any, encoding: any): any;

                read(n: any): any;

                removeAllListeners(ev: any, ...args: any[]): any;

                removeListener(ev: any, fn: any): any;

                resume(): any;

                setEncoding(enc: any): any;

                unpipe(dest: any): any;

                unshift(chunk: any, encoding: any): any;

                wrap(stream: any): any;

                static Duplex: any;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static PassThrough: any;

                static Readable: any;

                static ReadableState: any;

                static Stream: any;

                static Transform: any;

                static Writable: any;

                static addAbortSignal: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static compose: any;

                static defaultMaxListeners: any;

                static destroy: any;

                static errorMonitor: any;

                static finished: any;

                static from: any;

                static getEventListeners: any;

                static init: any;

                static isDisturbed: any;

                static isErrored: any;

                static isReadable: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static pipeline: any;

                static promises: any;

                static setMaxListeners: any;

                static usingDomains: any;

                static wrap: any;

            }

            class ReadableState {
                constructor(options: any, stream: any, isDuplex: any);

            }

            class Transform {
                constructor(options: any);

                static Duplex: any;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static PassThrough: any;

                static Readable: any;

                static ReadableState: any;

                static Stream: any;

                static Transform: any;

                static Writable: any;

                static addAbortSignal: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static compose: any;

                static defaultMaxListeners: any;

                static destroy: any;

                static errorMonitor: any;

                static finished: any;

                static from: any;

                static getEventListeners: any;

                static init: any;

                static isDisturbed: any;

                static isErrored: any;

                static isReadable: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static pipeline: any;

                static promises: any;

                static setMaxListeners: any;

                static usingDomains: any;

                static wrap: any;

            }

            class Writable {
                constructor(options: any);

                cork(): void;

                destroy(err: any, cb: any): any;

                end(chunk: any, encoding: any, cb: any): any;

                pipe(): void;

                setDefaultEncoding(encoding: any): any;

                uncork(): void;

                write(chunk: any, encoding: any, cb: any): any;

                static Duplex: any;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static PassThrough: any;

                static Readable: any;

                static Stream: any;

                static Transform: any;

                static Writable: any;

                static WritableState: any;

                static addAbortSignal: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static compose: any;

                static defaultMaxListeners: any;

                static destroy: any;

                static errorMonitor: any;

                static finished: any;

                static getEventListeners: any;

                static init: any;

                static isDisturbed: any;

                static isErrored: any;

                static isReadable: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static pipeline: any;

                static promises: any;

                static setMaxListeners: any;

                static usingDomains: any;

            }

            namespace promises {
                // Too-deep object hierarchy from fs.WriteStream.Stream.PassThrough.promises
                const finished: any;

                // Too-deep object hierarchy from fs.WriteStream.Stream.PassThrough.promises
                const pipeline: any;

            }

        }

        namespace Readable {
            class Duplex {
                constructor(options: any);

                cork(): void;

                end(chunk: any, encoding: any, cb: any): any;

                setDefaultEncoding(encoding: any): any;

                uncork(): void;

                write(chunk: any, encoding: any, cb: any): any;

                static Duplex: any;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static PassThrough: any;

                static Readable: any;

                static ReadableState: any;

                static Stream: any;

                static Transform: any;

                static Writable: any;

                static addAbortSignal: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static compose: any;

                static defaultMaxListeners: any;

                static destroy: any;

                static errorMonitor: any;

                static finished: any;

                static from: any;

                static getEventListeners: any;

                static init: any;

                static isDisturbed: any;

                static isErrored: any;

                static isReadable: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static pipeline: any;

                static promises: any;

                static setMaxListeners: any;

                static usingDomains: any;

                static wrap: any;

            }

            class EventEmitter {
                constructor(opts: any);

                addListener(type: any, listener: any): any;

                emit(type: any, args: any): any;

                eventNames(): any;

                getMaxListeners(): any;

                listenerCount(type: any): any;

                listeners(type: any): any;

                off(type: any, listener: any): any;

                on(type: any, listener: any): any;

                once(type: any, listener: any): any;

                prependListener(type: any, listener: any): any;

                prependOnceListener(type: any, listener: any): any;

                rawListeners(type: any): any;

                removeAllListeners(type: any, ...args: any[]): any;

                removeListener(type: any, listener: any): any;

                setMaxListeners(n: any): any;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static defaultMaxListeners: any;

                static errorMonitor: any;

                static getEventListeners: any;

                static init: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static setMaxListeners: any;

                static usingDomains: any;

            }

            class EventEmitterAsyncResource {
                constructor(...args: any[]);

                emit(...args: any[]): void;

                emitDestroy(...args: any[]): void;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static defaultMaxListeners: any;

                static errorMonitor: any;

                static getEventListeners: any;

                static init: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static setMaxListeners: any;

                static usingDomains: any;

            }

            class PassThrough {
                constructor(options: any);

                static Duplex: any;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static PassThrough: any;

                static Readable: any;

                static ReadableState: any;

                static Stream: any;

                static Transform: any;

                static Writable: any;

                static addAbortSignal: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static compose: any;

                static defaultMaxListeners: any;

                static destroy: any;

                static errorMonitor: any;

                static finished: any;

                static from: any;

                static getEventListeners: any;

                static init: any;

                static isDisturbed: any;

                static isErrored: any;

                static isReadable: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static pipeline: any;

                static promises: any;

                static setMaxListeners: any;

                static usingDomains: any;

                static wrap: any;

            }

            class ReadableState {
                constructor(options: any, stream: any, isDuplex: any);

            }

            class Transform {
                constructor(options: any);

                static Duplex: any;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static PassThrough: any;

                static Readable: any;

                static ReadableState: any;

                static Stream: any;

                static Transform: any;

                static Writable: any;

                static addAbortSignal: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static compose: any;

                static defaultMaxListeners: any;

                static destroy: any;

                static errorMonitor: any;

                static finished: any;

                static from: any;

                static getEventListeners: any;

                static init: any;

                static isDisturbed: any;

                static isErrored: any;

                static isReadable: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static pipeline: any;

                static promises: any;

                static setMaxListeners: any;

                static usingDomains: any;

                static wrap: any;

            }

            class Writable {
                constructor(options: any);

                cork(): void;

                destroy(err: any, cb: any): any;

                end(chunk: any, encoding: any, cb: any): any;

                pipe(): void;

                setDefaultEncoding(encoding: any): any;

                uncork(): void;

                write(chunk: any, encoding: any, cb: any): any;

                static Duplex: any;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static PassThrough: any;

                static Readable: any;

                static Stream: any;

                static Transform: any;

                static Writable: any;

                static WritableState: any;

                static addAbortSignal: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static compose: any;

                static defaultMaxListeners: any;

                static destroy: any;

                static errorMonitor: any;

                static finished: any;

                static getEventListeners: any;

                static init: any;

                static isDisturbed: any;

                static isErrored: any;

                static isReadable: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static pipeline: any;

                static promises: any;

                static setMaxListeners: any;

                static usingDomains: any;

            }

            namespace promises {
                // Too-deep object hierarchy from fs.WriteStream.Stream.Readable.promises
                const finished: any;

                // Too-deep object hierarchy from fs.WriteStream.Stream.Readable.promises
                const pipeline: any;

            }

        }

        namespace Transform {
            class Duplex {
                constructor(options: any);

                cork(): void;

                end(chunk: any, encoding: any, cb: any): any;

                setDefaultEncoding(encoding: any): any;

                uncork(): void;

                write(chunk: any, encoding: any, cb: any): any;

                static Duplex: any;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static PassThrough: any;

                static Readable: any;

                static ReadableState: any;

                static Stream: any;

                static Transform: any;

                static Writable: any;

                static addAbortSignal: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static compose: any;

                static defaultMaxListeners: any;

                static destroy: any;

                static errorMonitor: any;

                static finished: any;

                static from: any;

                static getEventListeners: any;

                static init: any;

                static isDisturbed: any;

                static isErrored: any;

                static isReadable: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static pipeline: any;

                static promises: any;

                static setMaxListeners: any;

                static usingDomains: any;

                static wrap: any;

            }

            class EventEmitter {
                constructor(opts: any);

                addListener(type: any, listener: any): any;

                emit(type: any, args: any): any;

                eventNames(): any;

                getMaxListeners(): any;

                listenerCount(type: any): any;

                listeners(type: any): any;

                off(type: any, listener: any): any;

                on(type: any, listener: any): any;

                once(type: any, listener: any): any;

                prependListener(type: any, listener: any): any;

                prependOnceListener(type: any, listener: any): any;

                rawListeners(type: any): any;

                removeAllListeners(type: any, ...args: any[]): any;

                removeListener(type: any, listener: any): any;

                setMaxListeners(n: any): any;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static defaultMaxListeners: any;

                static errorMonitor: any;

                static getEventListeners: any;

                static init: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static setMaxListeners: any;

                static usingDomains: any;

            }

            class EventEmitterAsyncResource {
                constructor(...args: any[]);

                emit(...args: any[]): void;

                emitDestroy(...args: any[]): void;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static defaultMaxListeners: any;

                static errorMonitor: any;

                static getEventListeners: any;

                static init: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static setMaxListeners: any;

                static usingDomains: any;

            }

            class PassThrough {
                constructor(options: any);

                static Duplex: any;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static PassThrough: any;

                static Readable: any;

                static ReadableState: any;

                static Stream: any;

                static Transform: any;

                static Writable: any;

                static addAbortSignal: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static compose: any;

                static defaultMaxListeners: any;

                static destroy: any;

                static errorMonitor: any;

                static finished: any;

                static from: any;

                static getEventListeners: any;

                static init: any;

                static isDisturbed: any;

                static isErrored: any;

                static isReadable: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static pipeline: any;

                static promises: any;

                static setMaxListeners: any;

                static usingDomains: any;

                static wrap: any;

            }

            class Readable {
                constructor(options: any);

                addListener(ev: any, fn: any): any;

                destroy(err: any, cb: any): any;

                filter(args: any): any;

                isPaused(): any;

                iterator(options: any): any;

                map(args: any): any;

                off(ev: any, fn: any): any;

                on(ev: any, fn: any): any;

                pause(): any;

                pipe(dest: any, pipeOpts: any): any;

                push(chunk: any, encoding: any): any;

                read(n: any): any;

                removeAllListeners(ev: any, ...args: any[]): any;

                removeListener(ev: any, fn: any): any;

                resume(): any;

                setEncoding(enc: any): any;

                unpipe(dest: any): any;

                unshift(chunk: any, encoding: any): any;

                wrap(stream: any): any;

                static Duplex: any;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static PassThrough: any;

                static Readable: any;

                static ReadableState: any;

                static Stream: any;

                static Transform: any;

                static Writable: any;

                static addAbortSignal: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static compose: any;

                static defaultMaxListeners: any;

                static destroy: any;

                static errorMonitor: any;

                static finished: any;

                static from: any;

                static getEventListeners: any;

                static init: any;

                static isDisturbed: any;

                static isErrored: any;

                static isReadable: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static pipeline: any;

                static promises: any;

                static setMaxListeners: any;

                static usingDomains: any;

                static wrap: any;

            }

            class ReadableState {
                constructor(options: any, stream: any, isDuplex: any);

            }

            class Writable {
                constructor(options: any);

                cork(): void;

                destroy(err: any, cb: any): any;

                end(chunk: any, encoding: any, cb: any): any;

                pipe(): void;

                setDefaultEncoding(encoding: any): any;

                uncork(): void;

                write(chunk: any, encoding: any, cb: any): any;

                static Duplex: any;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static PassThrough: any;

                static Readable: any;

                static Stream: any;

                static Transform: any;

                static Writable: any;

                static WritableState: any;

                static addAbortSignal: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static compose: any;

                static defaultMaxListeners: any;

                static destroy: any;

                static errorMonitor: any;

                static finished: any;

                static getEventListeners: any;

                static init: any;

                static isDisturbed: any;

                static isErrored: any;

                static isReadable: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static pipeline: any;

                static promises: any;

                static setMaxListeners: any;

                static usingDomains: any;

            }

            namespace promises {
                // Too-deep object hierarchy from fs.WriteStream.Stream.Transform.promises
                const finished: any;

                // Too-deep object hierarchy from fs.WriteStream.Stream.Transform.promises
                const pipeline: any;

            }

        }

        namespace Writable {
            class Duplex {
                constructor(options: any);

                cork(): void;

                end(chunk: any, encoding: any, cb: any): any;

                setDefaultEncoding(encoding: any): any;

                uncork(): void;

                write(chunk: any, encoding: any, cb: any): any;

                static Duplex: any;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static PassThrough: any;

                static Readable: any;

                static ReadableState: any;

                static Stream: any;

                static Transform: any;

                static Writable: any;

                static addAbortSignal: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static compose: any;

                static defaultMaxListeners: any;

                static destroy: any;

                static errorMonitor: any;

                static finished: any;

                static from: any;

                static getEventListeners: any;

                static init: any;

                static isDisturbed: any;

                static isErrored: any;

                static isReadable: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static pipeline: any;

                static promises: any;

                static setMaxListeners: any;

                static usingDomains: any;

                static wrap: any;

            }

            class EventEmitter {
                constructor(opts: any);

                addListener(type: any, listener: any): any;

                emit(type: any, args: any): any;

                eventNames(): any;

                getMaxListeners(): any;

                listenerCount(type: any): any;

                listeners(type: any): any;

                off(type: any, listener: any): any;

                on(type: any, listener: any): any;

                once(type: any, listener: any): any;

                prependListener(type: any, listener: any): any;

                prependOnceListener(type: any, listener: any): any;

                rawListeners(type: any): any;

                removeAllListeners(type: any, ...args: any[]): any;

                removeListener(type: any, listener: any): any;

                setMaxListeners(n: any): any;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static defaultMaxListeners: any;

                static errorMonitor: any;

                static getEventListeners: any;

                static init: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static setMaxListeners: any;

                static usingDomains: any;

            }

            class EventEmitterAsyncResource {
                constructor(...args: any[]);

                emit(...args: any[]): void;

                emitDestroy(...args: any[]): void;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static defaultMaxListeners: any;

                static errorMonitor: any;

                static getEventListeners: any;

                static init: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static setMaxListeners: any;

                static usingDomains: any;

            }

            class PassThrough {
                constructor(options: any);

                static Duplex: any;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static PassThrough: any;

                static Readable: any;

                static ReadableState: any;

                static Stream: any;

                static Transform: any;

                static Writable: any;

                static addAbortSignal: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static compose: any;

                static defaultMaxListeners: any;

                static destroy: any;

                static errorMonitor: any;

                static finished: any;

                static from: any;

                static getEventListeners: any;

                static init: any;

                static isDisturbed: any;

                static isErrored: any;

                static isReadable: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static pipeline: any;

                static promises: any;

                static setMaxListeners: any;

                static usingDomains: any;

                static wrap: any;

            }

            class Readable {
                constructor(options: any);

                addListener(ev: any, fn: any): any;

                destroy(err: any, cb: any): any;

                filter(args: any): any;

                isPaused(): any;

                iterator(options: any): any;

                map(args: any): any;

                off(ev: any, fn: any): any;

                on(ev: any, fn: any): any;

                pause(): any;

                pipe(dest: any, pipeOpts: any): any;

                push(chunk: any, encoding: any): any;

                read(n: any): any;

                removeAllListeners(ev: any, ...args: any[]): any;

                removeListener(ev: any, fn: any): any;

                resume(): any;

                setEncoding(enc: any): any;

                unpipe(dest: any): any;

                unshift(chunk: any, encoding: any): any;

                wrap(stream: any): any;

                static Duplex: any;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static PassThrough: any;

                static Readable: any;

                static ReadableState: any;

                static Stream: any;

                static Transform: any;

                static Writable: any;

                static addAbortSignal: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static compose: any;

                static defaultMaxListeners: any;

                static destroy: any;

                static errorMonitor: any;

                static finished: any;

                static from: any;

                static getEventListeners: any;

                static init: any;

                static isDisturbed: any;

                static isErrored: any;

                static isReadable: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static pipeline: any;

                static promises: any;

                static setMaxListeners: any;

                static usingDomains: any;

                static wrap: any;

            }

            class Transform {
                constructor(options: any);

                static Duplex: any;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static PassThrough: any;

                static Readable: any;

                static ReadableState: any;

                static Stream: any;

                static Transform: any;

                static Writable: any;

                static addAbortSignal: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static compose: any;

                static defaultMaxListeners: any;

                static destroy: any;

                static errorMonitor: any;

                static finished: any;

                static from: any;

                static getEventListeners: any;

                static init: any;

                static isDisturbed: any;

                static isErrored: any;

                static isReadable: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static pipeline: any;

                static promises: any;

                static setMaxListeners: any;

                static usingDomains: any;

                static wrap: any;

            }

            class WritableState {
                constructor(options: any, stream: any, isDuplex: any);

                getBuffer(): any;

            }

            namespace promises {
                // Too-deep object hierarchy from fs.WriteStream.Stream.Writable.promises
                const finished: any;

                // Too-deep object hierarchy from fs.WriteStream.Stream.Writable.promises
                const pipeline: any;

            }

        }

        namespace promises {
            function finished(stream: any, opts: any): any;

            function pipeline(streams: any): any;

        }

    }

    namespace Transform {
        class Duplex {
            constructor(options: any);

            cork(): void;

            end(chunk: any, encoding: any, cb: any): any;

            setDefaultEncoding(encoding: any): any;

            uncork(): void;

            write(chunk: any, encoding: any, cb: any): any;

            static Duplex: any;

            static Transform: any;

            static addAbortSignal(signal: any, stream: any): any;

            static captureRejectionSymbol: any;

            static captureRejections: boolean;

            static compose(streams: any): any;

            static defaultMaxListeners: number;

            static destroy(stream: any, err: any): any;

            static errorMonitor: any;

            static finished(stream: any, options: any, callback: any, ...args: any[]): any;

            static from(body: any): any;

            static getEventListeners(emitterOrTarget: any, type: any): any;

            static init(opts: any): void;

            static isDisturbed(stream: any): any;

            static isErrored(stream: any): any;

            static isReadable(stream: any): any;

            static kMaxEventTargetListeners: any;

            static kMaxEventTargetListenersWarned: any;

            static listenerCount(emitter: any, type: any): any;

            static on(emitter: any, event: any, options: any): any;

            static once(emitter: any, name: any, options: any): any;

            static pipeline(streams: any): any;

            static setMaxListeners(n: any, eventTargets: any): void;

            static usingDomains: boolean;

            static wrap(src: any, options: any): any;

        }

        class EventEmitter {
            constructor(opts: any);

            addListener(type: any, listener: any): any;

            emit(type: any, args: any): any;

            eventNames(): any;

            getMaxListeners(): any;

            listenerCount(type: any): any;

            listeners(type: any): any;

            off(type: any, listener: any): any;

            on(type: any, listener: any): any;

            once(type: any, listener: any): any;

            prependListener(type: any, listener: any): any;

            prependOnceListener(type: any, listener: any): any;

            rawListeners(type: any): any;

            removeAllListeners(type: any, ...args: any[]): any;

            removeListener(type: any, listener: any): any;

            setMaxListeners(n: any): any;

            static EventEmitter: any;

            static captureRejectionSymbol: any;

            static captureRejections: boolean;

            static defaultMaxListeners: number;

            static errorMonitor: any;

            static getEventListeners(emitterOrTarget: any, type: any): any;

            static init(opts: any): void;

            static kMaxEventTargetListeners: any;

            static kMaxEventTargetListenersWarned: any;

            static listenerCount(emitter: any, type: any): any;

            static on(emitter: any, event: any, options: any): any;

            static once(emitter: any, name: any, options: any): any;

            static setMaxListeners(n: any, eventTargets: any): void;

            static usingDomains: boolean;

        }

        class EventEmitterAsyncResource {
            constructor(...args: any[]);

            emit(...args: any[]): void;

            emitDestroy(...args: any[]): void;

            static EventEmitterAsyncResource: any;

            static captureRejectionSymbol: any;

            static captureRejections: boolean;

            static defaultMaxListeners: number;

            static errorMonitor: any;

            static getEventListeners(emitterOrTarget: any, type: any): any;

            static init(opts: any): void;

            static kMaxEventTargetListeners: any;

            static kMaxEventTargetListenersWarned: any;

            static listenerCount(emitter: any, type: any): any;

            static on(emitter: any, event: any, options: any): any;

            static once(emitter: any, name: any, options: any): any;

            static setMaxListeners(n: any, eventTargets: any): void;

            static usingDomains: boolean;

        }

        class PassThrough {
            constructor(options: any);

            static PassThrough: any;

            static Transform: any;

            static addAbortSignal(signal: any, stream: any): any;

            static captureRejectionSymbol: any;

            static captureRejections: boolean;

            static compose(streams: any): any;

            static defaultMaxListeners: number;

            static destroy(stream: any, err: any): any;

            static errorMonitor: any;

            static finished(stream: any, options: any, callback: any, ...args: any[]): any;

            static from(body: any): any;

            static getEventListeners(emitterOrTarget: any, type: any): any;

            static init(opts: any): void;

            static isDisturbed(stream: any): any;

            static isErrored(stream: any): any;

            static isReadable(stream: any): any;

            static kMaxEventTargetListeners: any;

            static kMaxEventTargetListenersWarned: any;

            static listenerCount(emitter: any, type: any): any;

            static on(emitter: any, event: any, options: any): any;

            static once(emitter: any, name: any, options: any): any;

            static pipeline(streams: any): any;

            static setMaxListeners(n: any, eventTargets: any): void;

            static usingDomains: boolean;

            static wrap(src: any, options: any): any;

        }

        class Readable {
            constructor(options: any);

            addListener(ev: any, fn: any): any;

            destroy(err: any, cb: any): any;

            filter(args: any): any;

            isPaused(): any;

            iterator(options: any): any;

            map(args: any): any;

            off(ev: any, fn: any): any;

            on(ev: any, fn: any): any;

            pause(): any;

            pipe(dest: any, pipeOpts: any): any;

            push(chunk: any, encoding: any): any;

            read(n: any): any;

            removeAllListeners(ev: any, ...args: any[]): any;

            removeListener(ev: any, fn: any): any;

            resume(): any;

            setEncoding(enc: any): any;

            unpipe(dest: any): any;

            unshift(chunk: any, encoding: any): any;

            wrap(stream: any): any;

            static Readable: any;

            static Transform: any;

            static addAbortSignal(signal: any, stream: any): any;

            static captureRejectionSymbol: any;

            static captureRejections: boolean;

            static compose(streams: any): any;

            static defaultMaxListeners: number;

            static destroy(stream: any, err: any): any;

            static errorMonitor: any;

            static finished(stream: any, options: any, callback: any, ...args: any[]): any;

            static from(iterable: any, opts: any): any;

            static getEventListeners(emitterOrTarget: any, type: any): any;

            static init(opts: any): void;

            static isDisturbed(stream: any): any;

            static isErrored(stream: any): any;

            static isReadable(stream: any): any;

            static kMaxEventTargetListeners: any;

            static kMaxEventTargetListenersWarned: any;

            static listenerCount(emitter: any, type: any): any;

            static on(emitter: any, event: any, options: any): any;

            static once(emitter: any, name: any, options: any): any;

            static pipeline(streams: any): any;

            static setMaxListeners(n: any, eventTargets: any): void;

            static usingDomains: boolean;

            static wrap(src: any, options: any): any;

        }

        class ReadableState {
            constructor(options: any, stream: any, isDuplex: any);

        }

        class Stream {
            constructor(opts: any);

            pipe(dest: any, options: any): any;

            static Stream: any;

            static Transform: any;

            static addAbortSignal(signal: any, stream: any): any;

            static captureRejectionSymbol: any;

            static captureRejections: boolean;

            static compose(streams: any): any;

            static defaultMaxListeners: number;

            static destroy(stream: any, err: any): any;

            static errorMonitor: any;

            static finished(stream: any, options: any, callback: any, ...args: any[]): any;

            static getEventListeners(emitterOrTarget: any, type: any): any;

            static init(opts: any): void;

            static isDisturbed(stream: any): any;

            static isErrored(stream: any): any;

            static isReadable(stream: any): any;

            static kMaxEventTargetListeners: any;

            static kMaxEventTargetListenersWarned: any;

            static listenerCount(emitter: any, type: any): any;

            static on(emitter: any, event: any, options: any): any;

            static once(emitter: any, name: any, options: any): any;

            static pipeline(streams: any): any;

            static setMaxListeners(n: any, eventTargets: any): void;

            static usingDomains: boolean;

        }

        class Writable {
            constructor(options: any);

            cork(): void;

            destroy(err: any, cb: any): any;

            end(chunk: any, encoding: any, cb: any): any;

            pipe(): void;

            setDefaultEncoding(encoding: any): any;

            uncork(): void;

            write(chunk: any, encoding: any, cb: any): any;

            static Transform: any;

            static Writable: any;

            static addAbortSignal(signal: any, stream: any): any;

            static captureRejectionSymbol: any;

            static captureRejections: boolean;

            static compose(streams: any): any;

            static defaultMaxListeners: number;

            static destroy(stream: any, err: any): any;

            static errorMonitor: any;

            static finished(stream: any, options: any, callback: any, ...args: any[]): any;

            static getEventListeners(emitterOrTarget: any, type: any): any;

            static init(opts: any): void;

            static isDisturbed(stream: any): any;

            static isErrored(stream: any): any;

            static isReadable(stream: any): any;

            static kMaxEventTargetListeners: any;

            static kMaxEventTargetListenersWarned: any;

            static listenerCount(emitter: any, type: any): any;

            static on(emitter: any, event: any, options: any): any;

            static once(emitter: any, name: any, options: any): any;

            static pipeline(streams: any): any;

            static setMaxListeners(n: any, eventTargets: any): void;

            static usingDomains: boolean;

        }

        namespace Duplex {
            class EventEmitter {
                constructor(opts: any);

                addListener(type: any, listener: any): any;

                emit(type: any, args: any): any;

                eventNames(): any;

                getMaxListeners(): any;

                listenerCount(type: any): any;

                listeners(type: any): any;

                off(type: any, listener: any): any;

                on(type: any, listener: any): any;

                once(type: any, listener: any): any;

                prependListener(type: any, listener: any): any;

                prependOnceListener(type: any, listener: any): any;

                rawListeners(type: any): any;

                removeAllListeners(type: any, ...args: any[]): any;

                removeListener(type: any, listener: any): any;

                setMaxListeners(n: any): any;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static defaultMaxListeners: any;

                static errorMonitor: any;

                static getEventListeners: any;

                static init: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static setMaxListeners: any;

                static usingDomains: any;

            }

            class EventEmitterAsyncResource {
                constructor(...args: any[]);

                emit(...args: any[]): void;

                emitDestroy(...args: any[]): void;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static defaultMaxListeners: any;

                static errorMonitor: any;

                static getEventListeners: any;

                static init: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static setMaxListeners: any;

                static usingDomains: any;

            }

            class PassThrough {
                constructor(options: any);

                static Duplex: any;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static PassThrough: any;

                static Readable: any;

                static ReadableState: any;

                static Stream: any;

                static Transform: any;

                static Writable: any;

                static addAbortSignal: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static compose: any;

                static defaultMaxListeners: any;

                static destroy: any;

                static errorMonitor: any;

                static finished: any;

                static from: any;

                static getEventListeners: any;

                static init: any;

                static isDisturbed: any;

                static isErrored: any;

                static isReadable: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static pipeline: any;

                static promises: any;

                static setMaxListeners: any;

                static usingDomains: any;

                static wrap: any;

            }

            class Readable {
                constructor(options: any);

                addListener(ev: any, fn: any): any;

                destroy(err: any, cb: any): any;

                filter(args: any): any;

                isPaused(): any;

                iterator(options: any): any;

                map(args: any): any;

                off(ev: any, fn: any): any;

                on(ev: any, fn: any): any;

                pause(): any;

                pipe(dest: any, pipeOpts: any): any;

                push(chunk: any, encoding: any): any;

                read(n: any): any;

                removeAllListeners(ev: any, ...args: any[]): any;

                removeListener(ev: any, fn: any): any;

                resume(): any;

                setEncoding(enc: any): any;

                unpipe(dest: any): any;

                unshift(chunk: any, encoding: any): any;

                wrap(stream: any): any;

                static Duplex: any;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static PassThrough: any;

                static Readable: any;

                static ReadableState: any;

                static Stream: any;

                static Transform: any;

                static Writable: any;

                static addAbortSignal: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static compose: any;

                static defaultMaxListeners: any;

                static destroy: any;

                static errorMonitor: any;

                static finished: any;

                static from: any;

                static getEventListeners: any;

                static init: any;

                static isDisturbed: any;

                static isErrored: any;

                static isReadable: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static pipeline: any;

                static promises: any;

                static setMaxListeners: any;

                static usingDomains: any;

                static wrap: any;

            }

            class ReadableState {
                constructor(options: any, stream: any, isDuplex: any);

            }

            class Stream {
                constructor(opts: any);

                pipe(dest: any, options: any): any;

                static Duplex: any;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static PassThrough: any;

                static Readable: any;

                static Stream: any;

                static Transform: any;

                static Writable: any;

                static addAbortSignal: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static compose: any;

                static defaultMaxListeners: any;

                static destroy: any;

                static errorMonitor: any;

                static finished: any;

                static getEventListeners: any;

                static init: any;

                static isDisturbed: any;

                static isErrored: any;

                static isReadable: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static pipeline: any;

                static promises: any;

                static setMaxListeners: any;

                static usingDomains: any;

            }

            class Writable {
                constructor(options: any);

                cork(): void;

                destroy(err: any, cb: any): any;

                end(chunk: any, encoding: any, cb: any): any;

                pipe(): void;

                setDefaultEncoding(encoding: any): any;

                uncork(): void;

                write(chunk: any, encoding: any, cb: any): any;

                static Duplex: any;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static PassThrough: any;

                static Readable: any;

                static Stream: any;

                static Transform: any;

                static Writable: any;

                static WritableState: any;

                static addAbortSignal: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static compose: any;

                static defaultMaxListeners: any;

                static destroy: any;

                static errorMonitor: any;

                static finished: any;

                static getEventListeners: any;

                static init: any;

                static isDisturbed: any;

                static isErrored: any;

                static isReadable: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static pipeline: any;

                static promises: any;

                static setMaxListeners: any;

                static usingDomains: any;

            }

            namespace promises {
                // Too-deep object hierarchy from fs.WriteStream.Transform.Duplex.promises
                const finished: any;

                // Too-deep object hierarchy from fs.WriteStream.Transform.Duplex.promises
                const pipeline: any;

            }

        }

        namespace EventEmitter {
            class EventEmitterAsyncResource {
                constructor(...args: any[]);

                emit(...args: any[]): void;

                emitDestroy(...args: any[]): void;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static defaultMaxListeners: any;

                static errorMonitor: any;

                static getEventListeners: any;

                static init: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static setMaxListeners: any;

                static usingDomains: any;

            }

        }

        namespace EventEmitterAsyncResource {
            class EventEmitter {
                constructor(opts: any);

                addListener(type: any, listener: any): any;

                emit(type: any, args: any): any;

                eventNames(): any;

                getMaxListeners(): any;

                listenerCount(type: any): any;

                listeners(type: any): any;

                off(type: any, listener: any): any;

                on(type: any, listener: any): any;

                once(type: any, listener: any): any;

                prependListener(type: any, listener: any): any;

                prependOnceListener(type: any, listener: any): any;

                rawListeners(type: any): any;

                removeAllListeners(type: any, ...args: any[]): any;

                removeListener(type: any, listener: any): any;

                setMaxListeners(n: any): any;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static defaultMaxListeners: any;

                static errorMonitor: any;

                static getEventListeners: any;

                static init: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static setMaxListeners: any;

                static usingDomains: any;

            }

        }

        namespace PassThrough {
            class Duplex {
                constructor(options: any);

                cork(): void;

                end(chunk: any, encoding: any, cb: any): any;

                setDefaultEncoding(encoding: any): any;

                uncork(): void;

                write(chunk: any, encoding: any, cb: any): any;

                static Duplex: any;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static PassThrough: any;

                static Readable: any;

                static ReadableState: any;

                static Stream: any;

                static Transform: any;

                static Writable: any;

                static addAbortSignal: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static compose: any;

                static defaultMaxListeners: any;

                static destroy: any;

                static errorMonitor: any;

                static finished: any;

                static from: any;

                static getEventListeners: any;

                static init: any;

                static isDisturbed: any;

                static isErrored: any;

                static isReadable: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static pipeline: any;

                static promises: any;

                static setMaxListeners: any;

                static usingDomains: any;

                static wrap: any;

            }

            class EventEmitter {
                constructor(opts: any);

                addListener(type: any, listener: any): any;

                emit(type: any, args: any): any;

                eventNames(): any;

                getMaxListeners(): any;

                listenerCount(type: any): any;

                listeners(type: any): any;

                off(type: any, listener: any): any;

                on(type: any, listener: any): any;

                once(type: any, listener: any): any;

                prependListener(type: any, listener: any): any;

                prependOnceListener(type: any, listener: any): any;

                rawListeners(type: any): any;

                removeAllListeners(type: any, ...args: any[]): any;

                removeListener(type: any, listener: any): any;

                setMaxListeners(n: any): any;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static defaultMaxListeners: any;

                static errorMonitor: any;

                static getEventListeners: any;

                static init: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static setMaxListeners: any;

                static usingDomains: any;

            }

            class EventEmitterAsyncResource {
                constructor(...args: any[]);

                emit(...args: any[]): void;

                emitDestroy(...args: any[]): void;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static defaultMaxListeners: any;

                static errorMonitor: any;

                static getEventListeners: any;

                static init: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static setMaxListeners: any;

                static usingDomains: any;

            }

            class Readable {
                constructor(options: any);

                addListener(ev: any, fn: any): any;

                destroy(err: any, cb: any): any;

                filter(args: any): any;

                isPaused(): any;

                iterator(options: any): any;

                map(args: any): any;

                off(ev: any, fn: any): any;

                on(ev: any, fn: any): any;

                pause(): any;

                pipe(dest: any, pipeOpts: any): any;

                push(chunk: any, encoding: any): any;

                read(n: any): any;

                removeAllListeners(ev: any, ...args: any[]): any;

                removeListener(ev: any, fn: any): any;

                resume(): any;

                setEncoding(enc: any): any;

                unpipe(dest: any): any;

                unshift(chunk: any, encoding: any): any;

                wrap(stream: any): any;

                static Duplex: any;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static PassThrough: any;

                static Readable: any;

                static ReadableState: any;

                static Stream: any;

                static Transform: any;

                static Writable: any;

                static addAbortSignal: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static compose: any;

                static defaultMaxListeners: any;

                static destroy: any;

                static errorMonitor: any;

                static finished: any;

                static from: any;

                static getEventListeners: any;

                static init: any;

                static isDisturbed: any;

                static isErrored: any;

                static isReadable: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static pipeline: any;

                static promises: any;

                static setMaxListeners: any;

                static usingDomains: any;

                static wrap: any;

            }

            class ReadableState {
                constructor(options: any, stream: any, isDuplex: any);

            }

            class Stream {
                constructor(opts: any);

                pipe(dest: any, options: any): any;

                static Duplex: any;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static PassThrough: any;

                static Readable: any;

                static Stream: any;

                static Transform: any;

                static Writable: any;

                static addAbortSignal: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static compose: any;

                static defaultMaxListeners: any;

                static destroy: any;

                static errorMonitor: any;

                static finished: any;

                static getEventListeners: any;

                static init: any;

                static isDisturbed: any;

                static isErrored: any;

                static isReadable: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static pipeline: any;

                static promises: any;

                static setMaxListeners: any;

                static usingDomains: any;

            }

            class Writable {
                constructor(options: any);

                cork(): void;

                destroy(err: any, cb: any): any;

                end(chunk: any, encoding: any, cb: any): any;

                pipe(): void;

                setDefaultEncoding(encoding: any): any;

                uncork(): void;

                write(chunk: any, encoding: any, cb: any): any;

                static Duplex: any;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static PassThrough: any;

                static Readable: any;

                static Stream: any;

                static Transform: any;

                static Writable: any;

                static WritableState: any;

                static addAbortSignal: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static compose: any;

                static defaultMaxListeners: any;

                static destroy: any;

                static errorMonitor: any;

                static finished: any;

                static getEventListeners: any;

                static init: any;

                static isDisturbed: any;

                static isErrored: any;

                static isReadable: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static pipeline: any;

                static promises: any;

                static setMaxListeners: any;

                static usingDomains: any;

            }

            namespace promises {
                // Too-deep object hierarchy from fs.WriteStream.Transform.PassThrough.promises
                const finished: any;

                // Too-deep object hierarchy from fs.WriteStream.Transform.PassThrough.promises
                const pipeline: any;

            }

        }

        namespace Readable {
            class Duplex {
                constructor(options: any);

                cork(): void;

                end(chunk: any, encoding: any, cb: any): any;

                setDefaultEncoding(encoding: any): any;

                uncork(): void;

                write(chunk: any, encoding: any, cb: any): any;

                static Duplex: any;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static PassThrough: any;

                static Readable: any;

                static ReadableState: any;

                static Stream: any;

                static Transform: any;

                static Writable: any;

                static addAbortSignal: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static compose: any;

                static defaultMaxListeners: any;

                static destroy: any;

                static errorMonitor: any;

                static finished: any;

                static from: any;

                static getEventListeners: any;

                static init: any;

                static isDisturbed: any;

                static isErrored: any;

                static isReadable: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static pipeline: any;

                static promises: any;

                static setMaxListeners: any;

                static usingDomains: any;

                static wrap: any;

            }

            class EventEmitter {
                constructor(opts: any);

                addListener(type: any, listener: any): any;

                emit(type: any, args: any): any;

                eventNames(): any;

                getMaxListeners(): any;

                listenerCount(type: any): any;

                listeners(type: any): any;

                off(type: any, listener: any): any;

                on(type: any, listener: any): any;

                once(type: any, listener: any): any;

                prependListener(type: any, listener: any): any;

                prependOnceListener(type: any, listener: any): any;

                rawListeners(type: any): any;

                removeAllListeners(type: any, ...args: any[]): any;

                removeListener(type: any, listener: any): any;

                setMaxListeners(n: any): any;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static defaultMaxListeners: any;

                static errorMonitor: any;

                static getEventListeners: any;

                static init: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static setMaxListeners: any;

                static usingDomains: any;

            }

            class EventEmitterAsyncResource {
                constructor(...args: any[]);

                emit(...args: any[]): void;

                emitDestroy(...args: any[]): void;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static defaultMaxListeners: any;

                static errorMonitor: any;

                static getEventListeners: any;

                static init: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static setMaxListeners: any;

                static usingDomains: any;

            }

            class PassThrough {
                constructor(options: any);

                static Duplex: any;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static PassThrough: any;

                static Readable: any;

                static ReadableState: any;

                static Stream: any;

                static Transform: any;

                static Writable: any;

                static addAbortSignal: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static compose: any;

                static defaultMaxListeners: any;

                static destroy: any;

                static errorMonitor: any;

                static finished: any;

                static from: any;

                static getEventListeners: any;

                static init: any;

                static isDisturbed: any;

                static isErrored: any;

                static isReadable: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static pipeline: any;

                static promises: any;

                static setMaxListeners: any;

                static usingDomains: any;

                static wrap: any;

            }

            class ReadableState {
                constructor(options: any, stream: any, isDuplex: any);

            }

            class Stream {
                constructor(opts: any);

                pipe(dest: any, options: any): any;

                static Duplex: any;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static PassThrough: any;

                static Readable: any;

                static Stream: any;

                static Transform: any;

                static Writable: any;

                static addAbortSignal: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static compose: any;

                static defaultMaxListeners: any;

                static destroy: any;

                static errorMonitor: any;

                static finished: any;

                static getEventListeners: any;

                static init: any;

                static isDisturbed: any;

                static isErrored: any;

                static isReadable: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static pipeline: any;

                static promises: any;

                static setMaxListeners: any;

                static usingDomains: any;

            }

            class Writable {
                constructor(options: any);

                cork(): void;

                destroy(err: any, cb: any): any;

                end(chunk: any, encoding: any, cb: any): any;

                pipe(): void;

                setDefaultEncoding(encoding: any): any;

                uncork(): void;

                write(chunk: any, encoding: any, cb: any): any;

                static Duplex: any;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static PassThrough: any;

                static Readable: any;

                static Stream: any;

                static Transform: any;

                static Writable: any;

                static WritableState: any;

                static addAbortSignal: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static compose: any;

                static defaultMaxListeners: any;

                static destroy: any;

                static errorMonitor: any;

                static finished: any;

                static getEventListeners: any;

                static init: any;

                static isDisturbed: any;

                static isErrored: any;

                static isReadable: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static pipeline: any;

                static promises: any;

                static setMaxListeners: any;

                static usingDomains: any;

            }

            namespace promises {
                // Too-deep object hierarchy from fs.WriteStream.Transform.Readable.promises
                const finished: any;

                // Too-deep object hierarchy from fs.WriteStream.Transform.Readable.promises
                const pipeline: any;

            }

        }

        namespace Stream {
            class Duplex {
                constructor(options: any);

                cork(): void;

                end(chunk: any, encoding: any, cb: any): any;

                setDefaultEncoding(encoding: any): any;

                uncork(): void;

                write(chunk: any, encoding: any, cb: any): any;

                static Duplex: any;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static PassThrough: any;

                static Readable: any;

                static ReadableState: any;

                static Stream: any;

                static Transform: any;

                static Writable: any;

                static addAbortSignal: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static compose: any;

                static defaultMaxListeners: any;

                static destroy: any;

                static errorMonitor: any;

                static finished: any;

                static from: any;

                static getEventListeners: any;

                static init: any;

                static isDisturbed: any;

                static isErrored: any;

                static isReadable: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static pipeline: any;

                static promises: any;

                static setMaxListeners: any;

                static usingDomains: any;

                static wrap: any;

            }

            class EventEmitter {
                constructor(opts: any);

                addListener(type: any, listener: any): any;

                emit(type: any, args: any): any;

                eventNames(): any;

                getMaxListeners(): any;

                listenerCount(type: any): any;

                listeners(type: any): any;

                off(type: any, listener: any): any;

                on(type: any, listener: any): any;

                once(type: any, listener: any): any;

                prependListener(type: any, listener: any): any;

                prependOnceListener(type: any, listener: any): any;

                rawListeners(type: any): any;

                removeAllListeners(type: any, ...args: any[]): any;

                removeListener(type: any, listener: any): any;

                setMaxListeners(n: any): any;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static defaultMaxListeners: any;

                static errorMonitor: any;

                static getEventListeners: any;

                static init: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static setMaxListeners: any;

                static usingDomains: any;

            }

            class EventEmitterAsyncResource {
                constructor(...args: any[]);

                emit(...args: any[]): void;

                emitDestroy(...args: any[]): void;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static defaultMaxListeners: any;

                static errorMonitor: any;

                static getEventListeners: any;

                static init: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static setMaxListeners: any;

                static usingDomains: any;

            }

            class PassThrough {
                constructor(options: any);

                static Duplex: any;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static PassThrough: any;

                static Readable: any;

                static ReadableState: any;

                static Stream: any;

                static Transform: any;

                static Writable: any;

                static addAbortSignal: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static compose: any;

                static defaultMaxListeners: any;

                static destroy: any;

                static errorMonitor: any;

                static finished: any;

                static from: any;

                static getEventListeners: any;

                static init: any;

                static isDisturbed: any;

                static isErrored: any;

                static isReadable: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static pipeline: any;

                static promises: any;

                static setMaxListeners: any;

                static usingDomains: any;

                static wrap: any;

            }

            class Readable {
                constructor(options: any);

                addListener(ev: any, fn: any): any;

                destroy(err: any, cb: any): any;

                filter(args: any): any;

                isPaused(): any;

                iterator(options: any): any;

                map(args: any): any;

                off(ev: any, fn: any): any;

                on(ev: any, fn: any): any;

                pause(): any;

                pipe(dest: any, pipeOpts: any): any;

                push(chunk: any, encoding: any): any;

                read(n: any): any;

                removeAllListeners(ev: any, ...args: any[]): any;

                removeListener(ev: any, fn: any): any;

                resume(): any;

                setEncoding(enc: any): any;

                unpipe(dest: any): any;

                unshift(chunk: any, encoding: any): any;

                wrap(stream: any): any;

                static Duplex: any;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static PassThrough: any;

                static Readable: any;

                static ReadableState: any;

                static Stream: any;

                static Transform: any;

                static Writable: any;

                static addAbortSignal: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static compose: any;

                static defaultMaxListeners: any;

                static destroy: any;

                static errorMonitor: any;

                static finished: any;

                static from: any;

                static getEventListeners: any;

                static init: any;

                static isDisturbed: any;

                static isErrored: any;

                static isReadable: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static pipeline: any;

                static promises: any;

                static setMaxListeners: any;

                static usingDomains: any;

                static wrap: any;

            }

            class Writable {
                constructor(options: any);

                cork(): void;

                destroy(err: any, cb: any): any;

                end(chunk: any, encoding: any, cb: any): any;

                pipe(): void;

                setDefaultEncoding(encoding: any): any;

                uncork(): void;

                write(chunk: any, encoding: any, cb: any): any;

                static Duplex: any;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static PassThrough: any;

                static Readable: any;

                static Stream: any;

                static Transform: any;

                static Writable: any;

                static WritableState: any;

                static addAbortSignal: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static compose: any;

                static defaultMaxListeners: any;

                static destroy: any;

                static errorMonitor: any;

                static finished: any;

                static getEventListeners: any;

                static init: any;

                static isDisturbed: any;

                static isErrored: any;

                static isReadable: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static pipeline: any;

                static promises: any;

                static setMaxListeners: any;

                static usingDomains: any;

            }

            namespace promises {
                // Too-deep object hierarchy from fs.WriteStream.Transform.Stream.promises
                const finished: any;

                // Too-deep object hierarchy from fs.WriteStream.Transform.Stream.promises
                const pipeline: any;

            }

        }

        namespace Writable {
            class Duplex {
                constructor(options: any);

                cork(): void;

                end(chunk: any, encoding: any, cb: any): any;

                setDefaultEncoding(encoding: any): any;

                uncork(): void;

                write(chunk: any, encoding: any, cb: any): any;

                static Duplex: any;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static PassThrough: any;

                static Readable: any;

                static ReadableState: any;

                static Stream: any;

                static Transform: any;

                static Writable: any;

                static addAbortSignal: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static compose: any;

                static defaultMaxListeners: any;

                static destroy: any;

                static errorMonitor: any;

                static finished: any;

                static from: any;

                static getEventListeners: any;

                static init: any;

                static isDisturbed: any;

                static isErrored: any;

                static isReadable: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static pipeline: any;

                static promises: any;

                static setMaxListeners: any;

                static usingDomains: any;

                static wrap: any;

            }

            class EventEmitter {
                constructor(opts: any);

                addListener(type: any, listener: any): any;

                emit(type: any, args: any): any;

                eventNames(): any;

                getMaxListeners(): any;

                listenerCount(type: any): any;

                listeners(type: any): any;

                off(type: any, listener: any): any;

                on(type: any, listener: any): any;

                once(type: any, listener: any): any;

                prependListener(type: any, listener: any): any;

                prependOnceListener(type: any, listener: any): any;

                rawListeners(type: any): any;

                removeAllListeners(type: any, ...args: any[]): any;

                removeListener(type: any, listener: any): any;

                setMaxListeners(n: any): any;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static defaultMaxListeners: any;

                static errorMonitor: any;

                static getEventListeners: any;

                static init: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static setMaxListeners: any;

                static usingDomains: any;

            }

            class EventEmitterAsyncResource {
                constructor(...args: any[]);

                emit(...args: any[]): void;

                emitDestroy(...args: any[]): void;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static defaultMaxListeners: any;

                static errorMonitor: any;

                static getEventListeners: any;

                static init: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static setMaxListeners: any;

                static usingDomains: any;

            }

            class PassThrough {
                constructor(options: any);

                static Duplex: any;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static PassThrough: any;

                static Readable: any;

                static ReadableState: any;

                static Stream: any;

                static Transform: any;

                static Writable: any;

                static addAbortSignal: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static compose: any;

                static defaultMaxListeners: any;

                static destroy: any;

                static errorMonitor: any;

                static finished: any;

                static from: any;

                static getEventListeners: any;

                static init: any;

                static isDisturbed: any;

                static isErrored: any;

                static isReadable: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static pipeline: any;

                static promises: any;

                static setMaxListeners: any;

                static usingDomains: any;

                static wrap: any;

            }

            class Readable {
                constructor(options: any);

                addListener(ev: any, fn: any): any;

                destroy(err: any, cb: any): any;

                filter(args: any): any;

                isPaused(): any;

                iterator(options: any): any;

                map(args: any): any;

                off(ev: any, fn: any): any;

                on(ev: any, fn: any): any;

                pause(): any;

                pipe(dest: any, pipeOpts: any): any;

                push(chunk: any, encoding: any): any;

                read(n: any): any;

                removeAllListeners(ev: any, ...args: any[]): any;

                removeListener(ev: any, fn: any): any;

                resume(): any;

                setEncoding(enc: any): any;

                unpipe(dest: any): any;

                unshift(chunk: any, encoding: any): any;

                wrap(stream: any): any;

                static Duplex: any;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static PassThrough: any;

                static Readable: any;

                static ReadableState: any;

                static Stream: any;

                static Transform: any;

                static Writable: any;

                static addAbortSignal: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static compose: any;

                static defaultMaxListeners: any;

                static destroy: any;

                static errorMonitor: any;

                static finished: any;

                static from: any;

                static getEventListeners: any;

                static init: any;

                static isDisturbed: any;

                static isErrored: any;

                static isReadable: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static pipeline: any;

                static promises: any;

                static setMaxListeners: any;

                static usingDomains: any;

                static wrap: any;

            }

            class Stream {
                constructor(opts: any);

                pipe(dest: any, options: any): any;

                static Duplex: any;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static PassThrough: any;

                static Readable: any;

                static Stream: any;

                static Transform: any;

                static Writable: any;

                static addAbortSignal: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static compose: any;

                static defaultMaxListeners: any;

                static destroy: any;

                static errorMonitor: any;

                static finished: any;

                static getEventListeners: any;

                static init: any;

                static isDisturbed: any;

                static isErrored: any;

                static isReadable: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static pipeline: any;

                static promises: any;

                static setMaxListeners: any;

                static usingDomains: any;

            }

            class WritableState {
                constructor(options: any, stream: any, isDuplex: any);

                getBuffer(): any;

            }

            namespace promises {
                // Too-deep object hierarchy from fs.WriteStream.Transform.Writable.promises
                const finished: any;

                // Too-deep object hierarchy from fs.WriteStream.Transform.Writable.promises
                const pipeline: any;

            }

        }

        namespace promises {
            function finished(stream: any, opts: any): any;

            function pipeline(streams: any): any;

        }

    }

    namespace Writable {
        class Duplex {
            constructor(options: any);

            cork(): void;

            end(chunk: any, encoding: any, cb: any): any;

            setDefaultEncoding(encoding: any): any;

            uncork(): void;

            write(chunk: any, encoding: any, cb: any): any;

            static Duplex: any;

            static Writable: any;

            static addAbortSignal(signal: any, stream: any): any;

            static captureRejectionSymbol: any;

            static captureRejections: boolean;

            static compose(streams: any): any;

            static defaultMaxListeners: number;

            static destroy(stream: any, err: any): any;

            static errorMonitor: any;

            static finished(stream: any, options: any, callback: any, ...args: any[]): any;

            static from(body: any): any;

            static getEventListeners(emitterOrTarget: any, type: any): any;

            static init(opts: any): void;

            static isDisturbed(stream: any): any;

            static isErrored(stream: any): any;

            static isReadable(stream: any): any;

            static kMaxEventTargetListeners: any;

            static kMaxEventTargetListenersWarned: any;

            static listenerCount(emitter: any, type: any): any;

            static on(emitter: any, event: any, options: any): any;

            static once(emitter: any, name: any, options: any): any;

            static pipeline(streams: any): any;

            static setMaxListeners(n: any, eventTargets: any): void;

            static usingDomains: boolean;

            static wrap(src: any, options: any): any;

        }

        class EventEmitter {
            constructor(opts: any);

            addListener(type: any, listener: any): any;

            emit(type: any, args: any): any;

            eventNames(): any;

            getMaxListeners(): any;

            listenerCount(type: any): any;

            listeners(type: any): any;

            off(type: any, listener: any): any;

            on(type: any, listener: any): any;

            once(type: any, listener: any): any;

            prependListener(type: any, listener: any): any;

            prependOnceListener(type: any, listener: any): any;

            rawListeners(type: any): any;

            removeAllListeners(type: any, ...args: any[]): any;

            removeListener(type: any, listener: any): any;

            setMaxListeners(n: any): any;

            static EventEmitter: any;

            static captureRejectionSymbol: any;

            static captureRejections: boolean;

            static defaultMaxListeners: number;

            static errorMonitor: any;

            static getEventListeners(emitterOrTarget: any, type: any): any;

            static init(opts: any): void;

            static kMaxEventTargetListeners: any;

            static kMaxEventTargetListenersWarned: any;

            static listenerCount(emitter: any, type: any): any;

            static on(emitter: any, event: any, options: any): any;

            static once(emitter: any, name: any, options: any): any;

            static setMaxListeners(n: any, eventTargets: any): void;

            static usingDomains: boolean;

        }

        class EventEmitterAsyncResource {
            constructor(...args: any[]);

            emit(...args: any[]): void;

            emitDestroy(...args: any[]): void;

            static EventEmitterAsyncResource: any;

            static captureRejectionSymbol: any;

            static captureRejections: boolean;

            static defaultMaxListeners: number;

            static errorMonitor: any;

            static getEventListeners(emitterOrTarget: any, type: any): any;

            static init(opts: any): void;

            static kMaxEventTargetListeners: any;

            static kMaxEventTargetListenersWarned: any;

            static listenerCount(emitter: any, type: any): any;

            static on(emitter: any, event: any, options: any): any;

            static once(emitter: any, name: any, options: any): any;

            static setMaxListeners(n: any, eventTargets: any): void;

            static usingDomains: boolean;

        }

        class PassThrough {
            constructor(options: any);

            static PassThrough: any;

            static Writable: any;

            static addAbortSignal(signal: any, stream: any): any;

            static captureRejectionSymbol: any;

            static captureRejections: boolean;

            static compose(streams: any): any;

            static defaultMaxListeners: number;

            static destroy(stream: any, err: any): any;

            static errorMonitor: any;

            static finished(stream: any, options: any, callback: any, ...args: any[]): any;

            static from(body: any): any;

            static getEventListeners(emitterOrTarget: any, type: any): any;

            static init(opts: any): void;

            static isDisturbed(stream: any): any;

            static isErrored(stream: any): any;

            static isReadable(stream: any): any;

            static kMaxEventTargetListeners: any;

            static kMaxEventTargetListenersWarned: any;

            static listenerCount(emitter: any, type: any): any;

            static on(emitter: any, event: any, options: any): any;

            static once(emitter: any, name: any, options: any): any;

            static pipeline(streams: any): any;

            static setMaxListeners(n: any, eventTargets: any): void;

            static usingDomains: boolean;

            static wrap(src: any, options: any): any;

        }

        class Readable {
            constructor(options: any);

            addListener(ev: any, fn: any): any;

            destroy(err: any, cb: any): any;

            filter(args: any): any;

            isPaused(): any;

            iterator(options: any): any;

            map(args: any): any;

            off(ev: any, fn: any): any;

            on(ev: any, fn: any): any;

            pause(): any;

            pipe(dest: any, pipeOpts: any): any;

            push(chunk: any, encoding: any): any;

            read(n: any): any;

            removeAllListeners(ev: any, ...args: any[]): any;

            removeListener(ev: any, fn: any): any;

            resume(): any;

            setEncoding(enc: any): any;

            unpipe(dest: any): any;

            unshift(chunk: any, encoding: any): any;

            wrap(stream: any): any;

            static Readable: any;

            static Writable: any;

            static addAbortSignal(signal: any, stream: any): any;

            static captureRejectionSymbol: any;

            static captureRejections: boolean;

            static compose(streams: any): any;

            static defaultMaxListeners: number;

            static destroy(stream: any, err: any): any;

            static errorMonitor: any;

            static finished(stream: any, options: any, callback: any, ...args: any[]): any;

            static from(iterable: any, opts: any): any;

            static getEventListeners(emitterOrTarget: any, type: any): any;

            static init(opts: any): void;

            static isDisturbed(stream: any): any;

            static isErrored(stream: any): any;

            static isReadable(stream: any): any;

            static kMaxEventTargetListeners: any;

            static kMaxEventTargetListenersWarned: any;

            static listenerCount(emitter: any, type: any): any;

            static on(emitter: any, event: any, options: any): any;

            static once(emitter: any, name: any, options: any): any;

            static pipeline(streams: any): any;

            static setMaxListeners(n: any, eventTargets: any): void;

            static usingDomains: boolean;

            static wrap(src: any, options: any): any;

        }

        class Stream {
            constructor(opts: any);

            pipe(dest: any, options: any): any;

            static Stream: any;

            static Writable: any;

            static addAbortSignal(signal: any, stream: any): any;

            static captureRejectionSymbol: any;

            static captureRejections: boolean;

            static compose(streams: any): any;

            static defaultMaxListeners: number;

            static destroy(stream: any, err: any): any;

            static errorMonitor: any;

            static finished(stream: any, options: any, callback: any, ...args: any[]): any;

            static getEventListeners(emitterOrTarget: any, type: any): any;

            static init(opts: any): void;

            static isDisturbed(stream: any): any;

            static isErrored(stream: any): any;

            static isReadable(stream: any): any;

            static kMaxEventTargetListeners: any;

            static kMaxEventTargetListenersWarned: any;

            static listenerCount(emitter: any, type: any): any;

            static on(emitter: any, event: any, options: any): any;

            static once(emitter: any, name: any, options: any): any;

            static pipeline(streams: any): any;

            static setMaxListeners(n: any, eventTargets: any): void;

            static usingDomains: boolean;

        }

        class Transform {
            constructor(options: any);

            static Transform: any;

            static Writable: any;

            static addAbortSignal(signal: any, stream: any): any;

            static captureRejectionSymbol: any;

            static captureRejections: boolean;

            static compose(streams: any): any;

            static defaultMaxListeners: number;

            static destroy(stream: any, err: any): any;

            static errorMonitor: any;

            static finished(stream: any, options: any, callback: any, ...args: any[]): any;

            static from(body: any): any;

            static getEventListeners(emitterOrTarget: any, type: any): any;

            static init(opts: any): void;

            static isDisturbed(stream: any): any;

            static isErrored(stream: any): any;

            static isReadable(stream: any): any;

            static kMaxEventTargetListeners: any;

            static kMaxEventTargetListenersWarned: any;

            static listenerCount(emitter: any, type: any): any;

            static on(emitter: any, event: any, options: any): any;

            static once(emitter: any, name: any, options: any): any;

            static pipeline(streams: any): any;

            static setMaxListeners(n: any, eventTargets: any): void;

            static usingDomains: boolean;

            static wrap(src: any, options: any): any;

        }

        class WritableState {
            constructor(options: any, stream: any, isDuplex: any);

            getBuffer(): any;

        }

        namespace Duplex {
            class EventEmitter {
                constructor(opts: any);

                addListener(type: any, listener: any): any;

                emit(type: any, args: any): any;

                eventNames(): any;

                getMaxListeners(): any;

                listenerCount(type: any): any;

                listeners(type: any): any;

                off(type: any, listener: any): any;

                on(type: any, listener: any): any;

                once(type: any, listener: any): any;

                prependListener(type: any, listener: any): any;

                prependOnceListener(type: any, listener: any): any;

                rawListeners(type: any): any;

                removeAllListeners(type: any, ...args: any[]): any;

                removeListener(type: any, listener: any): any;

                setMaxListeners(n: any): any;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static defaultMaxListeners: any;

                static errorMonitor: any;

                static getEventListeners: any;

                static init: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static setMaxListeners: any;

                static usingDomains: any;

            }

            class EventEmitterAsyncResource {
                constructor(...args: any[]);

                emit(...args: any[]): void;

                emitDestroy(...args: any[]): void;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static defaultMaxListeners: any;

                static errorMonitor: any;

                static getEventListeners: any;

                static init: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static setMaxListeners: any;

                static usingDomains: any;

            }

            class PassThrough {
                constructor(options: any);

                static Duplex: any;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static PassThrough: any;

                static Readable: any;

                static ReadableState: any;

                static Stream: any;

                static Transform: any;

                static Writable: any;

                static addAbortSignal: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static compose: any;

                static defaultMaxListeners: any;

                static destroy: any;

                static errorMonitor: any;

                static finished: any;

                static from: any;

                static getEventListeners: any;

                static init: any;

                static isDisturbed: any;

                static isErrored: any;

                static isReadable: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static pipeline: any;

                static promises: any;

                static setMaxListeners: any;

                static usingDomains: any;

                static wrap: any;

            }

            class Readable {
                constructor(options: any);

                addListener(ev: any, fn: any): any;

                destroy(err: any, cb: any): any;

                filter(args: any): any;

                isPaused(): any;

                iterator(options: any): any;

                map(args: any): any;

                off(ev: any, fn: any): any;

                on(ev: any, fn: any): any;

                pause(): any;

                pipe(dest: any, pipeOpts: any): any;

                push(chunk: any, encoding: any): any;

                read(n: any): any;

                removeAllListeners(ev: any, ...args: any[]): any;

                removeListener(ev: any, fn: any): any;

                resume(): any;

                setEncoding(enc: any): any;

                unpipe(dest: any): any;

                unshift(chunk: any, encoding: any): any;

                wrap(stream: any): any;

                static Duplex: any;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static PassThrough: any;

                static Readable: any;

                static ReadableState: any;

                static Stream: any;

                static Transform: any;

                static Writable: any;

                static addAbortSignal: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static compose: any;

                static defaultMaxListeners: any;

                static destroy: any;

                static errorMonitor: any;

                static finished: any;

                static from: any;

                static getEventListeners: any;

                static init: any;

                static isDisturbed: any;

                static isErrored: any;

                static isReadable: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static pipeline: any;

                static promises: any;

                static setMaxListeners: any;

                static usingDomains: any;

                static wrap: any;

            }

            class ReadableState {
                constructor(options: any, stream: any, isDuplex: any);

            }

            class Stream {
                constructor(opts: any);

                pipe(dest: any, options: any): any;

                static Duplex: any;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static PassThrough: any;

                static Readable: any;

                static Stream: any;

                static Transform: any;

                static Writable: any;

                static addAbortSignal: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static compose: any;

                static defaultMaxListeners: any;

                static destroy: any;

                static errorMonitor: any;

                static finished: any;

                static getEventListeners: any;

                static init: any;

                static isDisturbed: any;

                static isErrored: any;

                static isReadable: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static pipeline: any;

                static promises: any;

                static setMaxListeners: any;

                static usingDomains: any;

            }

            class Transform {
                constructor(options: any);

                static Duplex: any;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static PassThrough: any;

                static Readable: any;

                static ReadableState: any;

                static Stream: any;

                static Transform: any;

                static Writable: any;

                static addAbortSignal: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static compose: any;

                static defaultMaxListeners: any;

                static destroy: any;

                static errorMonitor: any;

                static finished: any;

                static from: any;

                static getEventListeners: any;

                static init: any;

                static isDisturbed: any;

                static isErrored: any;

                static isReadable: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static pipeline: any;

                static promises: any;

                static setMaxListeners: any;

                static usingDomains: any;

                static wrap: any;

            }

            namespace promises {
                // Too-deep object hierarchy from fs.WriteStream.Writable.Duplex.promises
                const finished: any;

                // Too-deep object hierarchy from fs.WriteStream.Writable.Duplex.promises
                const pipeline: any;

            }

        }

        namespace EventEmitter {
            class EventEmitterAsyncResource {
                constructor(...args: any[]);

                emit(...args: any[]): void;

                emitDestroy(...args: any[]): void;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static defaultMaxListeners: any;

                static errorMonitor: any;

                static getEventListeners: any;

                static init: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static setMaxListeners: any;

                static usingDomains: any;

            }

        }

        namespace EventEmitterAsyncResource {
            class EventEmitter {
                constructor(opts: any);

                addListener(type: any, listener: any): any;

                emit(type: any, args: any): any;

                eventNames(): any;

                getMaxListeners(): any;

                listenerCount(type: any): any;

                listeners(type: any): any;

                off(type: any, listener: any): any;

                on(type: any, listener: any): any;

                once(type: any, listener: any): any;

                prependListener(type: any, listener: any): any;

                prependOnceListener(type: any, listener: any): any;

                rawListeners(type: any): any;

                removeAllListeners(type: any, ...args: any[]): any;

                removeListener(type: any, listener: any): any;

                setMaxListeners(n: any): any;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static defaultMaxListeners: any;

                static errorMonitor: any;

                static getEventListeners: any;

                static init: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static setMaxListeners: any;

                static usingDomains: any;

            }

        }

        namespace PassThrough {
            class Duplex {
                constructor(options: any);

                cork(): void;

                end(chunk: any, encoding: any, cb: any): any;

                setDefaultEncoding(encoding: any): any;

                uncork(): void;

                write(chunk: any, encoding: any, cb: any): any;

                static Duplex: any;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static PassThrough: any;

                static Readable: any;

                static ReadableState: any;

                static Stream: any;

                static Transform: any;

                static Writable: any;

                static addAbortSignal: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static compose: any;

                static defaultMaxListeners: any;

                static destroy: any;

                static errorMonitor: any;

                static finished: any;

                static from: any;

                static getEventListeners: any;

                static init: any;

                static isDisturbed: any;

                static isErrored: any;

                static isReadable: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static pipeline: any;

                static promises: any;

                static setMaxListeners: any;

                static usingDomains: any;

                static wrap: any;

            }

            class EventEmitter {
                constructor(opts: any);

                addListener(type: any, listener: any): any;

                emit(type: any, args: any): any;

                eventNames(): any;

                getMaxListeners(): any;

                listenerCount(type: any): any;

                listeners(type: any): any;

                off(type: any, listener: any): any;

                on(type: any, listener: any): any;

                once(type: any, listener: any): any;

                prependListener(type: any, listener: any): any;

                prependOnceListener(type: any, listener: any): any;

                rawListeners(type: any): any;

                removeAllListeners(type: any, ...args: any[]): any;

                removeListener(type: any, listener: any): any;

                setMaxListeners(n: any): any;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static defaultMaxListeners: any;

                static errorMonitor: any;

                static getEventListeners: any;

                static init: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static setMaxListeners: any;

                static usingDomains: any;

            }

            class EventEmitterAsyncResource {
                constructor(...args: any[]);

                emit(...args: any[]): void;

                emitDestroy(...args: any[]): void;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static defaultMaxListeners: any;

                static errorMonitor: any;

                static getEventListeners: any;

                static init: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static setMaxListeners: any;

                static usingDomains: any;

            }

            class Readable {
                constructor(options: any);

                addListener(ev: any, fn: any): any;

                destroy(err: any, cb: any): any;

                filter(args: any): any;

                isPaused(): any;

                iterator(options: any): any;

                map(args: any): any;

                off(ev: any, fn: any): any;

                on(ev: any, fn: any): any;

                pause(): any;

                pipe(dest: any, pipeOpts: any): any;

                push(chunk: any, encoding: any): any;

                read(n: any): any;

                removeAllListeners(ev: any, ...args: any[]): any;

                removeListener(ev: any, fn: any): any;

                resume(): any;

                setEncoding(enc: any): any;

                unpipe(dest: any): any;

                unshift(chunk: any, encoding: any): any;

                wrap(stream: any): any;

                static Duplex: any;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static PassThrough: any;

                static Readable: any;

                static ReadableState: any;

                static Stream: any;

                static Transform: any;

                static Writable: any;

                static addAbortSignal: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static compose: any;

                static defaultMaxListeners: any;

                static destroy: any;

                static errorMonitor: any;

                static finished: any;

                static from: any;

                static getEventListeners: any;

                static init: any;

                static isDisturbed: any;

                static isErrored: any;

                static isReadable: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static pipeline: any;

                static promises: any;

                static setMaxListeners: any;

                static usingDomains: any;

                static wrap: any;

            }

            class ReadableState {
                constructor(options: any, stream: any, isDuplex: any);

            }

            class Stream {
                constructor(opts: any);

                pipe(dest: any, options: any): any;

                static Duplex: any;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static PassThrough: any;

                static Readable: any;

                static Stream: any;

                static Transform: any;

                static Writable: any;

                static addAbortSignal: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static compose: any;

                static defaultMaxListeners: any;

                static destroy: any;

                static errorMonitor: any;

                static finished: any;

                static getEventListeners: any;

                static init: any;

                static isDisturbed: any;

                static isErrored: any;

                static isReadable: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static pipeline: any;

                static promises: any;

                static setMaxListeners: any;

                static usingDomains: any;

            }

            class Transform {
                constructor(options: any);

                static Duplex: any;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static PassThrough: any;

                static Readable: any;

                static ReadableState: any;

                static Stream: any;

                static Transform: any;

                static Writable: any;

                static addAbortSignal: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static compose: any;

                static defaultMaxListeners: any;

                static destroy: any;

                static errorMonitor: any;

                static finished: any;

                static from: any;

                static getEventListeners: any;

                static init: any;

                static isDisturbed: any;

                static isErrored: any;

                static isReadable: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static pipeline: any;

                static promises: any;

                static setMaxListeners: any;

                static usingDomains: any;

                static wrap: any;

            }

            namespace promises {
                // Too-deep object hierarchy from fs.WriteStream.Writable.PassThrough.promises
                const finished: any;

                // Too-deep object hierarchy from fs.WriteStream.Writable.PassThrough.promises
                const pipeline: any;

            }

        }

        namespace Readable {
            class Duplex {
                constructor(options: any);

                cork(): void;

                end(chunk: any, encoding: any, cb: any): any;

                setDefaultEncoding(encoding: any): any;

                uncork(): void;

                write(chunk: any, encoding: any, cb: any): any;

                static Duplex: any;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static PassThrough: any;

                static Readable: any;

                static ReadableState: any;

                static Stream: any;

                static Transform: any;

                static Writable: any;

                static addAbortSignal: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static compose: any;

                static defaultMaxListeners: any;

                static destroy: any;

                static errorMonitor: any;

                static finished: any;

                static from: any;

                static getEventListeners: any;

                static init: any;

                static isDisturbed: any;

                static isErrored: any;

                static isReadable: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static pipeline: any;

                static promises: any;

                static setMaxListeners: any;

                static usingDomains: any;

                static wrap: any;

            }

            class EventEmitter {
                constructor(opts: any);

                addListener(type: any, listener: any): any;

                emit(type: any, args: any): any;

                eventNames(): any;

                getMaxListeners(): any;

                listenerCount(type: any): any;

                listeners(type: any): any;

                off(type: any, listener: any): any;

                on(type: any, listener: any): any;

                once(type: any, listener: any): any;

                prependListener(type: any, listener: any): any;

                prependOnceListener(type: any, listener: any): any;

                rawListeners(type: any): any;

                removeAllListeners(type: any, ...args: any[]): any;

                removeListener(type: any, listener: any): any;

                setMaxListeners(n: any): any;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static defaultMaxListeners: any;

                static errorMonitor: any;

                static getEventListeners: any;

                static init: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static setMaxListeners: any;

                static usingDomains: any;

            }

            class EventEmitterAsyncResource {
                constructor(...args: any[]);

                emit(...args: any[]): void;

                emitDestroy(...args: any[]): void;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static defaultMaxListeners: any;

                static errorMonitor: any;

                static getEventListeners: any;

                static init: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static setMaxListeners: any;

                static usingDomains: any;

            }

            class PassThrough {
                constructor(options: any);

                static Duplex: any;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static PassThrough: any;

                static Readable: any;

                static ReadableState: any;

                static Stream: any;

                static Transform: any;

                static Writable: any;

                static addAbortSignal: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static compose: any;

                static defaultMaxListeners: any;

                static destroy: any;

                static errorMonitor: any;

                static finished: any;

                static from: any;

                static getEventListeners: any;

                static init: any;

                static isDisturbed: any;

                static isErrored: any;

                static isReadable: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static pipeline: any;

                static promises: any;

                static setMaxListeners: any;

                static usingDomains: any;

                static wrap: any;

            }

            class ReadableState {
                constructor(options: any, stream: any, isDuplex: any);

            }

            class Stream {
                constructor(opts: any);

                pipe(dest: any, options: any): any;

                static Duplex: any;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static PassThrough: any;

                static Readable: any;

                static Stream: any;

                static Transform: any;

                static Writable: any;

                static addAbortSignal: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static compose: any;

                static defaultMaxListeners: any;

                static destroy: any;

                static errorMonitor: any;

                static finished: any;

                static getEventListeners: any;

                static init: any;

                static isDisturbed: any;

                static isErrored: any;

                static isReadable: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static pipeline: any;

                static promises: any;

                static setMaxListeners: any;

                static usingDomains: any;

            }

            class Transform {
                constructor(options: any);

                static Duplex: any;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static PassThrough: any;

                static Readable: any;

                static ReadableState: any;

                static Stream: any;

                static Transform: any;

                static Writable: any;

                static addAbortSignal: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static compose: any;

                static defaultMaxListeners: any;

                static destroy: any;

                static errorMonitor: any;

                static finished: any;

                static from: any;

                static getEventListeners: any;

                static init: any;

                static isDisturbed: any;

                static isErrored: any;

                static isReadable: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static pipeline: any;

                static promises: any;

                static setMaxListeners: any;

                static usingDomains: any;

                static wrap: any;

            }

            namespace promises {
                // Too-deep object hierarchy from fs.WriteStream.Writable.Readable.promises
                const finished: any;

                // Too-deep object hierarchy from fs.WriteStream.Writable.Readable.promises
                const pipeline: any;

            }

        }

        namespace Stream {
            class Duplex {
                constructor(options: any);

                cork(): void;

                end(chunk: any, encoding: any, cb: any): any;

                setDefaultEncoding(encoding: any): any;

                uncork(): void;

                write(chunk: any, encoding: any, cb: any): any;

                static Duplex: any;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static PassThrough: any;

                static Readable: any;

                static ReadableState: any;

                static Stream: any;

                static Transform: any;

                static Writable: any;

                static addAbortSignal: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static compose: any;

                static defaultMaxListeners: any;

                static destroy: any;

                static errorMonitor: any;

                static finished: any;

                static from: any;

                static getEventListeners: any;

                static init: any;

                static isDisturbed: any;

                static isErrored: any;

                static isReadable: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static pipeline: any;

                static promises: any;

                static setMaxListeners: any;

                static usingDomains: any;

                static wrap: any;

            }

            class EventEmitter {
                constructor(opts: any);

                addListener(type: any, listener: any): any;

                emit(type: any, args: any): any;

                eventNames(): any;

                getMaxListeners(): any;

                listenerCount(type: any): any;

                listeners(type: any): any;

                off(type: any, listener: any): any;

                on(type: any, listener: any): any;

                once(type: any, listener: any): any;

                prependListener(type: any, listener: any): any;

                prependOnceListener(type: any, listener: any): any;

                rawListeners(type: any): any;

                removeAllListeners(type: any, ...args: any[]): any;

                removeListener(type: any, listener: any): any;

                setMaxListeners(n: any): any;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static defaultMaxListeners: any;

                static errorMonitor: any;

                static getEventListeners: any;

                static init: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static setMaxListeners: any;

                static usingDomains: any;

            }

            class EventEmitterAsyncResource {
                constructor(...args: any[]);

                emit(...args: any[]): void;

                emitDestroy(...args: any[]): void;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static defaultMaxListeners: any;

                static errorMonitor: any;

                static getEventListeners: any;

                static init: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static setMaxListeners: any;

                static usingDomains: any;

            }

            class PassThrough {
                constructor(options: any);

                static Duplex: any;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static PassThrough: any;

                static Readable: any;

                static ReadableState: any;

                static Stream: any;

                static Transform: any;

                static Writable: any;

                static addAbortSignal: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static compose: any;

                static defaultMaxListeners: any;

                static destroy: any;

                static errorMonitor: any;

                static finished: any;

                static from: any;

                static getEventListeners: any;

                static init: any;

                static isDisturbed: any;

                static isErrored: any;

                static isReadable: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static pipeline: any;

                static promises: any;

                static setMaxListeners: any;

                static usingDomains: any;

                static wrap: any;

            }

            class Readable {
                constructor(options: any);

                addListener(ev: any, fn: any): any;

                destroy(err: any, cb: any): any;

                filter(args: any): any;

                isPaused(): any;

                iterator(options: any): any;

                map(args: any): any;

                off(ev: any, fn: any): any;

                on(ev: any, fn: any): any;

                pause(): any;

                pipe(dest: any, pipeOpts: any): any;

                push(chunk: any, encoding: any): any;

                read(n: any): any;

                removeAllListeners(ev: any, ...args: any[]): any;

                removeListener(ev: any, fn: any): any;

                resume(): any;

                setEncoding(enc: any): any;

                unpipe(dest: any): any;

                unshift(chunk: any, encoding: any): any;

                wrap(stream: any): any;

                static Duplex: any;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static PassThrough: any;

                static Readable: any;

                static ReadableState: any;

                static Stream: any;

                static Transform: any;

                static Writable: any;

                static addAbortSignal: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static compose: any;

                static defaultMaxListeners: any;

                static destroy: any;

                static errorMonitor: any;

                static finished: any;

                static from: any;

                static getEventListeners: any;

                static init: any;

                static isDisturbed: any;

                static isErrored: any;

                static isReadable: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static pipeline: any;

                static promises: any;

                static setMaxListeners: any;

                static usingDomains: any;

                static wrap: any;

            }

            class Transform {
                constructor(options: any);

                static Duplex: any;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static PassThrough: any;

                static Readable: any;

                static ReadableState: any;

                static Stream: any;

                static Transform: any;

                static Writable: any;

                static addAbortSignal: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static compose: any;

                static defaultMaxListeners: any;

                static destroy: any;

                static errorMonitor: any;

                static finished: any;

                static from: any;

                static getEventListeners: any;

                static init: any;

                static isDisturbed: any;

                static isErrored: any;

                static isReadable: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static pipeline: any;

                static promises: any;

                static setMaxListeners: any;

                static usingDomains: any;

                static wrap: any;

            }

            namespace promises {
                // Too-deep object hierarchy from fs.WriteStream.Writable.Stream.promises
                const finished: any;

                // Too-deep object hierarchy from fs.WriteStream.Writable.Stream.promises
                const pipeline: any;

            }

        }

        namespace Transform {
            class Duplex {
                constructor(options: any);

                cork(): void;

                end(chunk: any, encoding: any, cb: any): any;

                setDefaultEncoding(encoding: any): any;

                uncork(): void;

                write(chunk: any, encoding: any, cb: any): any;

                static Duplex: any;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static PassThrough: any;

                static Readable: any;

                static ReadableState: any;

                static Stream: any;

                static Transform: any;

                static Writable: any;

                static addAbortSignal: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static compose: any;

                static defaultMaxListeners: any;

                static destroy: any;

                static errorMonitor: any;

                static finished: any;

                static from: any;

                static getEventListeners: any;

                static init: any;

                static isDisturbed: any;

                static isErrored: any;

                static isReadable: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static pipeline: any;

                static promises: any;

                static setMaxListeners: any;

                static usingDomains: any;

                static wrap: any;

            }

            class EventEmitter {
                constructor(opts: any);

                addListener(type: any, listener: any): any;

                emit(type: any, args: any): any;

                eventNames(): any;

                getMaxListeners(): any;

                listenerCount(type: any): any;

                listeners(type: any): any;

                off(type: any, listener: any): any;

                on(type: any, listener: any): any;

                once(type: any, listener: any): any;

                prependListener(type: any, listener: any): any;

                prependOnceListener(type: any, listener: any): any;

                rawListeners(type: any): any;

                removeAllListeners(type: any, ...args: any[]): any;

                removeListener(type: any, listener: any): any;

                setMaxListeners(n: any): any;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static defaultMaxListeners: any;

                static errorMonitor: any;

                static getEventListeners: any;

                static init: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static setMaxListeners: any;

                static usingDomains: any;

            }

            class EventEmitterAsyncResource {
                constructor(...args: any[]);

                emit(...args: any[]): void;

                emitDestroy(...args: any[]): void;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static defaultMaxListeners: any;

                static errorMonitor: any;

                static getEventListeners: any;

                static init: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static setMaxListeners: any;

                static usingDomains: any;

            }

            class PassThrough {
                constructor(options: any);

                static Duplex: any;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static PassThrough: any;

                static Readable: any;

                static ReadableState: any;

                static Stream: any;

                static Transform: any;

                static Writable: any;

                static addAbortSignal: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static compose: any;

                static defaultMaxListeners: any;

                static destroy: any;

                static errorMonitor: any;

                static finished: any;

                static from: any;

                static getEventListeners: any;

                static init: any;

                static isDisturbed: any;

                static isErrored: any;

                static isReadable: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static pipeline: any;

                static promises: any;

                static setMaxListeners: any;

                static usingDomains: any;

                static wrap: any;

            }

            class Readable {
                constructor(options: any);

                addListener(ev: any, fn: any): any;

                destroy(err: any, cb: any): any;

                filter(args: any): any;

                isPaused(): any;

                iterator(options: any): any;

                map(args: any): any;

                off(ev: any, fn: any): any;

                on(ev: any, fn: any): any;

                pause(): any;

                pipe(dest: any, pipeOpts: any): any;

                push(chunk: any, encoding: any): any;

                read(n: any): any;

                removeAllListeners(ev: any, ...args: any[]): any;

                removeListener(ev: any, fn: any): any;

                resume(): any;

                setEncoding(enc: any): any;

                unpipe(dest: any): any;

                unshift(chunk: any, encoding: any): any;

                wrap(stream: any): any;

                static Duplex: any;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static PassThrough: any;

                static Readable: any;

                static ReadableState: any;

                static Stream: any;

                static Transform: any;

                static Writable: any;

                static addAbortSignal: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static compose: any;

                static defaultMaxListeners: any;

                static destroy: any;

                static errorMonitor: any;

                static finished: any;

                static from: any;

                static getEventListeners: any;

                static init: any;

                static isDisturbed: any;

                static isErrored: any;

                static isReadable: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static pipeline: any;

                static promises: any;

                static setMaxListeners: any;

                static usingDomains: any;

                static wrap: any;

            }

            class ReadableState {
                constructor(options: any, stream: any, isDuplex: any);

            }

            class Stream {
                constructor(opts: any);

                pipe(dest: any, options: any): any;

                static Duplex: any;

                static EventEmitter: any;

                static EventEmitterAsyncResource: any;

                static PassThrough: any;

                static Readable: any;

                static Stream: any;

                static Transform: any;

                static Writable: any;

                static addAbortSignal: any;

                static captureRejectionSymbol: any;

                static captureRejections: any;

                static compose: any;

                static defaultMaxListeners: any;

                static destroy: any;

                static errorMonitor: any;

                static finished: any;

                static getEventListeners: any;

                static init: any;

                static isDisturbed: any;

                static isErrored: any;

                static isReadable: any;

                static kMaxEventTargetListeners: any;

                static kMaxEventTargetListenersWarned: any;

                static listenerCount: any;

                static on: any;

                static once: any;

                static pipeline: any;

                static promises: any;

                static setMaxListeners: any;

                static usingDomains: any;

            }

            namespace promises {
                // Too-deep object hierarchy from fs.WriteStream.Writable.Transform.promises
                const finished: any;

                // Too-deep object hierarchy from fs.WriteStream.Writable.Transform.promises
                const pipeline: any;

            }

        }

        namespace promises {
            function finished(stream: any, opts: any): any;

            function pipeline(streams: any): any;

        }

    }

    namespace promises {
        function finished(stream: any, opts: any): any;

        function pipeline(streams: any): any;

    }

}

export namespace promises {
    function access(path: any, mode: any): any;

    function appendFile(path: any, data: any, options: any): any;

    function chmod(path: any, mode: any): any;

    function chown(path: any, uid: any, gid: any): any;

    function copyFile(src: any, dest: any, mode: any): any;

    function cp(src: any, dest: any, options: any): any;

    function lchmod(path: any, mode: any): any;

    function lchown(path: any, uid: any, gid: any): any;

    function link(existingPath: any, newPath: any): any;

    function lstat(path: any, options: any): any;

    function lutimes(path: any, atime: any, mtime: any): any;

    function mkdir(path: any, options: any): any;

    function mkdtemp(prefix: any, options: any): any;

    function open(path: any, flags: any, mode: any): any;

    function opendir(args: any): any;

    function readFile(path: any, options: any): any;

    function readdir(path: any, options: any): any;

    function readlink(path: any, options: any): any;

    function realpath(path: any, options: any): any;

    function rename(oldPath: any, newPath: any): any;

    function rm(path: any, options: any): any;

    function rmdir(path: any, options: any): any;

    function stat(path: any, options: any): any;

    function symlink(target: any, path: any, type_: any): any;

    function truncate(path: any, len: any): any;

    function unlink(path: any): any;

    function utimes(path: any, atime: any, mtime: any): any;

    function watch(filename: any, options: any): void;

    function writeFile(path: any, data: any, options: any): any;

}

